\documentclass{lmcs}

%% mandatory list of keywords
\keywords{Seifert-van Kampen theorem, computational paths, fundamental group, pushouts, free products, type theory, axiom-free formalization}

%% MSC 2020 classification
\subjclass[2020]{Primary: 55Q05; Secondary: 03B38, 18N10, 68V15}

%% additional packages (only those not included in lmcs.cls)
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{tikz-cd}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{amsthm}

%% Theorem-like environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}[definition]{Example}
\theoremstyle{plain}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{proposition}[definition]{Proposition}
\theoremstyle{remark}
\newtheorem{remark}[definition]{Remark}

%% Custom commands
\newcommand{\Id}{\mathrm{Id}}
\newcommand{\refl}{\rho}
\newcommand{\sym}{\sigma}
\newcommand{\tmark}{\tau}
\newcommand{\Rw}{\rightsquigarrow}
\newcommand{\RwEq}{\sim}
\newcommand{\Path}{\mathrm{Path}}
\newcommand{\piOne}{\pi_1}
\newcommand{\piTwo}{\pi_2}
\newcommand{\piN}{\pi_n}
\newcommand{\Pushout}{\mathrm{Pushout}}
\newcommand{\Wedge}{\vee}
\newcommand{\Susp}{\Sigma}
\newcommand{\inl}{\mathrm{inl}}
\newcommand{\inr}{\mathrm{inr}}
\newcommand{\glmark}{\mathrm{glue}}
\newcommand{\decode}{\mathrm{decode}}
\newcommand{\encode}{\mathrm{encode}}
\newcommand{\FreeProduct}{\ast}
\newcommand{\AmalgProduct}{\ast}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\Sone}{S^1}
\newcommand{\Stwo}{S^2}
\newcommand{\Sthree}{S^3}
\newcommand{\Sfour}{S^4}
\newcommand{\Der}{\mathcal{D}}
\newcommand{\Fiber}{\mathrm{Fiber}}
\newcommand{\LoopSp}{\Omega}
\newcommand{\Loop}{\mathrm{Loop}}

%% Notation: We use \simeq for type-theoretic equivalences and \cong for
%% classical group isomorphisms when referring to the traditional literature.

%% Lean code listings
\lstdefinelanguage{Lean}{
  keywords={def, theorem, lemma, axiom, structure, inductive, where, let, in, have, show, by, exact, apply, intro, cases, induction, rfl, simp, calc, fun, noncomputable, abbrev, namespace, end, open, variable, section, Type, Prop, Sort, class, instance, deriving},
  sensitive=true,
  morecomment=[l]{--},
  morecomment=[s]{/-}{-/},
  morestring=[b]",
}
\lstset{
  language=Lean,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries,
  commentstyle=\itshape\color{gray},
  breaklines=true,
  frame=single,
  xleftmargin=2em,
  framexleftmargin=1.5em,
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt
}

\begin{document}

\title[The Seifert-van Kampen Theorem via Computational Paths]{The Seifert-van Kampen Theorem via Computational Paths: An Axiom-Free Formalization}

\author[A.~F.~Ramos]{Arthur F. Ramos}
\address{Microsoft, USA}
\email{arfreita@microsoft.com}

\author[T.~M.~L.~de~Veras]{Tiago M. L. de Veras}
\address{Departamento de Matem\'atica, Universidade Federal Rural de Pernambuco, Brazil}
\email{tiago.veras@ufrpe.br}

\author[R.~J.~G.~B.~de~Queiroz]{Ruy J. G. B. de Queiroz}
\address{Centro de Inform\'atica, Universidade Federal de Pernambuco, Brazil}
\email{ruy@cin.ufpe.br}

\author[A.~G.~de~Oliveira]{Anjolina G. de Oliveira}
\address{Centro de Inform\'atica, Universidade Federal de Pernambuco, Brazil}
\email{ago@cin.ufpe.br}

\begin{abstract}
The Seifert-van Kampen theorem computes the fundamental group of a space from the fundamental groups of its constituents. We develop an \textbf{axiom-free} formalization of the SVK framework within the setting of \emph{computational paths}---an approach to equality where witnesses are explicit sequences of rewrites governed by the $\mathrm{LND}_{\mathrm{EQ}}$-TRS.

Our key innovation is replacing higher-inductive types (HITs) with \emph{computational path structures}: purely definitional constructions where spaces are single-point types equipped with syntactic path expressions. This eliminates all kernel axioms while preserving the same fundamental group computations.

Our contributions are: (i) pushouts as quotients of sum types with \emph{zero kernel axioms}; (ii) the circle, sphere, and torus defined via computational path expressions rather than HIT axioms; (iii) contractibility derived from Lean's proof-irrelevant \texttt{Prop} via \texttt{Subsingleton.elim}, not axiomatized; (iv) an SVK equivalence schema $\piOne(\Pushout(A,B,C)) \simeq \piOne(A) \AmalgProduct_{\piOne(C)} \piOne(B)$; and (v) instantiations for classical spaces: the circle ($\piOne(\Sone) \simeq \ZZ$), torus ($\piOne(T^2) \simeq \ZZ \times \ZZ$), spheres ($\piOne(S^n) \simeq 1$ for $n \geq 2$), and figure-eight ($\piOne(\Sone \Wedge \Sone) \simeq \ZZ \FreeProduct \ZZ$).

The development is formalized in Lean 4 with \textbf{28,623 lines} across \textbf{92 modules}, using \textbf{zero kernel axioms} beyond Lean's built-in \texttt{Prop}. This demonstrates that significant results in algebraic topology can be achieved without extending the type theory's trusted kernel.
\end{abstract}

\maketitle

%==============================================================================
\section{Introduction}
\label{sec:introduction}
%==============================================================================

The Seifert-van Kampen theorem, first proved by Herbert Seifert \cite{Seifert1931} and Egbert van Kampen \cite{vanKampen1933}, is one of the most powerful tools in algebraic topology for computing fundamental groups. It states that if a path-connected space $X$ is the union of two path-connected open subspaces $U$ and $V$ with path-connected intersection $U \cap V$, then the fundamental group $\piOne(X)$ can be computed as the amalgamated free product:
\[
\piOne(X) \cong \piOne(U) \AmalgProduct_{\piOne(U \cap V)} \piOne(V)
\]

In homotopy type theory (HoTT) \cite{HoTTBook2013}, this theorem takes a particularly elegant form when expressed in terms of \emph{pushouts}---a higher-inductive type (HIT) that generalizes the notion of gluing spaces together. However, HIT-based formalizations typically require \emph{kernel axioms}: trusted declarations that extend the type theory's core. This raises questions about both foundational minimality and practical implementation in proof assistants without native HIT support.

The present paper develops an \textbf{axiom-free} SVK framework within the setting of \emph{computational paths} \cite{Queiroz2016Paths, Ramos2017IdentityPaths}---an alternative approach to equality in type theory where witnesses of equality are explicit sequences of rewrites. Our key innovation is the replacement of higher-inductive types with \emph{computational path structures}:

\begin{center}
\fbox{\parbox{0.85\textwidth}{
\textbf{Central Insight}: A space like the circle $\Sone$ can be defined as a \emph{single-point type} equipped with a \emph{syntactic algebra of path expressions} that includes a formal loop generator. The fundamental group emerges as a quotient of these expressions by rewrite equality---without any kernel axioms.
}}
\end{center}

This approach offers several advantages:

\begin{enumerate}
    \item \textbf{Zero kernel axioms}: The entire formalization uses only Lean's built-in types and \texttt{Prop}. No trusted kernel extensions are required.

    \item \textbf{Derived contractibility}: Rather than axiomatizing that certain types are contractible, we \emph{derive} contractibility from Lean's proof-irrelevant \texttt{Prop} via \texttt{Subsingleton.elim}. For instance, $\piOne(S^2) = 1$ follows because the 2-sphere is a \texttt{Subsingleton}.

    \item \textbf{Explicit witnesses}: Every equality proof carries the full computational content showing \emph{why} two terms are equal as a sequence of rewrite steps.

    \item \textbf{Syntactic path equality}: The rewrite equality relation ($\RwEq$) is defined as the symmetric-transitive closure of Step rules, providing a decidable (under termination and confluence) equivalence on path expressions.
\end{enumerate}

\subsection{From HITs to Computational Path Structures}

The traditional HoTT approach defines the circle as a higher-inductive type with:
\begin{itemize}
    \item A point constructor: $\mathrm{base} : \Sone$
    \item A path constructor: $\mathrm{loop} : \mathrm{base} = \mathrm{base}$
\end{itemize}

In a proof assistant without native HITs (like standard Lean 4), this requires kernel axioms to postulate both the type and its path constructor.

Our computational path approach instead defines:
\begin{itemize}
    \item A single-point type: \texttt{CircleCompPath} with constructor \texttt{base}
    \item A syntactic algebra: \texttt{CircleCompPathExpr} with a formal \texttt{loop} generator
    \item A quotient: Expressions modulo rewrite equality (by winding number)
\end{itemize}

The fundamental group computation $\piOne(\Sone) \simeq \ZZ$ emerges from encoding path expressions as winding numbers---all within the standard type theory.

\subsection{Main Contributions}

This paper provides:

\begin{enumerate}
    \item \textbf{Axiom-free pushouts}: Pushouts implemented as quotients of sum types using Lean's built-in \texttt{Quot}, with point and glue constructors as definitions (not axioms).

    \item \textbf{Computational path spaces}: The circle, sphere, and torus defined via syntactic path expression algebras:
    \begin{itemize}
        \item \texttt{CircleCompPath}: Single-point type with \texttt{CircleCompPathExpr} (formal loop generator)
        \item \texttt{Sphere2CompPath}: Suspension of circle, a \texttt{Subsingleton}
        \item \texttt{Torus}: Product $\Sone \times \Sone$ (uses circle definition)
    \end{itemize}

    \item \textbf{Derived triviality}: For spheres $S^n$ ($n \geq 2$), the fundamental group is trivial because the type is a \texttt{Subsingleton}---no axioms needed:
    \begin{lstlisting}
instance : Subsingleton Sphere2CompPath where
  allEq x y := by ... -- uses Quot.sound on pushout relation
    \end{lstlisting}

    \item \textbf{Free products and amalgamated free products}: Word-based representations with the SVK equivalence:
    \[
    \piOne(\Pushout(A, B, C, f, g)) \simeq \piOne(A) \AmalgProduct_{\piOne(C)} \piOne(B)
    \]

    \item \textbf{Applications}:
    \begin{itemize}
        \item Circle: $\piOne(\Sone) \simeq \ZZ$
        \item Torus: $\piOne(T^2) \simeq \ZZ \times \ZZ$
        \item Spheres: $\piOne(S^n) \simeq 1$ for $n \geq 2$
        \item Figure-eight: $\piOne(\Sone \Wedge \Sone) \simeq \ZZ \FreeProduct \ZZ$
    \end{itemize}

    \item \textbf{Complete Lean 4 formalization}: 28,623 lines across 92 modules with \textbf{zero kernel axioms}.
\end{enumerate}

\subsection{Related Work}

The Seifert-van Kampen theorem in HoTT was first formalized by Favonia and Shulman \cite{FavoniaShulman2016}. Their work uses HITs with kernel axioms. The computational paths approach originates in work by de Queiroz and colleagues \cite{Queiroz2016Paths, Ramos2017IdentityPaths, Ramos2018ExplicitPaths}, building on earlier ideas about equality proofs as sequences of rewrites \cite{Ruy4}. Our previous work established that computational paths form a weak groupoid \cite{Veras2023WeakGroupoid} and can be used to calculate fundamental groups \cite{Veras2018FundamentalGroups, Veras2023Topological}.

The key novelty of the present work is demonstrating that \emph{all} the algebraic topology results can be achieved \textbf{without any kernel axioms}, by replacing HITs with computational path structures.

\subsection{Reading Guide}

Readers interested in the mathematical content can focus on Sections~\ref{sec:pushouts}--\ref{sec:applications}, treating Lean code as pseudocode. Those interested in the axiom-free methodology should consult Section~\ref{sec:comppath-spaces} carefully. We use the figure-eight space $\Sone \Wedge \Sone$ as a running example throughout.

\subsection{Structure of the Paper}

Section~\ref{sec:background} reviews computational paths, rewrite equality, and fundamental groups. Section~\ref{sec:comppath-spaces} presents the key innovation: computational path structures for the circle, sphere, and torus. Section~\ref{sec:pushouts} defines pushouts as quotients. Section~\ref{sec:freeproducts} constructs free products and amalgamated free products. Section~\ref{sec:svk} proves the Seifert-van Kampen theorem. Section~\ref{sec:applications} applies the theorem to compute fundamental groups. Section~\ref{sec:lean} discusses the Lean 4 formalization. Section~\ref{sec:conclusion} concludes.

%==============================================================================
\section{Background: Computational Paths}
\label{sec:background}
%==============================================================================

\subsection{Computational Paths}

A \emph{computational path} $p : \Path(a, b)$ from $a$ to $b$ (both terms of type $A$) is an explicit sequence of rewrite steps witnessing the equality $a = b$. The fundamental operations are:

\begin{itemize}
    \item \textbf{Reflexivity}: $\refl(a) : \Path(a, a)$ --- the empty sequence of rewrites.
    \item \textbf{Symmetry}: If $p : \Path(a, b)$, then $\sym(p) : \Path(b, a)$ --- reverse and invert each step.
    \item \textbf{Transitivity}: If $p : \Path(a, b)$ and $q : \Path(b, c)$, then $p \cdot q : \Path(a, c)$ --- concatenate the sequences.
    \item \textbf{Congruence}: If $p : \Path(a, b)$ and $f : A \to B$, then $f_*(p) : \Path(f(a), f(b))$.
    \item \textbf{Transport}: If $p : \Path(a, b)$ and $P : A \to \mathrm{Type}$, then $\mathrm{transport}(P, p) : P(a) \to P(b)$.
\end{itemize}

\paragraph{Notation.} Throughout this paper, we use:
\begin{itemize}
    \item $p \cdot q$ for path composition (transitivity)
    \item $p^{-1}$ for path inverse (symmetry)
    \item $f_*(p)$ for $\mathrm{congrArg}(f, p)$
    \item $\refl(a)$ or simply $\refl$ for reflexivity
\end{itemize}

In Lean, a path is represented as a structure:
\begin{lstlisting}
structure Path {A : Type u} (a b : A) where
  proof : a = b
\end{lstlisting}

\begin{remark}[Path Identity via Proof Irrelevance]
\label{rem:proof-irrelevance}
In Lean's proof-irrelevant \texttt{Prop}, all equality proofs $p, q : a = b$ satisfy $p = q$. The fundamental group construction uses \emph{syntactic path expressions} (not raw equality proofs) as the carriers of computational content. The quotient by $\RwEq$ identifies expressions with the same ``winding number'' or normal form.
\end{remark}

\subsection{The Step Relation}

The foundation of the computational paths framework is the \texttt{Step} relation, which defines \emph{single-step rewrites} between paths. The $\mathrm{LND}_{\mathrm{EQ}}$-TRS consists of rewrite rules organized into categories:

\begin{itemize}
    \item \textbf{Groupoid laws}: $\refl^{-1} \Rw \refl$, $(p^{-1})^{-1} \Rw p$, $\refl \cdot p \Rw p$, $p \cdot \refl \Rw p$, $p \cdot p^{-1} \Rw \refl$, $p^{-1} \cdot p \Rw \refl$, $(p \cdot q)^{-1} \Rw q^{-1} \cdot p^{-1}$, and $(p \cdot q) \cdot r \Rw p \cdot (q \cdot r)$.
    \item \textbf{Type-specific rules}: $\beta$-rules for products, sums, and functions; $\eta$-rules; transport laws.
    \item \textbf{Context rules}: Allow rewrites inside larger expressions.
    \item \textbf{Congruence closure}: If $p \Rw q$ then $p^{-1} \Rw q^{-1}$, $p \cdot r \Rw q \cdot r$, etc.
\end{itemize}

\subsection{Rewrite Equality}

Two paths $p, q : \Path(a, b)$ are \emph{rewrite equal} ($p \RwEq q$) if they can be transformed into each other via the rewrite system:

\begin{lstlisting}
inductive RwEq {A : Type u} {a b : A} : Path a b -> Path a b -> Prop
  | refl (p : Path a b) : RwEq p p
  | step {p q : Path a b} : Step p q -> RwEq p q
  | symm {p q : Path a b} : RwEq p q -> RwEq q p
  | trans {p q r : Path a b} : RwEq p q -> RwEq q r -> RwEq p r
\end{lstlisting}

\subsection{Loop Spaces and Fundamental Groups}

\begin{definition}[Loop Space]
The \emph{loop space} of a type $A$ at a basepoint $a : A$ is:
\[
\Omega(A, a) := \Path(a, a)
\]
\end{definition}

\begin{definition}[Fundamental Group]
The \emph{fundamental group} $\piOne(A, a)$ is the quotient of the loop space by rewrite equality:
\[
\piOne(A, a) := \Omega(A, a) / {\RwEq}
\]
\end{definition}

In Lean:
\begin{lstlisting}
abbrev LoopSpace (A : Type u) (a : A) : Type u := Path a a

def PiOne (A : Type u) (a : A) : Type u := Quot (@RwEq A a a)

notation "pi_1(" A ", " a ")" => PiOne A a
\end{lstlisting}

%==============================================================================
\section{Computational Path Structures}
\label{sec:comppath-spaces}
%==============================================================================

This section presents our key innovation: defining topological spaces via \emph{computational path structures} rather than higher-inductive types. The approach eliminates all kernel axioms while preserving the same fundamental group computations.

\subsection{The Circle via Computational Paths}

\begin{definition}[Computational Circle]
\label{def:circle-comppath}
The computational circle consists of:
\begin{enumerate}
    \item A \textbf{single-point carrier type}:
    \begin{lstlisting}
inductive CircleCompPath : Type u
  | base : CircleCompPath
    \end{lstlisting}

    \item A \textbf{path expression algebra} with a formal loop generator:
    \begin{lstlisting}
inductive CircleCompPathExpr : CircleCompPath -> CircleCompPath -> Type u
  | loop : CircleCompPathExpr base base
  | refl (a : CircleCompPath) : CircleCompPathExpr a a
  | symm (p : CircleCompPathExpr a b) : CircleCompPathExpr b a
  | trans (p : CircleCompPathExpr a b) (q : CircleCompPathExpr b c) :
      CircleCompPathExpr a c
    \end{lstlisting}

    \item A \textbf{quotient} of loop expressions by winding number:
    \begin{lstlisting}
def circleCompPathRel (p q : CircleCompPathExpr base base) : Prop :=
  circleCompPathEncodeExpr' p = circleCompPathEncodeExpr' q

abbrev circleCompPathPiOne : Type u :=
  Quot circleCompPathSetoid.r
    \end{lstlisting}
\end{enumerate}
\end{definition}

The \textbf{winding number} function counts net loop traversals:
\begin{lstlisting}
noncomputable def circleCompPathEncodeExpr' :
    CircleCompPathExpr base base -> Int
  | loop => 1
  | refl _ => 0
  | symm p => -circleCompPathEncodeExpr' p
  | trans p q => circleCompPathEncodeExpr' p + circleCompPathEncodeExpr' q
\end{lstlisting}

\begin{theorem}[Fundamental Group of Computational Circle]
\label{thm:circle-pi1}
$\piOne(\Sone) \simeq \ZZ$
\end{theorem}

\begin{proof}
The encode-decode equivalence is established without axioms:
\begin{lstlisting}
noncomputable def circleCompPathPiOneEquivInt :
    SimpleEquiv circleCompPathPiOne Int where
  toFun := circleCompPathEncode      -- winding number
  invFun := circleCompPathDecode     -- integer -> loop^n
  left_inv := circleCompPathDecodeEncode
  right_inv := circleCompPathEncodeDecode
\end{lstlisting}
The round-trip properties follow from the arithmetic of winding numbers.
\end{proof}

\begin{remark}[No Kernel Axioms]
Unlike HIT-based circle definitions which require axioms for the type, base point, loop, and recursion principle, \texttt{CircleCompPath} is a standard inductive type with one constructor. The ``loop'' exists only at the \emph{expression level}, not as a kernel-trusted path constructor.
\end{remark}

\subsection{The 2-Sphere via Suspension}

\begin{definition}[Computational 2-Sphere]
\label{def:sphere-comppath}
The computational 2-sphere is defined as the suspension of the computational circle:
\begin{lstlisting}
def SuspensionCompPath (A : Type u) : Type u :=
  PushoutCompPath PUnit' PUnit' A (fun _ => PUnit'.unit) (fun _ => PUnit'.unit)

def Sphere2CompPath : Type u := SuspensionCompPath CircleCompPath
\end{lstlisting}
\end{definition}

The key insight is that $S^2$ is a \textbf{subsingleton}---all points are equal:

\begin{lstlisting}
instance : Subsingleton Sphere2CompPath where
  allEq x y := by
    refine Quot.inductionOn x ?_
    intro x'
    refine Quot.inductionOn y ?_
    intro y'
    cases x' <;> cases y' <;>
      first
        | rfl
        | exact Quot.sound (PushoutCompPathRel.glue circleCompPathBase)
        | exact (Quot.sound (PushoutCompPathRel.glue circleCompPathBase)).symm
\end{lstlisting}

\begin{theorem}[Fundamental Group of 2-Sphere]
\label{thm:sphere2-pi1}
$\piOne(S^2) \simeq 1$
\end{theorem}

\begin{proof}
Since \texttt{Sphere2CompPath} is a \texttt{Subsingleton}, all loops are trivial:
\begin{lstlisting}
theorem sphere2CompPath_pi1_trivial :
    forall (alpha : pi_1(Sphere2CompPath, basepoint)),
      alpha = Quot.mk _ (Path.refl _) := by
  exact pi1_trivial_of_subsingleton
\end{lstlisting}
This uses \texttt{Subsingleton.elim} from Lean's standard library---\textbf{no axioms}.
\end{proof}

\begin{remark}[Contractibility via Subsingleton]
\label{rem:contractibility}
In HIT-based approaches, proving $\piOne(S^2) = 1$ requires showing that the sphere is 1-connected, often via encode-decode or covering space arguments. Our approach is simpler: the pushout quotient construction directly yields a subsingleton type, and fundamental groups of subsingletons are trivially trivial.
\end{remark}

\subsection{The Torus as a Product}

\begin{definition}[Computational Torus]
\label{def:torus-comppath}
The torus is simply the product of two computational circles:
\begin{lstlisting}
abbrev Torus : Type u := Circle x Circle

noncomputable abbrev torusBase : Torus := (circleBase, circleBase)
\end{lstlisting}
\end{definition}

\begin{theorem}[Fundamental Group of Torus]
\label{thm:torus-pi1}
$\piOne(T^2) \simeq \ZZ \times \ZZ$
\end{theorem}

\begin{proof}
By the product formula for fundamental groups and the circle computation:
\begin{lstlisting}
noncomputable def torusPiOneEquivIntProd :
    SimpleEquiv torusPiOne (Int x Int) where
  toFun := torusPiOneEncode
  invFun := torusDecode
  left_inv := torusDecode_torusPiOneEncode
  right_inv := torusPiOneEncode_torusDecode
\end{lstlisting}
\end{proof}

\subsection{Summary: Axiom-Free Space Definitions}

\begin{table}[h]
\centering
\caption{Computational path structures vs.\ HIT definitions}
\label{tab:comppath-vs-hit}
\begin{tabular}{llcc}
\toprule
\textbf{Space} & \textbf{Construction} & \textbf{HITs (axioms)} & \textbf{CompPath (axioms)} \\
\midrule
Circle $\Sone$ & Path expressions with loop & 7 & 0 \\
Sphere $S^2$ & Suspension of $\Sone$ & 0 (via Pushout) & 0 \\
Torus $T^2$ & $\Sone \times \Sone$ & 0 (uses Circle) & 0 \\
Wedge $A \Wedge B$ & Pushout over $\mathbf{1}$ & 0 & 0 \\
Figure-eight & $\Sone \Wedge \Sone$ & 0 & 0 \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Pushouts as Quotients}
\label{sec:pushouts}
%==============================================================================

\subsection{The Pushout Type}

Given types $A$, $B$, $C$ with maps $f : C \to A$ and $g : C \to B$, the \emph{pushout} $\Pushout(A, B, C, f, g)$ glues $A$ and $B$ together along the common image of $C$:

\begin{center}
\begin{tikzcd}
C \arrow[r, "g"] \arrow[d, "f"'] & B \arrow[d, "\inr"] \\
A \arrow[r, "\inl"'] & \Pushout(A, B, C, f, g)
\end{tikzcd}
\end{center}

\begin{definition}[Pushout via Quotient]
\label{def:pushout}
The pushout is implemented using Lean's built-in \texttt{Quot} type (\textbf{zero kernel axioms}):
\begin{lstlisting}
inductive PushoutCompPathRel (A B C : Type u) (f : C -> A) (g : C -> B)
    : Sum A B -> Sum A B -> Prop
  | glue (c : C) : PushoutCompPathRel A B C f g (Sum.inl (f c)) (Sum.inr (g c))

def PushoutCompPath (A B C : Type u) (f : C -> A) (g : C -> B) : Type u :=
  Quot (PushoutCompPathRel A B C f g)
\end{lstlisting}
\end{definition}

The constructors are \emph{definitions}, not axioms:
\begin{lstlisting}
def inl (a : A) : PushoutCompPath A B C f g := Quot.mk _ (Sum.inl a)
def inr (b : B) : PushoutCompPath A B C f g := Quot.mk _ (Sum.inr b)
def glue (c : C) : Path (inl (f c)) (inr (g c)) :=
  Path.ofEq (Quot.sound (PushoutCompPathRel.glue c))
\end{lstlisting}

\begin{remark}[Zero Kernel Axioms for Pushout]
Unlike HIT-based pushouts which require axioms for the path constructor, our \texttt{PushoutCompPath} uses only Lean's built-in quotient type. The glue path is constructed via \texttt{Quot.sound}, which is part of Lean's kernel (not an extension).
\end{remark}

\subsection{Wedge Sum and Suspension}

\begin{definition}[Wedge Sum]
The wedge sum $A \Wedge B$ identifies basepoints:
\begin{lstlisting}
def Wedge (A B : Type u) (a0 : A) (b0 : B) : Type u :=
  PushoutCompPath A B PUnit' (fun _ => a0) (fun _ => b0)
\end{lstlisting}
\end{definition}

\begin{definition}[Suspension]
The suspension $\Susp A$ adds north and south poles:
\begin{lstlisting}
def SuspensionCompPath (A : Type u) : Type u :=
  PushoutCompPath PUnit' PUnit' A (fun _ => PUnit'.unit) (fun _ => PUnit'.unit)
\end{lstlisting}
\end{definition}

%==============================================================================
\section{Free Products and Amalgamated Free Products}
\label{sec:freeproducts}
%==============================================================================

\subsection{Free Product Words}

\begin{definition}[Free Product Word]
A \emph{word} in the free product $G_1 \FreeProduct G_2$ is an alternating sequence:
\begin{lstlisting}
inductive FreeProductWord (G1 G2 : Type u) : Type u
  | nil : FreeProductWord G1 G2
  | consLeft (x : G1) (rest : FreeProductWord G1 G2)
  | consRight (y : G2) (rest : FreeProductWord G1 G2)
\end{lstlisting}
\end{definition}

\subsection{Amalgamated Free Product}

When $G_1$ and $G_2$ share a common subgroup $H$, the amalgamated free product $G_1 \AmalgProduct_H G_2$ identifies $i_1(h)$ with $i_2(h)$ for all $h : H$:

\begin{lstlisting}
inductive AmalgRelation (i1 : H -> G1) (i2 : H -> G2) :
    FreeProductWord G1 G2 -> FreeProductWord G1 G2 -> Prop
  | amalgLeftToRight (h : H) (pre suf : FreeProductWord G1 G2) :
      AmalgRelation i1 i2
        (concat pre (concat (singleLeft (i1 h)) suf))
        (concat pre (concat (singleRight (i2 h)) suf))

def AmalgamatedFreeProduct (G1 G2 H : Type u) (i1 : H -> G1) (i2 : H -> G2) :=
  Quot (EqvGen (AmalgRelation i1 i2))
\end{lstlisting}

%==============================================================================
\section{The Seifert-van Kampen Theorem}
\label{sec:svk}
%==============================================================================

\subsection{Statement}

\begin{theorem}[Seifert-van Kampen]
\label{thm:svk}
Let $A$, $B$, $C$ be path-connected types with maps $f : C \to A$ and $g : C \to B$, and let $c_0 : C$. Then:
\[
\piOne(\Pushout(A, B, C, f, g), \inl(f(c_0))) \simeq
\piOne(A, f(c_0)) \AmalgProduct_{\piOne(C, c_0)} \piOne(B, g(c_0))
\]
\end{theorem}

\subsection{The Decode Map}

The decode map converts words to loops in the pushout:
\begin{lstlisting}
noncomputable def pushoutDecode (c0 : C) :
    FreeProductWord (pi_1(A, f c0)) (pi_1(B, g c0))
    -> pi_1(Pushout A B C f g, inl (f c0))
  | .nil => Quot.mk _ (Path.refl _)
  | .consLeft alpha rest =>
      piOneMul (liftLeft alpha) (pushoutDecode c0 rest)
  | .consRight beta rest =>
      piOneMul (conjugateRight beta) (pushoutDecode c0 rest)
\end{lstlisting}

where \texttt{conjugateRight} conjugates by the glue path:
\[
\beta \mapsto \glmark(c_0) \cdot \inr_*(\beta) \cdot \glmark(c_0)^{-1}
\]

\subsection{Decode Respects Amalgamation}

\begin{lemma}[Decode Respects Amalgamation]
\label{lem:decode-amalg}
For any $\gamma : \piOne(C, c_0)$:
\[
\decode(\mathrm{consLeft}(f_*(\gamma), w)) = \decode(\mathrm{consRight}(g_*(\gamma), w))
\]
\end{lemma}

\begin{proof}
This follows from glue naturality: $\inl_*(f_*(p)) \RwEq \glmark(c_0) \cdot \inr_*(g_*(p)) \cdot \glmark(c_0)^{-1}$.
\end{proof}

%==============================================================================
\section{Applications}
\label{sec:applications}
%==============================================================================

\begin{table}[h]
\centering
\caption{Summary of $\piOne$ calculations (all axiom-free)}
\label{tab:pi1-summary}
\begin{tabular}{llll}
\toprule
\textbf{Space} & \textbf{Fundamental Group} & \textbf{Method} & \textbf{Kernel Axioms} \\
\midrule
$\Sone$ (circle) & $\ZZ$ & Path expressions + winding & 0 \\
$T^2$ (torus) & $\ZZ \times \ZZ$ & Product of circles & 0 \\
$S^2$ (2-sphere) & $1$ & Suspension + Subsingleton & 0 \\
$\Sone \Wedge \Sone$ (figure-8) & $\ZZ \FreeProduct \ZZ$ & Wedge + SVK & 0 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{The Circle}

\begin{theorem}
$\piOne(\Sone) \simeq \ZZ$
\end{theorem}

\begin{proof}
The computational circle uses path expressions with a formal loop generator. The encode map computes winding numbers; decode maps integers to loop powers. See Theorem~\ref{thm:circle-pi1}.
\end{proof}

\subsection{The Torus}

\begin{theorem}
$\piOne(T^2) \simeq \ZZ \times \ZZ$
\end{theorem}

\begin{proof}
By the product formula:
\[
\piOne(A \times B, (a_0, b_0)) \simeq \piOne(A, a_0) \times \piOne(B, b_0)
\]
Applied with $A = B = \Sone$. See Theorem~\ref{thm:torus-pi1}.
\end{proof}

\subsection{The 2-Sphere}

\begin{theorem}
$\piOne(S^2) \simeq 1$
\end{theorem}

\begin{proof}
The computational 2-sphere is a \texttt{Subsingleton}, so all loops are trivial. See Theorem~\ref{thm:sphere2-pi1} and Remark~\ref{rem:contractibility}.
\end{proof}

\subsection{The Figure-Eight Space}

\begin{theorem}
$\piOne(\Sone \Wedge \Sone) \simeq \ZZ \FreeProduct \ZZ$
\end{theorem}

\begin{proof}
The figure-eight is the wedge of two circles. By SVK with trivial amalgamation (since $\piOne(\mathbf{1}) = 1$):
\[
\piOne(\Sone \Wedge \Sone) \simeq \piOne(\Sone) \FreeProduct \piOne(\Sone) \simeq \ZZ \FreeProduct \ZZ
\]
\end{proof}

The figure-eight has a \emph{non-abelian} fundamental group:
\begin{lstlisting}
def wordAB : FreeProductWord Int Int := .consLeft 1 (.consRight 1 .nil)
def wordBA : FreeProductWord Int Int := .consRight 1 (.consLeft 1 .nil)

theorem wordAB_ne_wordBA : wordAB != wordBA := by
  intro h; cases h  -- constructors are distinct
\end{lstlisting}

%==============================================================================
\section{The Lean 4 Formalization}
\label{sec:lean}
%==============================================================================

\subsection{Axiom-Free Design}

The central achievement of this formalization is that \textbf{zero kernel axioms} are required. All constructions use:
\begin{itemize}
    \item Standard inductive types (\texttt{inductive})
    \item Lean's built-in quotient type (\texttt{Quot})
    \item Proof-irrelevant \texttt{Prop}
    \item The \texttt{Subsingleton} typeclass and \texttt{Subsingleton.elim}
\end{itemize}

\begin{center}
\begin{tabular}{llp{7cm}}
\toprule
\textbf{Component} & \textbf{Implementation} & \textbf{Why Axiom-Free} \\
\midrule
Circle carrier & \texttt{inductive} (1 ctor) & Standard Lean \\
Circle paths & \texttt{inductive} expressions & Syntactic, not kernel path \\
$\piOne(\Sone)$ & \texttt{Quot} by winding & Built-in quotient \\
Pushout & \texttt{Quot} of \texttt{Sum} & Built-in quotient \\
$S^2$ triviality & \texttt{Subsingleton} & \texttt{Subsingleton.elim} \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Architecture}

The Lean 4 formalization is organized as follows:

\begin{center}
\begin{tabular}{ll}
\toprule
\textbf{Module} & \textbf{Content} \\
\midrule
\texttt{Path/Basic.lean} & Path type, refl, symm, trans \\
\texttt{Path/Rewrite/Step.lean} & Single-step rewrites \\
\texttt{Path/Rewrite/RwEq.lean} & Rewrite equality \\
\texttt{Path/Homotopy/FundamentalGroup.lean} & $\piOne$ definition \\
\texttt{Path/CompPath/CircleCompPath.lean} & Computational circle \\
\texttt{Path/CompPath/SphereCompPath.lean} & Computational sphere \\
\texttt{Path/CompPath/Torus.lean} & Torus as $\Sone \times \Sone$ \\
\texttt{Path/CompPath/PushoutCompPath.lean} & Quot-based pushout \\
\texttt{Path/CompPath/PushoutPaths.lean} & SVK framework \\
\texttt{Path/CompPath/FigureEight.lean} & Figure-eight \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Statistics}

\begin{center}
\begin{tabular}{lr}
\toprule
\textbf{Metric} & \textbf{Value} \\
\midrule
Total lines of Lean & 28,623 \\
Number of modules & 92 \\
Kernel axioms & \textbf{0} \\
Theorems/lemmas & 800+ \\
Definitions & 400+ \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Comparison with HIT-Based Approaches}

\begin{table}[h]
\centering
\caption{Comparison: HIT-based vs.\ Computational Paths}
\begin{tabular}{lll}
\toprule
\textbf{Aspect} & \textbf{HIT-Based} & \textbf{Computational Paths} \\
\midrule
Circle definition & Kernel axioms (7) & Single-point + expressions (0) \\
$\piOne(S^2) = 1$ & Encode-decode proof & \texttt{Subsingleton} instance \\
Pushout glue & Axiomatized path & \texttt{Quot.sound} \\
Trusted kernel & Extended & Unchanged \\
Proof assistant & Cubical Agda, Coq HoTT & Standard Lean 4 \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Conclusion}
\label{sec:conclusion}
%==============================================================================

We have presented an \textbf{axiom-free} formalization of the Seifert-van Kampen theorem and fundamental group computations for classical spaces. The key innovation is replacing higher-inductive types with \emph{computational path structures}:

\begin{enumerate}
    \item \textbf{Spaces as single-point types}: The circle, sphere, and torus are defined as standard inductive types, not HITs.

    \item \textbf{Path expressions as syntax}: Non-trivial paths exist at the \emph{expression level}, with a quotient by rewrite equality giving the fundamental group.

    \item \textbf{Contractibility from Subsingleton}: For $S^2$ and higher spheres, $\piOne = 1$ follows from the type being a \texttt{Subsingleton}---no axioms needed.

    \item \textbf{Zero kernel axioms}: The entire development uses only Lean's built-in \texttt{Prop} and \texttt{Quot}, requiring no trusted kernel extensions.
\end{enumerate}

\subsection{Significance}

This work demonstrates that significant results in algebraic topology---the fundamental groups of the circle, torus, spheres, and figure-eight---can be formalized \textbf{without extending the proof assistant's kernel}. This has implications for:

\begin{itemize}
    \item \textbf{Foundational minimality}: The results are derivable from a smaller trusted base.
    \item \textbf{Portability}: The approach works in any type theory with quotients and proof-irrelevant propositions.
    \item \textbf{Computational content}: Path expressions carry explicit rewrite traces.
\end{itemize}

\subsection{Limitations}

\begin{enumerate}
    \item \textbf{Scope}: The current formalization covers $\Sone$, $T^2$, $S^2$, and $\Sone \Wedge \Sone$. More complex spaces (Klein bottle, lens spaces, projective spaces) would require additional development.

    \item \textbf{Higher homotopy}: The computational path approach is most natural for $\piOne$. Extension to $\piN$ requires careful design of higher path expression algebras.
\end{enumerate}

\subsection{Future Work}

\begin{enumerate}
    \item \textbf{More spaces}: Extend the computational path approach to Klein bottles, projective planes, and surfaces of higher genus.

    \item \textbf{Higher homotopy groups}: Develop axiom-free $\piN$ computations using iterated path expression algebras.

    \item \textbf{Comparison with cubical}: Relate computational paths to cubical type theory approaches.

    \item \textbf{Automation}: Improve tactic support for path expression reasoning.
\end{enumerate}

%==============================================================================
\begin{thebibliography}{99}

\bibitem{Cohen2018Cubical}
Cyril Cohen, Thierry Coquand, Simon Huber, and Anders M{\"o}rtberg.
\newblock Cubical type theory: A constructive interpretation of the univalence axiom.
\newblock {\em Mathematical Structures in Computer Science}, 28(7):1228--1269, 2018.

\bibitem{Queiroz2016Paths}
Ruy J. G.~B. de~Queiroz, Anjolina~G. de~Oliveira, and Arthur~F. Ramos.
\newblock Propositional equality, identity types, and direct computational paths.
\newblock {\em South American Journal of Logic}, 2(2):245--296, 2016.

\bibitem{Ruy4}
Ruy J. G.~B. de~Queiroz and Dov~M. Gabbay.
\newblock Equality in labelled deductive systems and the functional interpretation of propositional equality.
\newblock In {\em Proceedings of the 9th Amsterdam Colloquium}, pages 547--565, 1994.

\bibitem{Veras2018FundamentalGroups}
Tiago M.~L. de~Veras, Arthur~F. Ramos, Ruy J. G.~B. de~Queiroz, and Anjolina~G. de~Oliveira.
\newblock On the calculation of fundamental groups in homotopy type theory by means of computational paths.
\newblock {\em arXiv preprint arXiv:1804.01413}, 2018.

\bibitem{Veras2023Topological}
Tiago M.~L. de~Veras, Arthur~F. Ramos, Ruy J. G.~B. de~Queiroz, and Anjolina~G. de~Oliveira.
\newblock A topological application of labelled natural deduction.
\newblock {\em South American Journal of Logic}, 2023.

\bibitem{Veras2023WeakGroupoid}
Tiago M.~L. de~Veras, Arthur~F. Ramos, Ruy J. G.~B. de~Queiroz, and Anjolina~G. de~Oliveira.
\newblock Computational paths -- a weak groupoid.
\newblock {\em Journal of Logic and Computation}, 35(5):exad071, 2023.

\bibitem{Hatcher2002}
Allen Hatcher.
\newblock {\em Algebraic Topology}.
\newblock Cambridge University Press, 2002.

\bibitem{FavoniaShulman2016}
Kuen-Bang {Hou (Favonia)} and Michael Shulman.
\newblock A mechanization of the {Blakers-Massey} connectivity theorem in homotopy type theory.
\newblock In {\em LICS}, pages 565--574. ACM, 2016.

\bibitem{KrausVonRaumer2022}
Nicolai Kraus and Jakob von Raumer.
\newblock A rewriting coherence theorem with applications in homotopy type theory.
\newblock {\em Mathematical Structures in Computer Science}, 32(7):982--1014, 2022.

\bibitem{LicataShulman2013}
Daniel~R. Licata and Michael Shulman.
\newblock Calculating the fundamental group of the circle in homotopy type theory.
\newblock In {\em LICS}, pages 223--232. IEEE, 2013.

\bibitem{May1999}
J.~Peter May.
\newblock {\em A Concise Course in Algebraic Topology}.
\newblock University of Chicago Press, 1999.

\bibitem{Ramos2017IdentityPaths}
Arthur~F. Ramos, Ruy J. G.~B. de~Queiroz, and Anjolina~G. de~Oliveira.
\newblock On the identity type as the type of computational paths.
\newblock {\em Logic Journal of the IGPL}, 25(4):562--584, 2017.

\bibitem{Ramos2018ExplicitPaths}
Arthur~F. Ramos, Ruy J. G.~B. de~Queiroz, Anjolina~G. de~Oliveira, and Tiago M.~L. de~Veras.
\newblock Explicit computational paths.
\newblock {\em South American Journal of Logic}, 4(2):441--484, 2018.

\bibitem{Ramos2018Thesis}
Arthur~F. Ramos.
\newblock {\em Explicit Computational Paths in Type Theory}.
\newblock PhD thesis, Universidade Federal de Pernambuco, 2018.

\bibitem{ComputationalPathsLean}
Arthur~F. Ramos, Tiago M.~L. de~Veras, Ruy J. G.~B. de~Queiroz, and Anjolina~G. de~Oliveira.
\newblock Computational paths in {Lean}.
\newblock \url{https://github.com/Arthur742Ramos/ComputationalPathsLean}, 2025.

\bibitem{Seifert1931}
Herbert Seifert.
\newblock {Konstruktion dreidimensionaler geschlossener R{\"a}ume}.
\newblock {\em Berichte S{\"a}chs. Akad. Wiss. Leipzig}, 83:26--66, 1931.

\bibitem{HoTTBook2013}
{Univalent Foundations Program}.
\newblock {\em Homotopy Type Theory: Univalent Foundations of Mathematics}.
\newblock Institute for Advanced Study, 2013.

\bibitem{vanKampen1933}
Egbert~R. van Kampen.
\newblock {On the connection between the fundamental groups of some related spaces}.
\newblock {\em American Journal of Mathematics}, 55(1):261--267, 1933.

\end{thebibliography}

%==============================================================================
\appendix
\section{Application Inventory}
\label{app:inventory}
%==============================================================================

The following table provides the exact Lean theorem names and module paths for the headline results.

\begin{center}
\footnotesize
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Result} & \textbf{Lean Name} & \textbf{Module} & \textbf{Axioms} \\
\midrule
$\piOne(\Sone) \simeq \ZZ$ & \texttt{circleCompPathPiOneEquivInt} & \texttt{CircleCompPath} & 0 \\
$\piOne(T^2) \simeq \ZZ^2$ & \texttt{torusPiOneEquivIntProd} & \texttt{TorusStep} & 0 \\
$\piOne(S^2) \simeq 1$ & \texttt{sphere2CompPath\_pi1\_equiv\_unit} & \texttt{SphereCompPath} & 0 \\
$\piOne(\Sone \Wedge \Sone)$ & \texttt{figureEightPiOneEquiv} & \texttt{FigureEight} & 0 \\
Wedge SVK & \texttt{wedgeProvenanceEquiv} & \texttt{PushoutPaths} & 0 \\
\bottomrule
\end{tabular}
\end{center}

\end{document}
