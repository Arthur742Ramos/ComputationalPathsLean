/-
# Symmetric rewrite closure on computational paths

Defines the `RwEq` relation (symmetric reflexive/transitive closure of `Step`)
plus its interaction with `RewriteLift`, `Rw`, and higher-order constructs.

## File outline

* `RwEq` is introduced as the smallest relation containing `Step` and
  closed under symmetry/transitivity, together with convenient
  introduction/recursion lemmas (`rweq_of_step`, `rweq_toEq`, ...).
* The `RewriteLift` section shows how any `RewriteLift`, `Context`, or
  `BiContext` functorially transports `RwEq`, so congruence lemmas
  automatically specialise to the symmetric closure.
* Congruence lemmas for `mapLeft`, `mapRight`, `map2`, substitution, and
  dependent transport are grouped by feature so downstream files can reuse
  them as drop-in replacements for their `Rw` counterparts.
* The final portion provides canned rewrites (β/η rules, associativity,
  inverses) phrased directly in terms of `RwEq`, keeping quotient-facing
  modules agnostic of the underlying step representation.
-/

import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.Step
import ComputationalPaths.Path.Rewrite.Rw

namespace ComputationalPaths
namespace Path

open scoped Quot

universe u v w

variable {A : Type u}

namespace Step
@[simp] theorem map_comp {A B C : Type u} (f : B → C) (g : A → B) (s : ComputationalPaths.Step A) :
    ComputationalPaths.Step.map f (ComputationalPaths.Step.map g s) = ComputationalPaths.Step.map (f ∘ g) s := by
  cases s
  rfl

@[simp] theorem map_comp_fun {A B C : Type u} (f : B → C) (g : A → B) :
    ComputationalPaths.Step.map f ∘ ComputationalPaths.Step.map g = ComputationalPaths.Step.map (f ∘ g) := by
  funext s
  apply map_comp
end Step

/-- Symmetric reflexive/transitive closure generated by rewrite steps. -/
inductive RwEq {A : Type u} {a b : A} : Path a b → Path a b → Prop
  | refl (p : Path a b) : RwEq p p
  | step {p q : Path a b} : Step p q → RwEq p q
  | symm {p q : Path a b} : RwEq p q → RwEq q p
  | trans {p q r : Path a b} : RwEq p q → RwEq q r → RwEq p r

@[simp] theorem rweq_refl (p : Path a b) : RwEq p p :=
  RwEq.refl p

@[simp] theorem rweq_of_step {p q : Path a b} (h : Step p q) : RwEq p q :=
  RwEq.step h

@[simp] theorem rweq_symm {p q : Path a b} (h : RwEq p q) : RwEq q p :=
  match h with
  | RwEq.refl _ => RwEq.refl _
  | RwEq.step h => RwEq.symm (RwEq.step h)
  | RwEq.symm h => h
  | RwEq.trans h1 h2 => RwEq.trans (rweq_symm h2) (rweq_symm h1)

@[simp] theorem rweq_trans {p q r : Path a b} (h1 : RwEq p q) (h2 : RwEq q r) :
    RwEq p r :=
  RwEq.trans h1 h2

@[simp] theorem rweq_trans_congr_left {p p' : Path a b} (q : Path b c)
    (h : RwEq p p') : RwEq (trans p q) (trans p' q) := by
  induction h with
  | refl => exact RwEq.refl _
  | step h => exact RwEq.step (Step.trans_congr_left q h)
  | symm _ ih => exact RwEq.symm ih
  | trans _ _ ih1 ih2 => exact RwEq.trans ih1 ih2

@[simp] theorem rweq_trans_congr_right (p : Path a b) {q q' : Path b c}
    (h : RwEq q q') : RwEq (trans p q) (trans p q') := by
  induction h with
  | refl => exact RwEq.refl _
  | step h => exact RwEq.step (Step.trans_congr_right p h)
  | symm _ ih => exact RwEq.symm ih
  | trans _ _ ih1 ih2 => exact RwEq.trans ih1 ih2

@[simp] theorem rweq_trans_congr {p p' : Path a b} {q q' : Path b c}
    (hp : RwEq p p') (hq : RwEq q q') :
    RwEq (trans p q) (trans p' q') :=
  RwEq.trans (rweq_trans_congr_left q hp) (rweq_trans_congr_right p' hq)

@[simp] theorem rweq_toEq {p q : Path a b} (h : RwEq p q) :
    p.toEq = q.toEq := by
  induction h with
  | refl => rfl
  | step h => exact step_toEq h
  | symm h ih => exact ih.symm
  | trans h₁ h₂ ih₁ ih₂ => exact ih₁.trans ih₂

@[simp] theorem normalize_of_rweq {p q : Path a b} (h : RwEq p q) :
    normalize (A := A) (a := a) (b := b) p =
      normalize (A := A) (a := a) (b := b) q := by
  unfold normalize
  have := rweq_toEq (p := p) (q := q) h
  cases this
  rfl

@[simp] theorem normalizeForm_eq_of_rweq {p q : Path a b} (h : RwEq p q) :
    normalizeForm (A := A) (a := a) (b := b) p =
      normalizeForm (A := A) (a := a) (b := b) q := by
  unfold normalizeForm
  have hnorm := normalize_of_rweq (A := A) (a := a) (b := b) (p := p) (q := q) h
  cases hnorm
  simp

@[simp] theorem rweq_of_eq {A : Type u} {a b : A}
    {p q : Path a b} (h : p = q) : RwEq p q := by
  cases h
  exact RwEq.refl _

/-- Convert `Eq` into a `Path` while explicitly exhibiting rewrite-chain
structure through associativity, congruence, and unit rewrites. -/
def ofEqChain {A : Type u} {a b : A} (h : a = b) : Path a b := by
  cases h
  have _ :
      RwEq (trans (trans (Path.refl a) (Path.refl a)) (Path.refl a))
        (trans (Path.refl a) (trans (Path.refl a) (Path.refl a))) :=
    rweq_of_step (Step.trans_assoc (Path.refl a) (Path.refl a) (Path.refl a))
  have _ :
      RwEq (trans (trans (Path.refl a) (Path.refl a)) (Path.refl a))
        (trans (Path.refl a) (Path.refl a)) :=
    rweq_of_step
      (Step.trans_congr_right (Path.refl a) (Step.trans_refl_left (Path.refl a)))
  have _ : RwEq (trans (Path.refl a) (Path.refl a)) (Path.refl a) :=
    rweq_of_step (Step.trans_refl_right (Path.refl a))
  exact trans (Path.refl a) (Path.refl a)

namespace RewriteLift

variable {A : Type u} {B : Type u}

/-- Any `RewriteLift` functor transports symmetric rewrite equality.  This
statement mirrors `rw_of_rw` from `Rw.lean` and underpins the downstream
`Context`/`BiContext` congruence lemmas. -/

@[simp] theorem rweq_of_rweq (F : RewriteLift A B)
  {a b : A} {p q : Path (A := A) a b}
  (h : RwEq p q) :
  RwEq (F.map p) (F.map q) := by
  induction h with
  | refl _ => exact RwEq.refl _
  | step hStep =>
      exact RwEq.step (F.step_congr hStep)
  | symm _ ih => exact RwEq.symm ih
  | trans _ _ ih₁ ih₂ =>
      exact RwEq.trans ih₁ ih₂

end RewriteLift

/-- Transport compatibility: once `RewriteLift` is known to preserve `RwEq`, the
  specialized context/bi-context helpers simply instantiate it with the
  canonical lifts defined in `Basic/Context.lean`.  Grouping them here keeps the
  proof scripts short and makes it obvious which lemma to reach for when
  working under holes. -/
@[simp] theorem rweq_context_map_of_rweq {A : Type u} {B : Type u}
  (Ctx : Context A B) {a₁ a₂ : A}
  {p q : Path a₁ a₂} (h : RwEq p q) :
  RwEq (Context.map (A := A) (B := B) Ctx p)
    (Context.map (A := A) (B := B) Ctx q) := by
  classical
  let F := RewriteLift.ofContext (A := A) (B := B) Ctx
  change RwEq (F.map p) (F.map q)
  exact
    RewriteLift.rweq_of_rweq
      (A := A) (B := B) (F := F)
      (p := p) (q := q) h

@[simp] theorem rweq_biContext_mapLeft_of_rweq
  {A : Type u} {B : Type u} {C : Type u}
  (K : BiContext A B C) {a₁ a₂ : A} (b : B)
  {p q : Path a₁ a₂} (h : RwEq p q) :
  RwEq (BiContext.mapLeft (A := A) (B := B) (C := C) K p b)
    (BiContext.mapLeft (A := A) (B := B) (C := C) K q b) := by
  classical
  let F := RewriteLift.ofBiContextLeft (A := A) (B := B) (C := C)
      (K := K) (b₀ := b)
  change RwEq (F.map p) (F.map q)
  exact
    RewriteLift.rweq_of_rweq
      (A := A) (B := C) (F := F)
      (p := p) (q := q) h

@[simp] theorem rweq_biContext_mapRight_of_rweq
  {A : Type u} {B : Type u} {C : Type u}
  (K : BiContext A B C) (a : A) {b₁ b₂ : B}
  {p q : Path b₁ b₂} (h : RwEq p q) :
  RwEq (BiContext.mapRight (A := A) (B := B) (C := C) K a p)
    (BiContext.mapRight (A := A) (B := B) (C := C) K a q) := by
  classical
  let F := RewriteLift.ofBiContextRight (A := A) (B := B) (C := C)
      (K := K) (a := a)
  change RwEq (F.map p) (F.map q)
  exact
    RewriteLift.rweq_of_rweq
      (A := B) (B := C) (F := F)
      (p := p) (q := q) h

@[simp] theorem rweq_mapLeft_of_rweq {B : Type u} {C : Type u}
  (f : A → B → C) {a₁ a₂ : A} (b : B)
  {p q : Path a₁ a₂} (h : RwEq p q) :
  RwEq (Path.mapLeft f p b) (Path.mapLeft f q b) := by
  classical
  let Ctx : Context A C := ⟨fun a => f a b⟩
  change RwEq (Context.map (A := A) (B := C) Ctx p)
    (Context.map (A := A) (B := C) Ctx q)
  exact
    rweq_context_map_of_rweq (A := A) (B := C)
      (Ctx := Ctx) (p := p) (q := q) h

@[simp] theorem rweq_mapRight_of_rweq {B : Type u} {C : Type u}
  (f : A → B → C) (a : A) {b₁ b₂ : B}
  {p q : Path b₁ b₂} (h : RwEq p q) :
  RwEq (Path.mapRight f a p) (Path.mapRight f a q) := by
  classical
  let Ctx : Context B C := ⟨fun b => f a b⟩
  change RwEq (Context.map (A := B) (B := C) Ctx p)
    (Context.map (A := B) (B := C) Ctx q)
  exact
    rweq_context_map_of_rweq (A := B) (B := C)
      (Ctx := Ctx) (p := p) (q := q) h

@[simp] theorem rweq_congrArg_trans {B : Type v}
    {a b c : A} (f : A → B) (p : Path a b) (q : Path b c) :
    RwEq (Path.congrArg f (Path.trans p q))
      (Path.trans (Path.congrArg f p) (Path.congrArg f q)) :=
  rweq_of_eq (Path.congrArg_trans (f := f) (p := p) (q := q))

@[simp] theorem rweq_congrArg_symm {B : Type v}
    {a b : A} (f : A → B) (p : Path a b) :
    RwEq (Path.congrArg f (Path.symm p))
      (Path.symm (Path.congrArg f p)) :=
  rweq_of_eq (Path.congrArg_symm (f := f) (p := p))

/-- congrArg preserves RwEq: if p ≈ q then f*(p) ≈ f*(q). -/
@[simp] theorem rweq_congrArg_of_rweq {B : Type u} (f : A → B)
    {a b : A} {p q : Path a b} (h : RwEq p q) :
    RwEq (Path.congrArg f p) (Path.congrArg f q) := by
  let Ctx : Context A B := ⟨f⟩
  change RwEq (Context.map (A := A) (B := B) Ctx p)
    (Context.map (A := A) (B := B) Ctx q)
  exact rweq_context_map_of_rweq (A := A) (B := B) (Ctx := Ctx) (p := p) (q := q) h

/-- congrArg on refl is refl. -/
@[simp] theorem rweq_congrArg_refl {B : Type u} (f : A → B) (a : A) :
    RwEq (Path.congrArg f (Path.refl a)) (Path.refl (f a)) :=
  rweq_refl _

/-- Congruence along a constant map collapses to reflexivity.

This is derivable from the primitive rewrite rule `Step.transport_refl_beta`,
instantiated with a constant family, plus the usual `trans` congruence rules. -/
@[simp] theorem rweq_congrArg_const {B : Type u} (b : B)
    {a₁ a₂ : A} (p : Path a₁ a₂) : RwEq (Path.congrArg (fun _ => b) p) (Path.refl b) := by
  -- Reduce to the case where the underlying equality proof is reflexive.
  cases p with
  | mk steps proof =>
      cases proof
      -- Now `p = Path.mk steps rfl`.
      -- We show that any list of reflexive steps in the codomain rewrites to `refl`.
      -- The key base rewrite is `ofEq rfl ▷ refl`, which is `transport_refl_beta`.
      have hOfEq : RwEq (Path.stepChain (rfl : b = b)) (Path.refl b) := by
        simpa using
          (RwEq.step <|
            Step.transport_refl_beta (A := PUnit) (B := fun _ : PUnit => B)
              (a := PUnit.unit) (x := b))
      -- Prove the claim by induction on the stored step list.
      -- (The endpoints of a `Path` are carried by the `proof` field, so we pin them explicitly.)
      have : RwEq (Path.congrArg (fun _ : A => b) (Path.mk (A := A) (a := a₁) (b := a₁) steps rfl))
          (Path.refl b) := by
        induction steps with
        | nil =>
            simp [Path.congrArg, Path.refl]
        | cons s tail ih =>
            -- Peel one step: after mapping through the constant function it becomes `ofEq rfl`.
            cases s with
            | mk src tgt stepProof =>
                cases stepProof
                -- With a reflexive source step, the mapped path is definitionally a `trans` with `ofEq rfl`.
                have hsplit :
                    Path.congrArg (fun _ : A => b)
                        (Path.mk (A := A) (a := a₁) (b := a₁)
                          (ComputationalPaths.Step.mk src src rfl :: tail) rfl) =
                      Path.trans (Path.stepChain (rfl : b = b))
                        (Path.congrArg (fun _ : A => b)
                          (Path.mk (A := A) (a := a₁) (b := a₁) tail rfl)) := by
                  rfl
                -- Rewrite to the split form, then reduce the left factor to `refl` and use the IH.
                exact
                  RwEq.trans (rweq_of_eq hsplit)
                    (RwEq.trans
                      (RwEq.trans (rweq_trans_congr_left _ hOfEq)
                        (rweq_of_step (Step.trans_refl_left _)))
                      ih)
      simpa [Path.congrArg] using this

@[simp] theorem rweq_mapLeft_trans {B : Type v} {C : Type w}
    {a1 a2 a3 : A} (f : A → B → C)
    (p : Path a1 a2) (q : Path a2 a3) (b : B) :
    RwEq (Path.mapLeft f (Path.trans p q) b)
      (Path.trans (Path.mapLeft f p b) (Path.mapLeft f q b)) :=
  rweq_of_eq (Path.mapLeft_trans (f := f) (p := p) (q := q) (b := b))

@[simp] theorem rweq_mapLeft_symm {B : Type v} {C : Type w}
    {a1 a2 : A} (f : A → B → C)
    (p : Path a1 a2) (b : B) :
    RwEq (Path.mapLeft f (Path.symm p) b)
      (Path.symm (Path.mapLeft f p b)) :=
  rweq_of_eq (Path.mapLeft_symm (f := f) (p := p) (b := b))

@[simp] theorem rweq_mapLeft_refl {B : Type v} {C : Type w}
    (f : A → B → C) (a : A) (b : B) :
    RwEq (Path.mapLeft f (Path.refl a) b) (Path.refl (f a b)) :=
  rweq_of_eq (Path.mapLeft_refl (f := f) (a := a) (b := b))

@[simp] theorem rweq_mapLeft_ofEq {B : Type v} {C : Type w}
    (f : A → B → C) {a₁ a₂ : A} (h : a₁ = a₂) (b : B) :
    RwEq (Path.mapLeft (A := A) (B := B) (C := C) f
        (Path.stepChain (A := A) (a := a₁) (b := a₂) h) b)
      (Path.stepChain (A := C) (a := f a₁ b) (b := f a₂ b)
        (_root_.congrArg (fun x => f x b) h)) :=
  rweq_of_eq (by
    simp [Path.mapLeft, Path.stepChain, Path.congrArg, List.map])

@[simp] theorem rweq_mapRight_trans {B : Type v} {C : Type w}
    {b1 b2 b3 : B} (f : A → B → C)
    (a : A) (p : Path b1 b2) (q : Path b2 b3) :
    RwEq (Path.mapRight f a (Path.trans p q))
      (Path.trans (Path.mapRight f a p) (Path.mapRight f a q)) :=
  rweq_of_eq (Path.mapRight_trans (f := f) (a := a) (p := p) (q := q))

@[simp] theorem rweq_mapRight_refl {B : Type v} {C : Type w}
    (f : A → B → C) (a : A) (b : B) :
    RwEq (Path.mapRight f a (Path.refl b)) (Path.refl (f a b)) :=
  rweq_of_eq (Path.mapRight_refl (f := f) (a := a) (b := b))

@[simp] theorem rweq_mapRight_ofEq {B : Type v} {C : Type w}
    (f : A → B → C) (a : A) {b₁ b₂ : B} (h : b₁ = b₂) :
    RwEq (Path.mapRight (A := A) (B := B) (C := C) f a
          (Path.stepChain (A := B) (a := b₁) (b := b₂) h))
      (Path.stepChain (A := C) (a := f a b₁) (b := f a b₂)
        (_root_.congrArg (f a) h)) :=
  rweq_of_eq (by
    simp [Path.mapRight, Path.stepChain, Path.congrArg, List.map])

@[simp] theorem rweq_map2_trans
    {A₁ : Type u} {B : Type u}
    {a1 a2 a3 : A₁} {b1 b2 b3 : B}
    (f : A₁ → B → A)
    (p1 : Path (A := A₁) a1 a2) (p2 : Path (A := A₁) a2 a3)
    (q1 : Path (A := B) b1 b2) (q2 : Path (A := B) b2 b3) :
    RwEq
      (Path.map2 (A := A₁) (B := B) (C := A) f
        (Path.trans p1 p2) (Path.trans q1 q2))
      (Path.trans
        (Path.mapLeft (A := A₁) (B := B) (C := A) f p1 b1)
        (Path.trans
          (Path.mapLeft (A := A₁) (B := B) (C := A) f p2 b1)
          (Path.trans
            (Path.mapRight (A := A₁) (B := B) (C := A) f a3 q1)
            (Path.mapRight (A := A₁) (B := B) (C := A) f a3 q2)))) :=
  rweq_of_eq
    (Path.map2_trans (A := A₁) (B := B) (C := A) (f := f)
      (p1 := p1) (p2 := p2) (q1 := q1) (q2 := q2))

@[simp] theorem rweq_map2_refl
    {A₁ : Type u} {B : Type u} (f : A₁ → B → A) (a : A₁) (b : B) :
    RwEq (Path.map2 (A := A₁) (B := B) (C := A) f
        (Path.refl a) (Path.refl b)) (Path.refl (f a b)) :=
  rweq_of_eq (Path.map2_refl (A := A₁) (B := B) (C := A) (f := f) (a := a) (b := b))

@[simp] theorem rweq_mapRight_symm {B : Type v} {C : Type w}
    {b1 b2 : B} (f : A → B → C)
    (a : A) (p : Path b1 b2) :
    RwEq (Path.mapRight f a (Path.symm p))
      (Path.symm (Path.mapRight f a p)) :=
  rweq_of_eq (Path.mapRight_symm (f := f) (a := a) (p := p))

@[simp] theorem rweq_depBiContext_map2_left_of_rweq
  {A : Type u} {B : Type u} {C : A → B → Type u}
  (K : DepBiContext A B C) {a₁ a₂ : A} {b₁ b₂ : B}
  {p q : Path a₁ a₂} (r : Path b₁ b₂) (h : RwEq p q) :
  RwEq (DepBiContext.map2 (A := A) (B := B) (C := C) K p r)
    (DepBiContext.map2 (A := A) (B := B) (C := C) K q r) := by
  induction h with
  | refl _ => exact RwEq.refl _
  | step step =>
      exact RwEq.step
        (Step.depBiContext_map2_congr_left (A := A) (B := B) (C := C)
          (K := K) (r := r) step)
  | symm _ ih => exact RwEq.symm ih
  | trans _ _ ih₁ ih₂ => exact RwEq.trans ih₁ ih₂

@[simp] theorem rweq_depBiContext_map2_right_of_rweq
  {A : Type u} {B : Type u} {C : A → B → Type u}
  (K : DepBiContext A B C) {a₁ a₂ : A} {b₁ b₂ : B}
  (p : Path a₁ a₂) {q r : Path b₁ b₂} (h : RwEq q r) :
  RwEq (DepBiContext.map2 (A := A) (B := B) (C := C) K p q)
    (DepBiContext.map2 (A := A) (B := B) (C := C) K p r) := by
  induction h with
  | refl _ => exact RwEq.refl _
  | step step =>
      exact RwEq.step
        (Step.depBiContext_map2_congr_right (A := A) (B := B) (C := C)
          (K := K) (p := p) step)
  | symm _ ih => exact RwEq.symm ih
  | trans _ _ ih₁ ih₂ => exact RwEq.trans ih₁ ih₂

@[simp] theorem rweq_depBiContext_map2_of_rweq
  {A : Type u} {B : Type u} {C : A → B → Type u}
  (K : DepBiContext A B C) {a₁ a₂ : A} {b₁ b₂ : B}
  {p q : Path a₁ a₂} {r s : Path b₁ b₂}
  (hp : RwEq p q) (hq : RwEq r s) :
  RwEq (DepBiContext.map2 (A := A) (B := B) (C := C) K p r)
    (DepBiContext.map2 (A := A) (B := B) (C := C) K q s) := by
  apply RwEq.trans (q := DepBiContext.map2 (A := A) (B := B) (C := C) K q r)
  · exact rweq_depBiContext_map2_left_of_rweq K r hp
  · exact rweq_depBiContext_map2_right_of_rweq K q hq

@[simp] theorem rweq_map2_of_rweq {A : Type u} {B : Type u} {C : Type u}
  (f : A → B → C) {a₁ a₂ : A} {b₁ b₂ : B}
  {p q : Path a₁ a₂} {r s : Path b₁ b₂}
  (hp : RwEq p q) (hq : RwEq r s) :
  RwEq (Path.map2 (A := A) (B := B) (C := C) f p r)
    (Path.map2 (A := A) (B := B) (C := C) f q s) :=
  rweq_trans_congr
    (rweq_mapLeft_of_rweq f b₁ hp)
    (rweq_mapRight_of_rweq f a₂ hq)

@[simp] theorem rweq_context_subst_left_beta
    {A : Type u} {B : Type u}
    (C : Context A B) {x : B} {a₁ a₂ : A}
    (r : Path x (C.fill a₁)) (p : Path a₁ a₂) :
    RwEq (Path.trans r (Context.map (A := A) (B := B) C p))
      (Context.substLeft (A := A) (B := B) C r p) :=
  rweq_of_step
    (Step.context_subst_left_beta (A := A) (B := B) C r p)

@[simp] theorem rweq_context_subst_left_of_right
    {A : Type u} {B : Type u}
    (C : Context A B) {x : B} {a₁ a₂ : A}
    (r : Path x (C.fill a₁)) (p : Path a₁ a₂) :
    RwEq (Path.trans r
        (Context.substRight (A := A) (B := B) C p
          (Path.refl (C.fill a₂))))
      (Context.substLeft (A := A) (B := B) C r p) :=
  rweq_of_step
    (Step.context_subst_left_of_right (A := A) (B := B) C r p)

@[simp] theorem rweq_context_subst_left_assoc
    {A : Type u} {B : Type u}
    (C : Context A B) {x : B} {a₁ a₂ : A} {y : B}
    (r : Path x (C.fill a₁)) (p : Path a₁ a₂)
    (t : Path (C.fill a₂) y) :
    RwEq (Path.trans
        (Context.substLeft (A := A) (B := B) C r p) t)
      (Path.trans r
        (Context.substRight (A := A) (B := B) C p t)) :=
  rweq_of_step
    (Step.context_subst_left_assoc (A := A) (B := B) C r p t)

@[simp] theorem rweq_context_subst_right_assoc
    {A : Type u} {B : Type u}
    (C : Context A B) {a₁ a₂ : A} {y z : B}
    (p : Path a₁ a₂) (t : Path (C.fill a₂) y)
    (u : Path y z) :
    RwEq (Path.trans
        (Context.substRight (A := A) (B := B) C p t) u)
      (Context.substRight (A := A) (B := B) C p (Path.trans t u)) :=
  rweq_of_step
    (Step.context_subst_right_assoc (A := A) (B := B) C p t u)

@[simp] theorem rweq_depContext_map_of_rweq
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A}
    {p q : Path a₁ a₂} (h : RwEq p q) :
    RwEq (DepContext.map (A := A) (B := B) C p)
      (DepContext.map (A := A) (B := B) C q) := by
  induction h with
  | refl _ => exact RwEq.refl _
  | step step =>
      exact RwEq.step
        (Step.depContext_congr (A := A) (B := B) (C := C) step)
  | symm _ ih => exact RwEq.symm ih
  | trans _ _ ih₁ ih₂ => exact RwEq.trans ih₁ ih₂

@[simp] theorem rweq_depContext_subst_left_beta
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A} {x : B a₁}
    (r : Path (A := B a₁) x (C.fill a₁)) (p : Path a₁ a₂) :
    RwEq (Path.trans
          (Context.map (A := B a₁) (B := B a₂)
            (DepContext.transportContext (A := A) (B := B) p) r)
          (DepContext.map (A := A) (B := B) C p))
      (DepContext.substLeft (A := A) (B := B) C r p) :=
  rweq_of_step
    (Step.depContext_subst_left_beta (A := A) (B := B) C r p)

@[simp] theorem rweq_depContext_subst_left_assoc
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A} {x : B a₁} {y : B a₂}
    (r : Path (A := B a₁) x (C.fill a₁)) (p : Path a₁ a₂)
    (t : Path (A := B a₂) (C.fill a₂) y) :
    RwEq (Path.trans
        (DepContext.substLeft (A := A) (B := B) C r p) t)
      (Path.trans
        (Context.map (A := B a₁) (B := B a₂)
          (DepContext.transportContext (A := A) (B := B) p) r)
        (DepContext.substRight (A := A) (B := B) C p t)) :=
  rweq_of_step
    (Step.depContext_subst_left_assoc (A := A) (B := B) C r p t)

@[simp] theorem rweq_depContext_subst_right_beta
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A} {y : B a₂}
    (p : Path a₁ a₂)
    (t : Path (A := B a₂) (C.fill a₂) y) :
    RwEq (Path.trans
        (DepContext.map (A := A) (B := B) C p) t)
      (DepContext.substRight (A := A) (B := B) C p t) :=
  rweq_of_step
    (Step.depContext_subst_right_beta (A := A) (B := B) C p t)

@[simp] theorem rweq_depContext_subst_right_assoc
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A} {y z : B a₂}
    (p : Path a₁ a₂)
    (t : Path (A := B a₂) (C.fill a₂) y)
    (u : Path (A := B a₂) y z) :
    RwEq (Path.trans
        (DepContext.substRight (A := A) (B := B) C p t) u)
      (DepContext.substRight (A := A) (B := B) C p
        (Path.trans t u)) :=
  rweq_of_step
    (Step.depContext_subst_right_assoc (A := A) (B := B) C p t u)

@[simp] theorem rweq_depContext_subst_left_refl_right
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a : A} {x : B a}
    (r : Path (A := B a) x (C.fill a)) :
    RwEq (DepContext.substLeft (A := A) (B := B) C r (Path.refl a))
      r :=
  rweq_of_step
    (Step.depContext_subst_left_refl_right (A := A) (B := B) C r)

@[simp] theorem rweq_depContext_subst_left_refl_left
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A}
    (p : Path a₁ a₂) :
    RwEq (DepContext.substLeft (A := A) (B := B) C
        (Path.refl (C.fill a₁)) p)
      (DepContext.map (A := A) (B := B) C p) :=
  rweq_of_step
    (Step.depContext_subst_left_refl_left (A := A) (B := B) C p)

@[simp] theorem rweq_depContext_subst_right_refl_left
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a : A} {y : B a}
    (r : Path (A := B a) (C.fill a) y) :
    RwEq (DepContext.substRight (A := A) (B := B) C
        (Path.refl a) r) r :=
  rweq_of_step
    (Step.depContext_subst_right_refl_left (A := A) (B := B) C r)

@[simp] theorem rweq_depContext_subst_right_refl_right
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A}
    (p : Path a₁ a₂) :
    RwEq (DepContext.substRight (A := A) (B := B) C p
        (Path.refl (C.fill a₂)))
      (DepContext.map (A := A) (B := B) C p) :=
  rweq_of_step
    (Step.depContext_subst_right_refl_right (A := A) (B := B) C p)

@[simp] theorem rweq_depContext_subst_left_idempotent
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A} {x : B a₁}
    (r : Path (A := B a₁) x (C.fill a₁)) (p : Path a₁ a₂) :
    RwEq (DepContext.substLeft (A := A) (B := B) C
        (DepContext.substLeft (A := A) (B := B) C r (Path.refl a₁)) p)
      (DepContext.substLeft (A := A) (B := B) C r p) :=
  rweq_of_step
    (Step.depContext_subst_left_idempotent (A := A) (B := B) C r p)

@[simp] theorem rweq_depContext_subst_right_cancel_inner
    {A : Type u} {B : A → Type u}
    (C : DepContext A B) {a₁ a₂ : A} {y : B a₂}
    (p : Path a₁ a₂)
    (t : Path (A := B a₂) (C.fill a₂) y) :
    RwEq (DepContext.substRight (A := A) (B := B) C p
        (DepContext.substRight (A := A) (B := B) C (Path.refl a₂) t))
      (DepContext.substRight (A := A) (B := B) C p t) :=
  rweq_of_step
    (Step.depContext_subst_right_cancel_inner (A := A) (B := B) C p t)

@[simp] theorem rweq_depBiContext_mapLeft_of_rweq
  {A : Type u} {B : Type u} {C : A → B → Type u}
    (K : DepBiContext A B C) {a₁ a₂ : A} (b : B)
    {p q : Path a₁ a₂} (h : RwEq p q) :
    RwEq (DepBiContext.mapLeft (A := A) (B := B) (C := C) K p b)
      (DepBiContext.mapLeft (A := A) (B := B) (C := C) K q b) := by
  change
    RwEq
      (DepContext.map (A := A) (B := fun a => C a b)
        (DepBiContext.fixRight (A := A) (B := B) (C := C) K b) p)
      (DepContext.map (A := A) (B := fun a => C a b)
        (DepBiContext.fixRight (A := A) (B := B) (C := C) K b) q)
  exact
    rweq_depContext_map_of_rweq
      (A := A) (B := fun a => C a b)
      (C := DepBiContext.fixRight (A := A) (B := B) (C := C) K b)
      (p := p) (q := q) (h := h)

@[simp] theorem rweq_depBiContext_mapRight_of_rweq
  {A : Type u} {B : Type u} {C : A → B → Type u}
    (K : DepBiContext A B C) (a : A) {b₁ b₂ : B}
    {p q : Path b₁ b₂} (h : RwEq p q) :
    RwEq (DepBiContext.mapRight (A := A) (B := B) (C := C) K a p)
      (DepBiContext.mapRight (A := A) (B := B) (C := C) K a q) := by
  change
    RwEq
      (DepContext.map (A := B) (B := fun b => C a b)
        (DepBiContext.fixLeft (A := A) (B := B) (C := C) K a) p)
      (DepContext.map (A := B) (B := fun b => C a b)
        (DepBiContext.fixLeft (A := A) (B := B) (C := C) K a) q)
  exact
    rweq_depContext_map_of_rweq
      (A := B) (B := fun b => C a b)
      (C := DepBiContext.fixLeft (A := A) (B := B) (C := C) K a)
      (p := p) (q := q) (h := h)



@[simp] theorem rweq_transport_refl_beta
    {A : Type u} {B : A → Type u}
    {a : A} (x : B a) :
    RwEq
      (Path.stepChain (A := B a)
        (a := transport (A := A) (D := fun t => B t)
                (Path.refl a) x)
        (b := x)
        (transport_refl (A := A) (D := fun t => B t)
          (a := a) (x := x)))
      (Path.refl x) :=
  rweq_of_step (Step.transport_refl_beta (A := A) (B := B) (a := a) x)

@[simp] theorem rweq_sr {A : Type u} (a : A) :
    RwEq (Path.symm (Path.refl a)) (Path.refl a) :=
  rweq_of_step (Step.symm_refl (A := A) a)

@[simp] theorem rweq_ss {A : Type u} {a b : A} (p : Path a b) :
    RwEq (Path.symm (Path.symm p)) p :=
  rweq_of_step (Step.symm_symm (A := A) (p := p))

@[simp] theorem rweq_tt {A : Type u} {a b c d : A}
    (p : Path a b) (q : Path b c) (r : Path c d) :
    RwEq (Path.trans (Path.trans p q) r)
      (Path.trans p (Path.trans q r)) :=
  rweq_of_step (Step.trans_assoc (A := A) (a := a) (b := b)
    (c := c) (d := d) p q r)

@[simp] theorem rweq_cmpA_refl_left {A : Type u} {a b : A}
    (p : Path a b) :
    RwEq (Path.trans (Path.refl a) p) p :=
  rweq_of_step (Step.trans_refl_left (A := A) (a := a) (b := b) p)

@[simp] theorem rweq_cmpA_refl_right {A : Type u} {a b : A}
    (p : Path a b) :
    RwEq (Path.trans p (Path.refl b)) p :=
  rweq_of_step (Step.trans_refl_right (A := A) (a := a) (b := b) p)

@[simp] theorem rweq_cmpA_inv_right {A : Type u} {a b : A}
    (p : Path a b) :
    RwEq (Path.trans p (Path.symm p)) (Path.refl a) :=
  rweq_of_step (Step.trans_symm (A := A) (a := a) (b := b) p)

@[simp] theorem rweq_cmpA_inv_left {A : Type u} {a b : A}
    (p : Path a b) :
    RwEq (Path.trans (Path.symm p) p) (Path.refl b) :=
  rweq_of_step (Step.symm_trans (A := A) (a := a) (b := b) p)

@[simp] theorem rweq_mapLeft_congr
    {B : Type u} (f : A → B → A)
    {a₁ a₂ : A} (b : B)
    {p q : Path a₁ a₂} (h : RwEq p q) :
    RwEq (Path.mapLeft f p b) (Path.mapLeft f q b) :=
  match h with
  | RwEq.refl _ => RwEq.refl _
  | RwEq.step s =>
      RwEq.step (Step.mapLeft_congr (f := f) (b := b) s)
  | RwEq.symm h =>
      RwEq.symm (rweq_mapLeft_congr (f := f) (b := b) h)
  | RwEq.trans h₁ h₂ =>
      RwEq.trans
        (rweq_mapLeft_congr (f := f) (b := b) h₁)
        (rweq_mapLeft_congr (f := f) (b := b) h₂)

@[simp] theorem rweq_mapRight_congr
    (f : A → A → A) (a : A) {b₁ b₂ : A}
    {p q : Path b₁ b₂} (h : RwEq p q) :
    RwEq (Path.mapRight f a p) (Path.mapRight f a q) :=
  match h with
  | RwEq.refl _ => RwEq.refl _
  | RwEq.step s =>
      RwEq.step (Step.mapRight_congr (f := f) (a := a) s)
  | RwEq.symm h =>
      RwEq.symm (rweq_mapRight_congr (f := f) (a := a) h)
  | RwEq.trans h₁ h₂ =>
      RwEq.trans
        (rweq_mapRight_congr (f := f) (a := a) h₁)
        (rweq_mapRight_congr (f := f) (a := a) h₂)

@[simp] theorem rweq_symm_congr {p q : Path a b}
    (h : RwEq p q) : RwEq (Path.symm p) (Path.symm q) :=
  match h with
  | RwEq.refl _ => RwEq.refl _
  | RwEq.step s => RwEq.step (Step.symm_congr s)
  | RwEq.symm h => RwEq.symm (rweq_symm_congr h)
  | RwEq.trans h₁ h₂ =>
      RwEq.trans (rweq_symm_congr h₁) (rweq_symm_congr h₂)



@[simp] theorem rweq_map2_subst
    {A₁ : Type u} {B : Type u}
    {a1 a2 : A₁} {b1 b2 : B}
    (f : A₁ → B → A)
    (p : Path (A := A₁) a1 a2)
    (q : Path (A := B) b1 b2) :
    RwEq
      (Path.map2 (A := A₁) (B := B) (C := A) f p q)
      (Path.trans
        (Path.mapRight (A := A₁) (B := B) (C := A) f a1 q)
        (Path.mapLeft (A := A₁) (B := B) (C := A) f p b2)) :=
  rweq_of_step (Step.map2_subst f p q)

@[simp] theorem rweq_map2_symm
    {A₁ : Type u} {B : Type u}
    {a1 a2 : A₁} {b1 b2 : B}
    (f : A₁ → B → A)
    (p : Path (A := A₁) a1 a2)
    (q : Path (A := B) b1 b2) :
    RwEq
      (Path.map2 (A := A₁) (B := B) (C := A) f (Path.symm p) (Path.symm q))
      (Path.symm (Path.map2 (A := A₁) (B := B) (C := A) f p q)) := by
  have h :=
    rweq_of_step
      (Step.map2_subst (A₁ := A₁) (B := B) (f := f)
        (p := Path.symm p) (q := Path.symm q))
  have h2 :=
    Path.map2_symm (A := A₁) (B := B) (C := A) f p q
  exact rweq_trans h (rweq_of_eq h2.symm)

@[simp] theorem rweq_prod_fst_beta {A : Type u} {B : Type u}
    {a1 a2 : A} {b1 b2 : B}
    (p : Path a1 a2) (q : Path b1 b2) :
    RwEq (Path.congrArg Prod.fst
        (Path.map2 (A := A) (B := B) (C := Prod A B) Prod.mk p q)) p :=
  rweq_of_step (Step.prod_fst_beta (B := B) p q)

@[simp] theorem rweq_prod_snd_beta {B : Type u} {A : Type u}
    {a1 a2 : B} {b1 b2 : A}
    (p : Path a1 a2) (q : Path b1 b2) :
    RwEq (Path.congrArg Prod.snd
        (Path.map2 (A := B) (B := A) (C := Prod B A) Prod.mk p q)) q :=
  rweq_of_step (Step.prod_snd_beta (B := B) p q)

@[simp] theorem rweq_prod_rec_beta {α β : Type u} {A : Type u}
    (f : α → β → A)
    {a1 a2 : α} {b1 b2 : β}
    (p : Path a1 a2) (q : Path b1 b2) :
    RwEq
      (Path.congrArg (Prod.rec f)
        (Path.map2 (A := α) (B := β) (C := Prod α β) Prod.mk p q))
      (Path.map2 (A := α) (B := β) (C := A) f p q) :=
  rweq_of_step (Step.prod_rec_beta (α := α) (β := β) (f := f) p q)

@[simp] theorem rweq_sigma_fst_beta {A : Type u} {B : A → Type u}
    {a1 a2 : A} {b1 : B a1} {b2 : B a2}
    (p : Path a1 a2)
    (q : Path (transport (A := A) (D := fun a => B a) p b1) b2) :
    RwEq
      (Path.congrArg Sigma.fst
        (Path.sigmaMk (B := B) p q))
      (Path.stepChain (A := A) p.toEq) :=
  rweq_of_step (Step.sigma_fst_beta (A := A) (B := B) p q)

@[simp] theorem rweq_sigma_snd_beta {A : Type u} {B : A → Type u}
    {a1 a2 : A} {b1 : B a1} {b2 : B a2}
    (p : Path a1 a2)
    (q : Path (transport (A := A) (D := fun a => B a) p b1) b2) :
    RwEq
      (Path.sigmaSnd (B := B) (Path.sigmaMk (B := B) p q))
      (Path.stepChain
        (A := B a2)
        (a := transport (A := A) (D := fun a => B a)
              (Path.sigmaFst (B := B) (Path.sigmaMk (B := B) p q)) b1)
        (b := b2) q.toEq) :=
  rweq_of_eq
    (Path.sigmaSnd_sigmaMk_eq_ofEq
      (B := B) (p := p) (q := q))

@[simp] theorem rweq_of_rw {p q : Path a b} (h : Rw p q) : RwEq p q :=
  match h with
  | Rw.refl _ => RwEq.refl _
  | Rw.tail h step => RwEq.trans (rweq_of_rw h) (RwEq.step step)

@[simp] theorem rweq_sigma_eta {A : Type u} {B : A → Type u}
    {a1 a2 : A} {b1 : B a1} {b2 : B a2}
    (p : Path (A := Sigma B) ⟨a1, b1⟩ ⟨a2, b2⟩) :
    RwEq (Path.sigmaMk (Path.sigmaFst p) (Path.sigmaSnd p)) p := by
  classical
  exact rweq_of_rw (rw_sigma_eta (A := A) (B := B) (p := p))

@[simp] theorem rweq_apd_refl {A : Type u} {B : A → Type u}
    (f : ∀ x : A, B x) (a : A) :
    RwEq
      (Path.apd (A := A) (B := B) f (Path.refl a))
      (Path.refl (f a)) :=
  RwEq.step (Step.apd_refl (A := A) (B := B) f a)

@[simp] theorem rweq_sum_rec_inl_beta {α β : Type u} {A : Type u}
    {a1 a2 : α} (f : α → A) (g : β → A) (p : Path a1 a2) :
    RwEq
      (Path.congrArg (Sum.rec f g)
        (Path.congrArg Sum.inl p))
      (Path.congrArg f p) :=
  rweq_of_step (Step.sum_rec_inl_beta (α := α) (β := β) (f := f) (g := g) p)

@[simp] theorem rweq_sum_rec_inr_beta {α β : Type u} {A : Type u}
    {b1 b2 : β} (f : α → A) (g : β → A) (p : Path b1 b2) :
    RwEq
      (Path.congrArg (Sum.rec f g)
        (Path.congrArg Sum.inr p))
      (Path.congrArg g p) :=
  rweq_of_step (Step.sum_rec_inr_beta (α := α) (β := β) (f := f) (g := g) p)

@[simp] theorem rweq_fun_app_beta {α : Type u}
    {f g : α → A} (p : ∀ x : α, Path (f x) (g x)) (a : α) :
    RwEq
      (Path.congrArg (fun h : α → A => h a)
        (Path.lamCongr (f := f) (g := g) p))
      (p a) :=
  rweq_of_step (Step.fun_app_beta (α := α) p a)

@[simp] theorem rweq_fun_eta {α β : Type u}
    {f g : α → β} (p : Path f g) :
    RwEq (Path.lamCongr (fun x => Path.app p x)) p := by
  classical
  exact rweq_of_rw (rw_fun_eta (α := α) (β := β) (p := p))

@[simp] theorem rweq_lamCongr_of_rweq {A : Type u} {B : Type v}
    {f g : A → B}
    {p q : ∀ x : A, Path (f x) (g x)}
    (h : ∀ x : A, RwEq (p x) (q x)) :
    RwEq (Path.lamCongr p) (Path.lamCongr q) := by
  classical
  have hxProof :
      ∀ x, (p x).proof = (q x).proof := fun x => by
        have hx := rweq_toEq (h x)
        cases hx
        simp
  have hx : Path.lamCongr p = Path.lamCongr q := by
    have hxFun := funext hxProof
    cases hxFun
    simp [Path.lamCongr]
  cases hx
  exact RwEq.refl _

@[simp] theorem rweq_lamCongr_of_rw {A : Type u} {B : Type v}
    {f g : A → B}
    {p q : ∀ x : A, Path (f x) (g x)}
    (h : ∀ x : A, Rw (p x) (q x)) :
    RwEq (Path.lamCongr p) (Path.lamCongr q) :=
  rweq_lamCongr_of_rweq (A := A) (B := B) (f := f) (g := g)
    (p := p) (q := q) (h := fun x => rweq_of_rw (h x))

@[simp] theorem rw_congr_rweq {p q r : Path a b}
    (hpq : Rw p q) (hqr : RwEq q r) : RwEq p r :=
  rweq_trans (rweq_of_rw hpq) hqr

@[simp] theorem rweq_congr_rw {p q r : Path a b}
    (hpq : RwEq p q) (hqr : Rw q r) : RwEq p r :=
  rweq_trans hpq (rweq_of_rw hqr)

@[simp] theorem rweq_symm_trans_congr {p : Path a b} {q : Path b c} :
    RwEq (symm (trans p q)) (trans (symm q) (symm p)) :=
  rweq_of_rw (rw_symm_trans_congr (p := p) (q := q))

@[simp] theorem rweq_prod_eta {α β : Type u}
    {a₁ a₂ : α} {b₁ b₂ : β}
    (p : Path (A := Prod α β) (a₁, b₁) (a₂, b₂)) :
    RwEq (Path.prodMk (Path.fst p) (Path.snd p)) p := by
  classical
  exact rweq_of_rw (rw_prod_eta (α := α) (β := β) (p := p))

@[simp] theorem rweq_sigmaMk_refl {A : Type u} {B : A → Type u}
    (a : A) (b : B a) :
    RwEq
      (Path.sigmaMk (B := B) (Path.refl a)
        (Path.stepChain (A := B a) (a := b) (b := b) rfl))
      (Path.refl (Sigma.mk a b)) := by
  classical
  have hfst :
      Path.sigmaFst (B := B) (Path.refl (Sigma.mk a b)) =
        Path.refl a := by
    unfold Path.sigmaFst
    simp [Path.congrArg, Path.refl]
  have hsnd :
      Path.sigmaSnd (B := B) (Path.refl (Sigma.mk a b)) =
        Path.stepChain (A := B a) (a := b) (b := b) rfl := by
    unfold Path.sigmaSnd
    simp [transport, Path.refl]
  have h :=
    rweq_sigma_eta (A := A) (B := B)
      (p := Path.refl (Sigma.mk a b))
  cases hfst
  cases hsnd
  exact h

@[simp] theorem rweq_fst_prodMk {α β : Type u}
    {a₁ a₂ : α} {b₁ b₂ : β}
    (p : Path a₁ a₂) (q : Path b₁ b₂) :
    RwEq (Path.fst (Path.prodMk p q)) p := by
  classical
  exact rweq_of_rw (rw_prod_fst_beta (p := p) (q := q))

@[simp] theorem rweq_snd_prodMk {α β : Type u}
    {a₁ a₂ : α} {b₁ b₂ : β}
    (p : Path a₁ a₂) (q : Path b₁ b₂) :
    RwEq (Path.snd (Path.prodMk p q)) q := by
  classical
  exact rweq_of_rw (rw_prod_snd_beta (p := p) (q := q))

@[simp] theorem rweq_congrArg_prod_map {α β α' β' : Type u}
    (g : α → α') (h : β → β')
    {a₁ a₂ : α} {b₁ b₂ : β}
    (p : Path a₁ a₂) (q : Path b₁ b₂) :
    RwEq (Path.congrArg (fun x : α × β => (g x.1, h x.2)) (Path.prodMk p q))
      (Path.prodMk (Path.congrArg g p) (Path.congrArg h q)) := by
  classical
  apply rweq_trans (rweq_of_rw (rw_prod_rec_beta (fun a b => (g a, h b)) p q))
  apply rweq_of_rw
  apply rw_of_eq
  simp [Path.prodMk, Path.map2, Path.mapLeft, Path.mapRight, Step.map_comp_fun]
  rfl
end Path
end ComputationalPaths
