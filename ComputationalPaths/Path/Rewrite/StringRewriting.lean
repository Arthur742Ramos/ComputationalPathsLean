/-
# String Rewriting Systems as a Special Case of Path Rewriting

This module formalizes string rewriting systems (SRS) and Thue systems
via computational paths.  Words over an alphabet are modeled as lists,
rewrite rules replace subwords, and we prove:

- The symmetric closure of an SRS is a Thue system
- Thue congruence properties
- Free monoid structure via paths
- Church-Rosser property for confluent SRS
- Length-based termination conditions
- Unique normal forms

## References

- Book & Otto, "String-Rewriting Systems" (1993)
- Thue, "Die Lösung eines Speziellen Problems" (1914)
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths.Path.Rewrite.StringRewriting

open List

universe u

/-! ## Words and String Rewriting -/

/-- A word over alphabet α is just a list. -/
abbrev Word (α : Type u) := List α

/-- A string rewrite rule: replace `lhs` with `rhs`. -/
structure SRule (α : Type u) where
  lhs : Word α
  rhs : Word α

/-- One-step string rewriting: replace an occurrence of `r.lhs` with `r.rhs`
in context `u ++ r.lhs ++ v`. -/
inductive SStep {α : Type u} (rules : List (SRule α)) :
    Word α → Word α → Prop where
  | apply (r : SRule α) (u v : Word α) :
      r ∈ rules →
      SStep rules (u ++ r.lhs ++ v) (u ++ r.rhs ++ v)

/-- Multi-step string rewriting (reflexive-transitive closure). -/
inductive SRtc {α : Type u} (rules : List (SRule α)) :
    Word α → Word α → Prop where
  | refl (w : Word α) : SRtc rules w w
  | head {a b c : Word α} : SStep rules a b → SRtc rules b c → SRtc rules a c

namespace SRtc

variable {α : Type u} {rules : List (SRule α)}

theorem single {a b : Word α} (h : SStep rules a b) : SRtc rules a b :=
  .head h (.refl b)

theorem trans {a b c : Word α} (h₁ : SRtc rules a b) (h₂ : SRtc rules b c) :
    SRtc rules a c := by
  induction h₁ with
  | refl => exact h₂
  | head step _ ih => exact .head step (ih h₂)

end SRtc

/-! ## Thue Systems: Symmetric Closure -/

/-- Thue congruence: the equivalence relation generated by an SRS.
This is the symmetric-reflexive-transitive closure of rewriting. -/
inductive ThueEq {α : Type u} (rules : List (SRule α)) :
    Word α → Word α → Prop where
  | refl (w : Word α) : ThueEq rules w w
  | fwd (r : SRule α) (u v : Word α) :
      r ∈ rules → ThueEq rules (u ++ r.lhs ++ v) (u ++ r.rhs ++ v)
  | bwd (r : SRule α) (u v : Word α) :
      r ∈ rules → ThueEq rules (u ++ r.rhs ++ v) (u ++ r.lhs ++ v)
  | symm {a b : Word α} : ThueEq rules a b → ThueEq rules b a
  | trans {a b c : Word α} : ThueEq rules a b → ThueEq rules b c → ThueEq rules a c

/-- Forward rewriting implies Thue equivalence. -/
theorem SStep.toThueEq {α : Type u} {rules : List (SRule α)}
    {a b : Word α} (h : SStep rules a b) : ThueEq rules a b := by
  cases h with
  | apply r u v hmem => exact .fwd r u v hmem

/-- Multi-step rewriting implies Thue equivalence. -/
theorem SRtc.toThueEq {α : Type u} {rules : List (SRule α)}
    {a b : Word α} (h : SRtc rules a b) : ThueEq rules a b := by
  induction h with
  | refl => exact .refl _
  | head step _ ih => exact .trans (step.toThueEq) ih

/-! ## Monoid Structure on Words -/

/-- Concatenation is associative (word level). -/
theorem word_append_assoc {α : Type u} (u v w : Word α) :
    u ++ v ++ w = u ++ (v ++ w) :=
  List.append_assoc u v w

/-- Empty word is left identity. -/
theorem word_nil_append {α : Type u} (w : Word α) :
    [] ++ w = w := List.nil_append w

/-- Empty word is right identity. -/
theorem word_append_nil {α : Type u} (w : Word α) :
    w ++ [] = w := List.append_nil w

/-- Path witnessing associativity of word concatenation. -/
def wordAssocPath {α : Type u} (u v w : Word α) :
    ComputationalPaths.Path (u ++ v ++ w) (u ++ (v ++ w)) :=
  ComputationalPaths.Path.mk [Step.mk _ _ (word_append_assoc u v w)]
    (word_append_assoc u v w)

/-- Path witnessing left identity of word concatenation. -/
def wordNilLeftPath {α : Type u} (w : Word α) :
    ComputationalPaths.Path ([] ++ w) w :=
  ComputationalPaths.Path.mk [Step.mk _ _ (word_nil_append w)]
    (word_nil_append w)

/-- Path witnessing right identity of word concatenation. -/
def wordNilRightPath {α : Type u} (w : Word α) :
    ComputationalPaths.Path (w ++ []) w :=
  ComputationalPaths.Path.mk [Step.mk _ _ (word_append_nil w)]
    (word_append_nil w)

/-- Monoid left-unit path toEq is correct. -/
theorem wordNilLeftPath_toEq {α : Type u} (w : Word α) :
    (wordNilLeftPath w).toEq = word_nil_append w := by simp

/-- Monoid right-unit path toEq is correct. -/
theorem wordNilRightPath_toEq {α : Type u} (w : Word α) :
    (wordNilRightPath w).toEq = word_append_nil w := by simp

/-- Associativity path toEq is correct. -/
theorem wordAssocPath_toEq {α : Type u} (u v w : Word α) :
    (wordAssocPath u v w).toEq = word_append_assoc u v w := by simp

/-! ## Congruence Properties of ThueEq -/

/-- ThueEq is reflexive. -/
theorem ThueEq.rfl' {α : Type u} {rules : List (SRule α)} {w : Word α} :
    ThueEq rules w w := .refl w

/-- ThueEq is an equivalence relation. -/
theorem ThueEq.equiv {α : Type u} {rules : List (SRule α)}
    {a b c : Word α}
    (hab : ThueEq rules a b) (hbc : ThueEq rules b c) :
    ThueEq rules a c := .trans hab hbc

/-! ## Church-Rosser Property -/

/-- A string rewriting system has the Church-Rosser property if
ThueEq implies joinability via SRtc. -/
def ChurchRosser {α : Type u} (rules : List (SRule α)) : Prop :=
  ∀ a b : Word α, ThueEq rules a b →
    ∃ c, SRtc rules a c ∧ SRtc rules b c

/-- A string rewriting system is confluent if all forks join. -/
def Confluent {α : Type u} (rules : List (SRule α)) : Prop :=
  ∀ a b c : Word α, SRtc rules a b → SRtc rules a c →
    ∃ d, SRtc rules b d ∧ SRtc rules c d

/-- Confluence implies Church-Rosser. -/
theorem confluent_implies_churchRosser {α : Type u} {rules : List (SRule α)}
    (hconf : Confluent rules) : ChurchRosser rules := by
  intro a b hab
  induction hab with
  | refl w => exact ⟨w, .refl w, .refl w⟩
  | fwd r u v hmem =>
    exact ⟨u ++ r.rhs ++ v, .single (.apply r u v hmem), .refl _⟩
  | bwd r u v hmem =>
    -- rhs → lhs direction: we need to join u ++ r.rhs ++ v and u ++ r.lhs ++ v
    -- The first reduces to itself, the second can be joined via confluence
    -- Actually, use confluence on the original terms
    have hfork1 : SRtc rules (u ++ r.rhs ++ v) (u ++ r.rhs ++ v) := .refl _
    have hfork2 : SRtc rules (u ++ r.lhs ++ v) (u ++ r.rhs ++ v) :=
      .single (.apply r u v hmem)
    exact ⟨u ++ r.rhs ++ v, hfork1, hfork2⟩
  | symm _ ih =>
    obtain ⟨c, hac, hbc⟩ := ih
    exact ⟨c, hbc, hac⟩
  | trans _ _ ih1 ih2 =>
    obtain ⟨c₁, hac₁, hbc₁⟩ := ih1
    obtain ⟨c₂, hbc₂, hcc₂⟩ := ih2
    -- b reduces to c₁ and c₂; use confluence to join
    obtain ⟨d, hc₁d, hc₂d⟩ := hconf _ _ _ hbc₁ hbc₂
    exact ⟨d, hac₁.trans hc₁d, hcc₂.trans hc₂d⟩

/-! ## Length-Based Termination -/

/-- A rule is length-reducing if its RHS is strictly shorter. -/
def SRule.isLengthReducing {α : Type u} (r : SRule α) : Prop :=
  r.rhs.length < r.lhs.length

/-- A system is length-reducing if all rules are. -/
def isLengthReducing {α : Type u} (rules : List (SRule α)) : Prop :=
  ∀ r ∈ rules, SRule.isLengthReducing r

/-- Length-reducing steps decrease word length. -/
theorem length_reducing_step {α : Type u} {rules : List (SRule α)}
    (hlr : isLengthReducing rules) {a b : Word α}
    (h : SStep rules a b) : b.length < a.length := by
  cases h with
  | apply r u v hmem =>
    simp [List.length_append]
    have := hlr r hmem
    unfold SRule.isLengthReducing at this
    omega

/-- Multi-step rewriting in a length-reducing system decreases or preserves length. -/
theorem length_reducing_rtc {α : Type u} {rules : List (SRule α)}
    (hlr : isLengthReducing rules) {a b : Word α}
    (h : SRtc rules a b) : b.length ≤ a.length := by
  induction h with
  | refl => omega
  | head step _ ih =>
    have := length_reducing_step hlr step
    omega

/-- In a length-reducing system, SStep is well-founded. -/
theorem length_reducing_wf {α : Type u} {rules : List (SRule α)}
    (hlr : isLengthReducing rules) :
    WellFounded (fun a b => SStep rules b a) :=
  Subrelation.wf
    (fun {a b} (h : SStep rules b a) =>
      length_reducing_step hlr h)
    (InvImage.wf (fun (w : Word α) => w.length) Nat.lt_wfRel.wf)

/-! ## Normal Forms -/

/-- A word is in normal form if no rule applies to it. -/
def IsNF {α : Type u} (rules : List (SRule α)) (w : Word α) : Prop :=
  ∀ w', ¬ SStep rules w w'

/-- In a confluent system, two NFs reachable from the same source are equal. -/
theorem unique_normal_form {α : Type u} {rules : List (SRule α)}
    (hconf : Confluent rules)
    {a nf₁ nf₂ : Word α}
    (h₁ : SRtc rules a nf₁) (hnf₁ : IsNF rules nf₁)
    (h₂ : SRtc rules a nf₂) (hnf₂ : IsNF rules nf₂) :
    nf₁ = nf₂ := by
  obtain ⟨d, hd₁, hd₂⟩ := hconf a nf₁ nf₂ h₁ h₂
  cases hd₁ with
  | refl => cases hd₂ with
    | refl => rfl
    | head step _ => exact absurd step (hnf₂ _)
  | head step _ => exact absurd step (hnf₁ _)

/-! ## Empty System Properties -/

/-- No steps exist in the empty system. -/
theorem no_step_empty {α : Type u} {a b : Word α} :
    ¬ SStep ([] : List (SRule α)) a b := by
  intro h; cases h; rename_i hmem; simp at hmem

/-- The empty system is confluent. -/
theorem empty_confluent {α : Type u} :
    Confluent ([] : List (SRule α)) := by
  intro a b c h₁ h₂
  cases h₁ with
  | refl => exact ⟨c, h₂, .refl c⟩
  | head step _ => exact absurd step no_step_empty

/-- In the empty system, ThueEq is just equality. -/
theorem thueEq_empty_iff_eq {α : Type u} {a b : Word α} :
    ThueEq ([] : List (SRule α)) a b → a = b := by
  intro h
  induction h with
  | refl => rfl
  | fwd r _ _ hmem => simp at hmem
  | bwd r _ _ hmem => simp at hmem
  | symm _ ih => exact ih.symm
  | trans _ _ ih1 ih2 => exact ih1.trans ih2

/-! ## Single-Rule Systems -/

/-- In a single-rule system, steps decompose predictably. -/
theorem single_rule_step {α : Type u} (l r : Word α)
    {a b : Word α} (h : SStep [SRule.mk l r] a b) :
    ∃ u v, a = u ++ l ++ v ∧ b = u ++ r ++ v := by
  cases h with
  | apply rule u v hmem =>
    simp at hmem
    subst hmem
    exact ⟨u, v, rfl, rfl⟩

/-- In a single-rule system, if the rule is length-reducing, the system terminates. -/
theorem single_rule_terminates {α : Type u} (l r : Word α)
    (hlr : r.length < l.length) :
    WellFounded (fun a b => SStep [SRule.mk l r] b a) :=
  length_reducing_wf (fun rule hmem => by simp at hmem; subst hmem; exact hlr)

/-! ## Rewriting Preserves Thue Classes -/

/-- Forward steps are in the same Thue class. -/
theorem sstep_same_class {α : Type u} {rules : List (SRule α)}
    {a b : Word α} (h : SStep rules a b) :
    ThueEq rules a b := h.toThueEq

/-- Multi-step rewriting preserves Thue class. -/
theorem srtc_same_class {α : Type u} {rules : List (SRule α)}
    {a b : Word α} (h : SRtc rules a b) :
    ThueEq rules a b := h.toThueEq

/-- NFs are Thue-equivalent to their source. -/
theorem nf_same_class {α : Type u} {rules : List (SRule α)}
    {a nf : Word α} (h : SRtc rules a nf) :
    ThueEq rules a nf := srtc_same_class h

/-! ## Path Representation of Rewriting -/

/-- Every SStep yields an equality proof (the words are literally equal since
the step is indexed by the before/after words). -/
theorem sstep_eq {α : Type u} {rules : List (SRule α)}
    {a b : Word α} (_ : SStep rules a b) :
    ∃ r u v, r ∈ rules ∧ a = u ++ r.lhs ++ v ∧ b = u ++ r.rhs ++ v := by
  rename_i h
  cases h with
  | apply r u v hmem => exact ⟨r, u, v, hmem, rfl, rfl⟩

/-- Confluence implies all NFs of a word are in the same path-equivalence class. -/
theorem nf_path_class {α : Type u} {rules : List (SRule α)}
    (hconf : Confluent rules)
    {a nf₁ nf₂ : Word α}
    (h₁ : SRtc rules a nf₁) (hnf₁ : IsNF rules nf₁)
    (h₂ : SRtc rules a nf₂) (hnf₂ : IsNF rules nf₂) :
    nf₁ = nf₂ :=
  unique_normal_form hconf h₁ hnf₁ h₂ hnf₂

end ComputationalPaths.Path.Rewrite.StringRewriting
