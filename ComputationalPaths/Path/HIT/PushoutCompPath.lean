import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.RwEq
import ComputationalPaths.Path.Basic

/-
# Pushout via computational path expressions

Defines a pushout type as a quotient of `Sum A B` together with a syntax tree
of path expressions generated by `glue`, `inlPath`, and `inrPath`.  Path
expressions are quotiented by rewrite equality of their interpreted paths.

## Key Results

- `PushoutCompPath`: quotient pushout of a span `A ← C → B`.
- `PushoutCompPathExpr`: syntax trees for paths in the pushout.
- `PushoutCompPathExprQuot`: quotient of expressions by path rewrite equality.

## References

- Computational paths framework (explicit path expressions).
-/

namespace ComputationalPaths
namespace Path
namespace HIT

universe u

/-- Unit type at any universe level (for wedge/suspension constructions). -/
inductive PUnit' : Type u where
  | unit : PUnit'

instance : Inhabited PUnit' := ⟨PUnit'.unit⟩

instance : Subsingleton PUnit' where
  allEq := by
    intro a b
    cases a <;> cases b <;> rfl

/-- A type is path-connected if all its points are path-connected to a basepoint.
    Note: Must be Type-valued to hold data (the basepoint), not Prop. -/
class IsPathConnected (A : Type u) : Type u where
  base : A
  connected : ∀ (x : A), Path base x

namespace IsPathConnected

variable {A : Type u} [h : IsPathConnected A]

/-- Connect any two points in a path-connected space. -/
def connect (x y : A) : Path x y :=
  Path.trans (Path.symm (IsPathConnected.connected x)) (IsPathConnected.connected y)

end IsPathConnected

/-! ## Pushout type -/

/-- Relation generating the pushout quotient: identify `inl (f c)` with
`inr (g c)` for each `c : C`. -/
inductive PushoutCompPathRel (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Sum A B → Sum A B → Prop
  | glue (c : C) : PushoutCompPathRel A B C f g (Sum.inl (f c)) (Sum.inr (g c))

/-- Pushout of a span `A ← C → B` as a quotient of `Sum A B`. -/
def PushoutCompPath (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Type u :=
  Quot (PushoutCompPathRel A B C f g)

namespace PushoutCompPath

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-! ## Point constructors -/

/-- Left injection into the pushout. -/
def inl (a : A) : PushoutCompPath A B C f g :=
  Quot.mk _ (Sum.inl a)

/-- Right injection into the pushout. -/
def inr (b : B) : PushoutCompPath A B C f g :=
  Quot.mk _ (Sum.inr b)

/-! ## Glue path -/

/-- The gluing path: `inl (f c)` is identified with `inr (g c)`. -/
def glue (c : C) : Path (inl (f c) : PushoutCompPath A B C f g) (inr (g c)) :=
  Path.ofEq <|
    Quot.sound (PushoutCompPathRel.glue (A := A) (B := B) (C := C) (f := f) (g := g) c)

/-- Inverse of the gluing path. -/
def glueInv (c : C) : Path (inr (g c) : PushoutCompPath A B C f g) (inl (f c)) :=
  Path.symm (glue (A := A) (B := B) (C := C) (f := f) (g := g) c)

/-! ## Path expressions -/

/-- Path expressions for the computational pushout.

These are syntax trees generated by:
- `glue` for crossing the span,
- `inlPath`/`inrPath` for internal paths,
- `refl`, `symm`, `trans` for groupoid structure.
-/
inductive PushoutCompPathExpr (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) :
    PushoutCompPath A B C f g → PushoutCompPath A B C f g → Type u
  | glue (c : C) :
      PushoutCompPathExpr A B C f g (inl (f c)) (inr (g c))
  | inlPath {a a' : A} (p : Path a a') :
      PushoutCompPathExpr A B C f g (inl a) (inl a')
  | inrPath {b b' : B} (p : Path b b') :
      PushoutCompPathExpr A B C f g (inr b) (inr b')
  | refl (x : PushoutCompPath A B C f g) :
      PushoutCompPathExpr A B C f g x x
  | symm {x y : PushoutCompPath A B C f g}
      (p : PushoutCompPathExpr A B C f g x y) :
      PushoutCompPathExpr A B C f g y x
  | trans {x y z : PushoutCompPath A B C f g}
      (p : PushoutCompPathExpr A B C f g x y)
      (q : PushoutCompPathExpr A B C f g y z) :
      PushoutCompPathExpr A B C f g x z

/-- Interpret a path expression as a computational path. -/
def exprToPath {x y : PushoutCompPath A B C f g} :
    PushoutCompPathExpr A B C f g x y → Path x y
  | PushoutCompPathExpr.glue c => glue (A := A) (B := B) (C := C) (f := f) (g := g) c
  | PushoutCompPathExpr.inlPath p => Path.congrArg (inl (A := A) (B := B) (C := C) (f := f) (g := g)) p
  | PushoutCompPathExpr.inrPath p => Path.congrArg (inr (A := A) (B := B) (C := C) (f := f) (g := g)) p
  | PushoutCompPathExpr.refl x => Path.refl x
  | PushoutCompPathExpr.symm p => Path.symm (exprToPath p)
  | PushoutCompPathExpr.trans p q => Path.trans (exprToPath p) (exprToPath q)

/-! ## Expression quotient -/

/-- Two expressions are equivalent if their interpreted paths are rewrite-equal. -/
def exprRel {x y : PushoutCompPath A B C f g}
    (p q : PushoutCompPathExpr A B C f g x y) : Prop :=
  RwEq (exprToPath (A := A) (B := B) (C := C) (f := f) (g := g) p)
       (exprToPath (A := A) (B := B) (C := C) (f := f) (g := g) q)

@[simp] theorem exprRel_refl {x y : PushoutCompPath A B C f g}
    (p : PushoutCompPathExpr A B C f g x y) : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p p :=
  rweq_refl _

@[simp] theorem exprRel_symm {x y : PushoutCompPath A B C f g}
    {p q : PushoutCompPathExpr A B C f g x y}
    (h : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p q) :
    exprRel (A := A) (B := B) (C := C) (f := f) (g := g) q p :=
  rweq_symm h

@[simp] theorem exprRel_trans {x y : PushoutCompPath A B C f g}
    {p q r : PushoutCompPathExpr A B C f g x y}
    (h₁ : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p q)
    (h₂ : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) q r) :
    exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p r :=
  rweq_trans h₁ h₂

/-- Setoid on pushout path expressions. -/
def exprSetoid (x y : PushoutCompPath A B C f g) :
    Setoid (PushoutCompPathExpr A B C f g x y) where
  r := exprRel (A := A) (B := B) (C := C) (f := f) (g := g)
  iseqv := by
    refine ⟨?refl, ?symm, ?trans⟩
    · intro p
      exact exprRel_refl (A := A) (B := B) (C := C) (f := f) (g := g) p
    · intro p q h
      exact exprRel_symm (A := A) (B := B) (C := C) (f := f) (g := g) h
    · intro p q r h₁ h₂
      exact exprRel_trans (A := A) (B := B) (C := C) (f := f) (g := g) h₁ h₂

/-- Quotient of path expressions by rewrite equality. -/
abbrev PushoutCompPathExprQuot (x y : PushoutCompPath A B C f g) : Type u :=
  Quot (exprSetoid (A := A) (B := B) (C := C) (f := f) (g := g) x y).r

/-- Embed an expression into the quotient. -/
def exprClass {x y : PushoutCompPath A B C f g}
    (p : PushoutCompPathExpr A B C f g x y) : PushoutCompPathExprQuot (A := A) (B := B) (C := C)
      (f := f) (g := g) x y :=
  Quot.mk _ p

/-! ## Summary -/

end PushoutCompPath

/-! ## Compatibility aliases -/

/-- Alias for the computational pushout, matching the legacy name. -/
abbrev Pushout (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Type u :=
  PushoutCompPath A B C f g

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-- Alias for the left injection. -/
def inl (a : A) : Pushout A B C f g :=
  PushoutCompPath.inl (A := A) (B := B) (C := C) (f := f) (g := g) a

/-- Alias for the right injection. -/
def inr (b : B) : Pushout A B C f g :=
  PushoutCompPath.inr (A := A) (B := B) (C := C) (f := f) (g := g) b

/-- Alias for the gluing path. -/
def glue (c : C) : Path (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c))
    (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c)) :=
  PushoutCompPath.glue (A := A) (B := B) (C := C) (f := f) (g := g) c

/-- Alias for the left-path constructor. -/
def inlPath {a a' : A} (p : Path a a') :
    Path (inl (A := A) (B := B) (C := C) (f := f) (g := g) a)
      (inl (A := A) (B := B) (C := C) (f := f) (g := g) a') :=
  Path.congrArg (inl (A := A) (B := B) (C := C) (f := f) (g := g)) p

/-- Alias for the right-path constructor. -/
def inrPath {b b' : B} (p : Path b b') :
    Path (inr (A := A) (B := B) (C := C) (f := f) (g := g) b)
      (inr (A := A) (B := B) (C := C) (f := f) (g := g) b') :=
  Path.congrArg (inr (A := A) (B := B) (C := C) (f := f) (g := g)) p

end Pushout

/-- Alias for the wedge sum (pushout of unit). -/
abbrev Wedge (A : Type u) (B : Type u) (a₀ : A) (b₀ : B) : Type u :=
  Pushout A B PUnit' (fun _ => a₀) (fun _ => b₀)

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}
variable (c₀ : C)

/-- Naturality condition for loops in the pushout.
    This class asserts that certain rewrite equalities hold between glue paths.
    It is needed for the Seifert-Van Kampen theorem proof. -/
class HasGlueNaturalLoopRwEq : Prop where
   eq : ∀ (c : C) (p : Path c₀ c),
      RwEq (trans (symm (inlPath (congrArg f p))) (trans (glue c₀) (inrPath (congrArg g p))))
           (glue c)

end Pushout

namespace Wedge

variable {A : Type u} {B : Type u}
variable {a₀ : A} {b₀ : B}

def inl (a : A) : Wedge A B a₀ b₀ :=
  Pushout.inl (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) a

def inr (b : B) : Wedge A B a₀ b₀ :=
  Pushout.inr (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) b

def wedgeBasepoint : Wedge A B a₀ b₀ :=
  inl (A := A) (B := B) (a₀ := a₀) (b₀ := b₀) a₀

def glue : Path (inl (A := A) (B := B) (a₀ := a₀) (b₀ := b₀) a₀)
    (inr (A := A) (B := B) (a₀ := a₀) (b₀ := b₀) b₀) :=
  Pushout.glue (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) PUnit'.unit

end Wedge

/-! ## Legacy notation -/

/-- Legacy-style basepoint for wedge sums. -/
@[simp] def Wedge.basepoint {A : Type u} {B : Type u} {a₀ : A} {b₀ : B} : Wedge A B a₀ b₀ :=
  Wedge.wedgeBasepoint (A := A) (B := B) (a₀ := a₀) (b₀ := b₀)
end HIT
end Path
end ComputationalPaths
