/-
# Pushout as a Higher-Inductive Type

This module defines the pushout (homotopy pushout) as a higher-inductive type,
following the computational paths framework. The pushout is the fundamental
construction needed for the Seifert-Van Kampen theorem.

## The Pushout

Given types A, B, C with maps f : C → A and g : C → B, the pushout is:

```
      C ---g---> B
      |         |
      f         inr
      |         |
      v         v
      A --inl-> Pushout A B C f g
```

with a path `glue c : inl (f c) = inr (g c)` for each c : C.

## Key Results (to be proven)

- Path characterization: paths in Pushout decompose into "words"
- Seifert-Van Kampen: π₁(Pushout) ≃ π₁(A) *_{π₁(C)} π₁(B)

## References

- Favonia & Shulman, "The Seifert-van Kampen Theorem in HoTT"
- HoTT Book, Chapter 6.8
-/

import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Homotopy.Loops
import ComputationalPaths.Path.Homotopy.FundamentalGroup
import ComputationalPaths.Path.Homotopy.Sets
import ComputationalPaths.Path.Rewrite.Quot

namespace ComputationalPaths
namespace Path

universe u v w

/-! ## Pushout Type Definition -/

/-- Relation generating the pushout quotient: identify `inl (f c)` with
`inr (g c)` for each `c : C`. -/
inductive PushoutRel (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Sum A B → Sum A B → Prop
  | glue (c : C) : PushoutRel A B C f g (Sum.inl (f c)) (Sum.inr (g c))

/-- The pushout of a span `A ← C → B`, implemented as a quotient of `Sum A B`
by the relation generated by the glue constructor. -/
def Pushout (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Type u :=
  Quot (PushoutRel A B C f g)

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-! ## Point Constructors -/

/-- Left injection into the pushout. -/
def inl (a : A) : Pushout A B C f g :=
  Quot.mk _ (Sum.inl a)

/-- Right injection into the pushout. -/
def inr (b : B) : Pushout A B C f g :=
  Quot.mk _ (Sum.inr b)

/-! ## Path Constructor -/

/-- The gluing path: for each c : C, we have a path from inl (f c) to inr (g c).
This is the computational path witnessing the pushout square. -/
def glue (c : C) : Path (inl (f c) : Pushout A B C f g) (inr (g c)) :=
  Path.ofEq <|
    Quot.sound (PushoutRel.glue (A := A) (B := B) (C := C) (f := f) (g := g) c)

/-- Inverse of the gluing path. -/
noncomputable def glueInv (c : C) : Path (inr (g c) : Pushout A B C f g) (inl (f c)) :=
  Path.symm (glue c)

/-! ## Non-dependent Eliminator (Recursion Principle) -/

/-- Data for the non-dependent eliminator of the pushout. -/
structure RecData (D : Type v) where
  /-- Image of the left injection. -/
  onInl : A → D
  /-- Image of the right injection. -/
  onInr : B → D
  /-- The glue path maps to a path between images. -/
  onGlue : (c : C) → Path (onInl (f c)) (onInr (g c))

/-- Non-dependent eliminator for the pushout. -/
def rec {D : Type v} (data : RecData (f := f) (g := g) D) :
    Pushout A B C f g → D :=
  Quot.lift
    (fun s : Sum A B =>
      match s with
      | Sum.inl a => data.onInl a
      | Sum.inr b => data.onInr b)
    (by
      intro a b h
      cases h with
      | glue c => exact (data.onGlue c).toEq)

/-- Computation rule for rec at inl. -/
@[simp] theorem rec_inl {D : Type v} (data : RecData (f := f) (g := g) D) (a : A) :
    rec data (inl (A := A) (B := B) (C := C) (f := f) (g := g) a) = data.onInl a := rfl

/-- Computation rule for rec at inr. -/
@[simp] theorem rec_inr {D : Type v} (data : RecData (f := f) (g := g) D) (b : B) :
    rec data (inr (A := A) (B := B) (C := C) (f := f) (g := g) b) = data.onInr b := rfl

/-! ## Dependent Eliminator (Induction Principle) -/

/-- Data for the dependent eliminator of the pushout. -/
structure IndData (D : Pushout A B C f g → Type v) where
  /-- Value at left injection points. -/
  onInl : (a : A) → D (inl a)
  /-- Value at right injection points. -/
  onInr : (b : B) → D (inr b)
  /-- Transport along glue matches the values.
  For each c : C, transporting onInl (f c) along glue c equals onInr (g c). -/
  onGlue : (c : C) →
    Path (Path.transport (D := D) (glue c) (onInl (f c))) (onInr (g c))

/-- Dependent eliminator (induction principle) for the pushout. -/
noncomputable def ind {D : Pushout A B C f g → Type v} (data : IndData (f := f) (g := g) D) :
    (x : Pushout A B C f g) → D x :=
  fun x =>
    Quot.rec (motive := fun z : Pushout A B C f g => D z)
      (fun s =>
        match s with
        | Sum.inl a => data.onInl a
        | Sum.inr b => data.onInr b)
      (by
        intro a b h
        cases h with
        | glue c =>
            -- Goal: transport along `Quot.sound (glue c)` matches the supplied `onGlue`.
            simpa [glue, Path.transport] using (data.onGlue c).toEq)
      x

/-- Computation rule for ind at inl. -/
@[simp] theorem ind_inl {D : Pushout A B C f g → Type v}
    (data : IndData (f := f) (g := g) D) (a : A) :
    ind data (inl (A := A) (B := B) (C := C) (f := f) (g := g) a) = data.onInl a := by
  rfl

/-- Computation rule for ind at inr. -/
@[simp] theorem ind_inr {D : Pushout A B C f g → Type v}
    (data : IndData (f := f) (g := g) D) (b : B) :
    ind data (inr (A := A) (B := B) (C := C) (f := f) (g := g) b) = data.onInr b := by
  rfl

/-! ## Basic Properties -/

/-- The pushout is nonempty if A is nonempty. -/
noncomputable def ofA (a : A) : Pushout A B C f g := inl a

/-- The pushout is nonempty if B is nonempty. -/
noncomputable def ofB (b : B) : Pushout A B C f g := inr b

/-- If both legs are subsingletons and `C` is inhabited, then the pushout is a subsingleton. -/
instance instSubsingleton_of_subsingleton_of_nonempty
    (A : Type u) (B : Type u) (C : Type u) (f : C → A) (g : C → B)
    [Subsingleton A] [Subsingleton B] [Nonempty C] :
    Subsingleton (Pushout A B C f g) where
  allEq := by
    intro x y
    refine Quot.inductionOn x ?_
    intro sx
    refine Quot.inductionOn y ?_
    intro sy
    cases sx with
    | inl a =>
        cases sy with
        | inl a' =>
            have ha : a = a' := Subsingleton.elim a a'
            cases ha
            rfl
        | inr b =>
            obtain ⟨c⟩ := (inferInstance : Nonempty C)
            have ha : a = f c := Subsingleton.elim a (f c)
            have hb : b = g c := Subsingleton.elim b (g c)
            cases ha
            cases hb
            exact Quot.sound (PushoutRel.glue (A := A) (B := B) (C := C) (f := f) (g := g) c)
    | inr b =>
        cases sy with
        | inl a =>
            obtain ⟨c⟩ := (inferInstance : Nonempty C)
            have ha : a = f c := Subsingleton.elim a (f c)
            have hb : b = g c := Subsingleton.elim b (g c)
            cases ha
            cases hb
            exact (Quot.sound (PushoutRel.glue (A := A) (B := B) (C := C) (f := f) (g := g) c)).symm
        | inr b' =>
            have hb : b = b' := Subsingleton.elim b b'
            cases hb
            rfl

/-- Functorial action on paths within the left component. -/
noncomputable def inlPath {a₁ a₂ : A} (p : Path a₁ a₂) :
    Path (inl a₁ : Pushout A B C f g) (inl a₂) :=
  Path.congrArg inl p

/-- Functorial action on paths within the right component. -/
noncomputable def inrPath {b₁ b₂ : B} (p : Path b₁ b₂) :
    Path (inr b₁ : Pushout A B C f g) (inr b₂) :=
  Path.congrArg inr p

/-! ## Glue Naturality

The glue paths are natural with respect to paths in C. For any path p : c₁ =_C c₂,
we have a commuting square:

```
  inl(f c₁) ---inlPath(f*(p))---> inl(f c₂)
      |                              |
  glue(c₁)                       glue(c₂)
      |                              |
      v                              v
  inr(g c₁) ---inrPath(g*(p))---> inr(g c₂)
```

This means: inlPath(f*(p)) ⋅ glue(c₂) = glue(c₁) ⋅ inrPath(g*(p))
-/

/-- **Glue naturality axiom**: The glue path is natural with respect to paths in C.
This states that inlPath(f*(p)) ≈ glue ⋅ inrPath(g*(p)) ⋅ glue⁻¹, which captures
the commutativity of the pushout square at the level of paths. -/
class HasGlueNaturalRwEq : Prop where
  glue_natural_rweq_axiom {c₁ c₂ : C} (p : Path c₁ c₂) :
      RwEq (inlPath (Path.congrArg f p) : Path (inl (f c₁)) (inl (f c₂)))
           (Path.trans (glue c₁)
              (Path.trans (inrPath (Path.congrArg g p))
                (Path.symm (glue c₂))))

theorem glue_natural_rweq_axiom [h : HasGlueNaturalRwEq (A := A) (B := B) (C := C) (f := f) (g := g)]
    {c₁ c₂ : C} (p : Path c₁ c₂) :
    RwEq (inlPath (Path.congrArg f p) : Path (inl (f c₁)) (inl (f c₂)))
         (Path.trans (glue c₁)
            (Path.trans (inrPath (Path.congrArg g p))
              (Path.symm (glue c₂)))) :=
  h.glue_natural_rweq_axiom (p := p)

/-- Glue naturality in RwEq form for fundamental group calculations.
States that inlPath(f*(p)) is RwEq to glue ⋅ inrPath(g*(p)) ⋅ glue⁻¹.

Since equality proofs are proof-irrelevant, it is enough to show both sides
have the same underlying propositional equality. -/
theorem glue_natural_rweq [HasGlueNaturalRwEq (A := A) (B := B) (C := C) (f := f) (g := g)]
    {c₁ c₂ : C} (p : Path c₁ c₂) :
    RwEq (inlPath (Path.congrArg f p) : Path (inl (f c₁)) (inl (f c₂)))
         (Path.trans (glue c₁)
            (Path.trans (inrPath (Path.congrArg g p))
              (Path.symm (glue c₂)))) :=
  glue_natural_rweq_axiom p

/-- **Loop-only glue naturality axiom**: The glue path is natural with respect to loops at `c₀`.

This is the only form of glue naturality used by the SVK decoding proof, since
amalgamation is witnessed by conjugating loops at the chosen basepoint. -/
class HasGlueNaturalLoopRwEq (c₀ : C) : Prop where
  glue_natural_loop_rweq_axiom (p : LoopSpace C c₀) :
      RwEq
        (inlPath (Path.congrArg f p) :
          LoopSpace (Pushout A B C f g) (inl (f c₀)))
        (Path.trans (glue c₀)
          (Path.trans (inrPath (Path.congrArg g p))
            (Path.symm (glue c₀))))

instance hasGlueNaturalLoopRwEq_of_hasGlueNaturalRwEq (c₀ : C)
    [HasGlueNaturalRwEq (A := A) (B := B) (C := C) (f := f) (g := g)] :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ where
  glue_natural_loop_rweq_axiom p := by
    simpa using (glue_natural_rweq (A := A) (B := B) (C := C) (f := f) (g := g) (p := p))

/-- If `C` satisfies Axiom K (all loops rewrite to refl), then glue naturality for loops
holds automatically: both sides reduce to the trivial loop at the basepoint. -/
theorem hasGlueNaturalLoopRwEq_of_axiomK (c₀ : C) (hC : AxiomK C) :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ where
  glue_natural_loop_rweq_axiom p := by
    -- In a type satisfying Axiom K, every loop is rewrite-equal to `refl`.
    have hp : RwEq p (Path.refl c₀) := hC c₀ p

    have hf : RwEq (Path.congrArg f p) (Path.refl (f c₀)) :=
      RwEq.trans (rweq_congrArg_of_rweq f hp) (rweq_congrArg_refl f c₀)
    have hg : RwEq (Path.congrArg g p) (Path.refl (g c₀)) :=
      RwEq.trans (rweq_congrArg_of_rweq g hp) (rweq_congrArg_refl g c₀)

    have hlhs :
        RwEq
          (inlPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg f p))
          (Path.refl (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c₀))) := by
      -- `inlPath` is `congrArg inl`, so rewrite via congruence.
      simpa [inlPath] using
        RwEq.trans (rweq_congrArg_of_rweq (inl (A := A) (B := B) (C := C) (f := f) (g := g)) hf)
          (rweq_congrArg_refl (inl (A := A) (B := B) (C := C) (f := f) (g := g)) (f c₀))

    have hinr :
        RwEq
          (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
          (Path.refl (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c₀))) := by
      simpa [inrPath] using
        RwEq.trans (rweq_congrArg_of_rweq (inr (A := A) (B := B) (C := C) (f := f) (g := g)) hg)
          (rweq_congrArg_refl (inr (A := A) (B := B) (C := C) (f := f) (g := g)) (g c₀))

    -- Reduce the RHS to `refl` using the above and the inverse law for `glue`.
    let glue₀ :=
      glue (A := A) (B := B) (C := C) (f := f) (g := g) c₀
    have inner_eq :
        RwEq
          (Path.trans
            (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
            (Path.symm glue₀))
          (Path.symm glue₀) := by
      have step1 :
          RwEq
            (Path.trans
              (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
              (Path.symm glue₀))
            (Path.trans
              (Path.refl (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c₀)))
              (Path.symm glue₀)) :=
        rweq_trans_congr_left (Path.symm glue₀) hinr
      have step2 :
          RwEq
            (Path.trans
              (Path.refl (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c₀)))
              (Path.symm glue₀))
            (Path.symm glue₀) :=
        rweq_cmpA_refl_left (Path.symm glue₀)
      exact RwEq.trans step1 step2

    have hrhs :
        RwEq
          (Path.trans glue₀
            (Path.trans
              (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
              (Path.symm glue₀)))
          (Path.refl (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c₀))) := by
      have step3 :
          RwEq
            (Path.trans glue₀
              (Path.trans
                (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
                (Path.symm glue₀)))
            (Path.trans glue₀ (Path.symm glue₀)) :=
        rweq_trans_congr_right glue₀ inner_eq
      exact RwEq.trans step3 (rweq_cmpA_inv_right glue₀)

    -- Both sides are rewrite-equal to `refl`, so they are rewrite-equal to each other.
    exact RwEq.trans hlhs (rweq_symm hrhs)

/-- A convenient specialization: subsingleton gluing types automatically satisfy loop naturality. -/
instance hasGlueNaturalLoopRwEq_of_subsingleton (c₀ : C) [Subsingleton C] :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ :=
  hasGlueNaturalLoopRwEq_of_axiomK (A := A) (B := B) (C := C) (f := f) (g := g) c₀
    (hC := axiomK_of_subsingleton (A := C))

/-- H-set gluing types satisfy loop naturality (via Axiom K). -/
instance hasGlueNaturalLoopRwEq_of_isHSet (c₀ : C) [IsHSet C] :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ := by
  have hC : AxiomK C := isHSet_implies_axiomK (A := C) (h := inferInstance)
  exact hasGlueNaturalLoopRwEq_of_axiomK (A := A) (B := B) (C := C) (f := f) (g := g) c₀ hC

/-- If both legs `A` and `B` satisfy Axiom K (all loops rewrite to refl), then glue naturality for
loops holds automatically: both sides of the naturality statement reduce to the trivial loop in
the pushout. -/
theorem hasGlueNaturalLoopRwEq_of_axiomK_left_right (c₀ : C) (hA : AxiomK A) (hB : AxiomK B) :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ where
  glue_natural_loop_rweq_axiom p := by
    have hf : RwEq (Path.congrArg f p) (Path.refl (f c₀)) := hA (f c₀) (Path.congrArg f p)
    have hg : RwEq (Path.congrArg g p) (Path.refl (g c₀)) := hB (g c₀) (Path.congrArg g p)

    have hlhs :
        RwEq
          (inlPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg f p))
          (Path.refl (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c₀))) := by
      simpa [inlPath] using
        RwEq.trans
          (rweq_congrArg_of_rweq (inl (A := A) (B := B) (C := C) (f := f) (g := g)) hf)
          (rweq_congrArg_refl (inl (A := A) (B := B) (C := C) (f := f) (g := g)) (f c₀))

    have hinr :
        RwEq
          (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
          (Path.refl (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c₀))) := by
      simpa [inrPath] using
        RwEq.trans
          (rweq_congrArg_of_rweq (inr (A := A) (B := B) (C := C) (f := f) (g := g)) hg)
          (rweq_congrArg_refl (inr (A := A) (B := B) (C := C) (f := f) (g := g)) (g c₀))

    let glue₀ := glue (A := A) (B := B) (C := C) (f := f) (g := g) c₀

    have inner_eq :
        RwEq
          (Path.trans
            (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
            (Path.symm glue₀))
          (Path.symm glue₀) := by
      have step1 :
          RwEq
            (Path.trans
              (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
              (Path.symm glue₀))
            (Path.trans
              (Path.refl (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c₀)))
              (Path.symm glue₀)) :=
        rweq_trans_congr_left (Path.symm glue₀) hinr
      have step2 :
          RwEq
            (Path.trans
              (Path.refl (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c₀)))
              (Path.symm glue₀))
            (Path.symm glue₀) :=
        rweq_cmpA_refl_left (Path.symm glue₀)
      exact RwEq.trans step1 step2

    have hrhs :
        RwEq
          (Path.trans glue₀
            (Path.trans
              (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
              (Path.symm glue₀)))
          (Path.refl (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c₀))) := by
      have step3 :
          RwEq
            (Path.trans glue₀
              (Path.trans
                (inrPath (A := A) (B := B) (C := C) (f := f) (g := g) (Path.congrArg g p))
                (Path.symm glue₀)))
            (Path.trans glue₀ (Path.symm glue₀)) :=
        rweq_trans_congr_right glue₀ inner_eq
      exact RwEq.trans step3 (rweq_cmpA_inv_right glue₀)

    exact RwEq.trans hlhs (rweq_symm hrhs)

/-- A convenient specialization: if both legs are subsingletons, loop naturality holds
without assumptions on the gluing type `C`. -/
instance (priority := 50) hasGlueNaturalLoopRwEq_of_subsingleton_left_right (c₀ : C)
    [Subsingleton A] [Subsingleton B] :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ :=
  hasGlueNaturalLoopRwEq_of_axiomK_left_right (A := A) (B := B) (C := C) (f := f) (g := g) c₀
    (hA := axiomK_of_subsingleton (A := A))
    (hB := axiomK_of_subsingleton (A := B))

/-- If both legs are h-sets, loop naturality follows from Axiom K on each leg. -/
instance (priority := 50) hasGlueNaturalLoopRwEq_of_isHSet_left_right (c₀ : C)
    [IsHSet A] [IsHSet B] :
    HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀ := by
  have hA : AxiomK A := isHSet_implies_axiomK (A := A) (h := inferInstance)
  have hB : AxiomK B := isHSet_implies_axiomK (A := B) (h := inferInstance)
  exact
    hasGlueNaturalLoopRwEq_of_axiomK_left_right
      (A := A) (B := B) (C := C) (f := f) (g := g) c₀ hA hB

/- Decidable-equality shortcuts previously relied on a global Axiom K interface.
   We now keep only explicit Axiom K proofs, so supply `hasGlueNaturalLoopRwEq_of_axiomK`
   or `hasGlueNaturalLoopRwEq_of_axiomK_left_right` directly when available. -/

/-- Glue naturality for loops: For a loop p at c₀, inlPath(f*(p)) equals
glue ⋅ inrPath(g*(p)) ⋅ glue⁻¹ up to RwEq. This is the key fact for SVK. -/
theorem glue_natural_loop_rweq
    (c₀ : C)
    [h : HasGlueNaturalLoopRwEq (A := A) (B := B) (C := C) (f := f) (g := g) c₀]
    (p : LoopSpace C c₀) :
    RwEq (inlPath (Path.congrArg f p) : LoopSpace (Pushout A B C f g) (inl (f c₀)))
         (Path.trans (glue c₀)
           (Path.trans (inrPath (Path.congrArg g p))
              (Path.symm (glue c₀)))) :=
  h.glue_natural_loop_rweq_axiom p

/-! ## Cocone Structure -/

/-- A cocone over the span A ←f─ C ─g→ B consists of:
- A vertex type D
- Maps from A and B to D
- A proof that the two compositions C → D are equal (up to path) -/
structure Cocone (D : Type v) where
  vertexInl : A → D
  vertexInr : B → D
  commutes : (c : C) → Path (vertexInl (f c)) (vertexInr (g c))

/-- The pushout is the universal cocone. -/
noncomputable def pushoutCocone : Cocone (f := f) (g := g) (Pushout A B C f g) where
  vertexInl := inl
  vertexInr := inr
  commutes := glue

/-- Any cocone factors through the pushout. -/
noncomputable def coconeMap {D : Type v} (cocone : Cocone (f := f) (g := g) D) :
    Pushout A B C f g → D :=
  rec ⟨cocone.vertexInl, cocone.vertexInr, cocone.commutes⟩

@[simp] theorem coconeMap_inl {D : Type v} (cocone : Cocone (f := f) (g := g) D)
    (a : A) : coconeMap cocone (inl a) = cocone.vertexInl a :=
  rec_inl ⟨cocone.vertexInl, cocone.vertexInr, cocone.commutes⟩ a

@[simp] theorem coconeMap_inr {D : Type v} (cocone : Cocone (f := f) (g := g) D)
    (b : B) : coconeMap cocone (inr b) = cocone.vertexInr b :=
  rec_inr ⟨cocone.vertexInl, cocone.vertexInr, cocone.commutes⟩ b

end Pushout

/-! ## Special Cases of Pushouts -/

section SpecialCases

universe uu

/-- Unit type at any universe level. -/
inductive PUnit' : Type uu where
  | unit : PUnit'

/-- PUnit' has decidable equality (trivially, since there's only one element). -/
instance : DecidableEq PUnit' := fun a b =>
  match a, b with
  | .unit, .unit => isTrue rfl

/-- PUnit' is a subsingleton (there is only one element). -/
instance : Subsingleton PUnit' where
  allEq := by
    intro a b
    cases a <;> cases b <;> rfl

/-- The wedge sum A ∨ B is the pushout of A ← PUnit' → B.
This is the disjoint union with basepoints identified. -/
def Wedge (A : Type uu) (B : Type uu) (a₀ : A) (b₀ : B) : Type uu :=
  Pushout A B PUnit' (fun _ => a₀) (fun _ => b₀)

namespace Wedge

variable {A : Type uu} {B : Type uu} {a₀ : A} {b₀ : B}

/-- Left injection into the wedge. -/
noncomputable def inl (a : A) : Wedge A B a₀ b₀ := Pushout.inl a

/-- Right injection into the wedge. -/
noncomputable def inr (b : B) : Wedge A B a₀ b₀ := Pushout.inr b

/-- The basepoint of the wedge (where a₀ and b₀ are identified). -/
noncomputable def basepoint : Wedge A B a₀ b₀ := inl a₀

/-- The glue path identifying the two basepoints. -/
noncomputable def glue : Path (inl a₀ : Wedge A B a₀ b₀) (inr b₀) :=
  Pushout.glue PUnit'.unit

/-- Alternative basepoint via right injection. -/
noncomputable def basepoint_path_inr :
    Path (basepoint : Wedge A B a₀ b₀) (inr b₀) := glue

end Wedge

/-- The suspension ΣA is the pushout of PUnit' ← A → PUnit'.
It adds a north pole, south pole, and meridian paths. -/
def Suspension (A : Type uu) : Type uu :=
  Pushout PUnit' PUnit' A (fun _ => PUnit'.unit) (fun _ => PUnit'.unit)

namespace Suspension

variable {A : Type uu}

/-- North pole of the suspension. -/
noncomputable def north : Suspension A := Pushout.inl PUnit'.unit

/-- South pole of the suspension. -/
noncomputable def south : Suspension A := Pushout.inr PUnit'.unit

/-- Meridian path from north to south, parameterized by a : A. -/
noncomputable def merid (a : A) : Path (north : Suspension A) south :=
  Pushout.glue a

end Suspension

end SpecialCases

/-! ## Connectedness -/

/-- A type is path-connected if any two points are connected by a path. -/
def IsPathConnected (A : Type u) : Prop :=
  ∀ a b : A, Nonempty (Path a b)

/-- A type is pointed if it has a distinguished basepoint. -/
structure Pointed (A : Type u) where
  basepoint : A

/-- A pointed connected type. -/
structure PointedConnected (A : Type u) extends Pointed A where
  connected : IsPathConnected A

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-- Explicitly: inl(a) is connected to inl(f c) via A's connectivity. -/
noncomputable def inl_to_hub (a : A) (c : C) (hA : IsPathConnected A) :
    Path (inl a : Pushout A B C f g) (inl (f c)) :=
  inlPath (Classical.choice (hA a (f c)))

/-- Explicitly: inr(b) is connected to inl(f c) via B's connectivity and glue. -/
noncomputable def inr_to_hub (b : B) (c : C) (hB : IsPathConnected B) :
    Path (inr b : Pushout A B C f g) (inl (f c)) :=
  Path.trans (inrPath (Classical.choice (hB b (g c)))) (glueInv c)

/-- Every point in the pushout is connected to inl(f c) for any c : C.

This is provable for the quotient pushout by reducing to the `Sum A B`
representative of `x`. -/
theorem path_to_hub {c : C} (hA : IsPathConnected A) (hB : IsPathConnected B)
    (x : Pushout A B C f g) : Nonempty (Path x (inl (f c))) := by
  refine Quot.inductionOn x ?_
  intro s
  cases s with
  | inl a =>
      exact ⟨inl_to_hub (A := A) (B := B) (C := C) (f := f) (g := g) a c hA⟩
  | inr b =>
      exact ⟨inr_to_hub (A := A) (B := B) (C := C) (f := f) (g := g) b c hB⟩

/-- If C is nonempty, then the pushout is path-connected when A, B, C are. -/
theorem isPathConnected_of_components
    (hA : IsPathConnected A)
    (hB : IsPathConnected B)
    (hC : Nonempty C) :
    IsPathConnected (Pushout A B C f g) := by
  intro x y
  -- Pick a hub point via C's nonemptiness
  obtain ⟨c⟩ := hC
  -- Both x and y are connected to the hub inl(f c)
  obtain ⟨px⟩ := path_to_hub (c := c) hA hB x
  obtain ⟨py⟩ := path_to_hub (c := c) hA hB y
  -- Compose: x → hub → y
  exact ⟨Path.trans px (Path.symm py)⟩

end Pushout

/-! ## Concrete Glue Naturality Instances

The glue naturality axiom is provable when both span maps are constant. This
covers wedge sums and suspensions, which are pushouts of constant maps.
-/

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}

/-- Glue naturality holds when both maps are constant. -/
instance hasGlueNaturalRwEq_const (a₀ : A) (b₀ : B) :
    Pushout.HasGlueNaturalRwEq
      (A := A) (B := B) (C := C)
      (f := fun _ : C => a₀) (g := fun _ : C => b₀) where
  glue_natural_rweq_axiom {c₁ c₂} p := by
    have lhs_eq :
        RwEq
          (Pushout.inlPath (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)
            (Path.congrArg (fun _ : C => a₀) p))
          (Path.refl
            (Pushout.inl (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) a₀)) := by
      apply rweq_trans
        (rweq_congrArg_of_rweq
          (Pushout.inl (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀))
          (rweq_congrArg_const a₀ p))
      exact
        rweq_congrArg_refl
          (Pushout.inl (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)) a₀

    have rhs_eq :
        RwEq
          (Path.trans
            (Pushout.glue (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) c₁)
            (Path.trans
              (Pushout.inrPath (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)
                (Path.congrArg (fun _ : C => b₀) p))
              (Path.symm
                (Pushout.glue (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) c₂))))
          (Path.refl
            (Pushout.inl (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) a₀)) := by
      have inr_eq :
          RwEq
            (Pushout.inrPath (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)
              (Path.congrArg (fun _ : C => b₀) p))
            (Path.refl
              (Pushout.inr (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) b₀)) := by
        apply rweq_trans
          (rweq_congrArg_of_rweq
            (Pushout.inr (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀))
            (rweq_congrArg_const b₀ p))
        exact
          rweq_congrArg_refl
            (Pushout.inr (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)) b₀

      let glue₁ :=
        Pushout.glue (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) c₁
      let glue₂ :=
        Pushout.glue (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) c₂

      have inner1 :
          RwEq
            (Path.trans
              (Pushout.inrPath (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)
                (Path.congrArg (fun _ : C => b₀) p))
              (Path.symm glue₂))
            (Path.trans
              (Path.refl
                (Pushout.inr (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) b₀))
              (Path.symm glue₂)) :=
        rweq_trans_congr_left (Path.symm glue₂) inr_eq

      have inner2 : RwEq
          (Path.trans
            (Path.refl
              (Pushout.inr (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) b₀))
            (Path.symm glue₂))
          (Path.symm glue₂) :=
        rweq_cmpA_refl_left (Path.symm glue₂)

      have inner : RwEq
          (Path.trans
            (Pushout.inrPath (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)
              (Path.congrArg (fun _ : C => b₀) p))
            (Path.symm glue₂))
          (Path.symm glue₂) :=
        rweq_trans inner1 inner2

      have step3 :
          RwEq
            (Path.trans glue₁
              (Path.trans
                (Pushout.inrPath (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀)
                  (Path.congrArg (fun _ : C => b₀) p))
                (Path.symm glue₂)))
            (Path.trans glue₁ (Path.symm glue₂)) :=
        rweq_trans_congr_right glue₁ inner

      have hglue : glue₂ = glue₁ := by
        simp [glue₁, glue₂, Pushout.glue]

      have step4 :
          RwEq (Path.trans glue₁ (Path.symm glue₂))
            (Path.refl
              (Pushout.inl (A := A) (B := B) (C := C) (f := fun _ : C => a₀) (g := fun _ : C => b₀) a₀)) := by
        have h :
            Path.trans glue₁ (Path.symm glue₂) =
              Path.trans glue₁ (Path.symm glue₁) := by
          simp [hglue]
        exact rweq_trans (rweq_of_eq h) (rweq_cmpA_inv_right glue₁)

      exact rweq_trans step3 step4

    exact rweq_trans lhs_eq (rweq_symm rhs_eq)

/-- Glue naturality is automatic when both codomains are `PUnit'`. -/
instance hasGlueNaturalRwEq_punit {C : Type u} (f g : C → PUnit'.{u}) :
    Pushout.HasGlueNaturalRwEq (A := PUnit'.{u}) (B := PUnit'.{u}) (C := C) (f := f) (g := g) := by
  have hf : f = (fun _ : C => PUnit'.unit) := by
    funext c
    cases f c
    rfl
  have hg : g = (fun _ : C => PUnit'.unit) := by
    funext c
    cases g c
    rfl
  cases hf
  cases hg
  infer_instance

end Pushout

/-! ## Concrete SVK Instances for Wedge Sums

For the wedge sum A ∨ B (defined as Pushout A B PUnit' (fun _ => a₀) (fun _ => b₀)),
the glue naturality axiom holds trivially because the maps f and g are constant.
-/

namespace Wedge

variable {A : Type u} {B : Type u} {a₀ : A} {b₀ : B}

/-- For wedge sums, glue naturality holds because f and g are constant functions.

Since f = (fun _ => a₀) and g = (fun _ => b₀), for any path p : Path c₁ c₂ in PUnit':
- congrArg f p ≈ refl a₀ (by rweq_congrArg_const)
- congrArg g p ≈ refl b₀ (by rweq_congrArg_const)

And since c₁ = c₂ = PUnit'.unit (unique element), both sides reduce to refl. -/
instance hasGlueNaturalRwEq :
    Pushout.HasGlueNaturalRwEq
      (A := A) (B := B) (C := PUnit')
      (f := fun _ => a₀) (g := fun _ => b₀) where
  glue_natural_rweq_axiom {c₁ c₂} p := by
    -- Since PUnit' has only one element, c₁ = c₂ = unit
    cases c₁; cases c₂
    -- Abbreviate the Wedge type for clarity
    let W := Wedge A B a₀ b₀
    -- LHS: inlPath (congrArg (fun _ => a₀) p)
    -- RHS: trans (glue unit) (trans (inrPath (congrArg (fun _ => b₀) p)) (symm (glue unit)))
    -- Both simplify to refl
    have lhs_eq : RwEq
        (Pushout.inlPath (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)
          (Path.congrArg (fun _ => a₀) p))
        (Path.refl (Pushout.inl (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) a₀)) := by
      apply rweq_trans
        (rweq_congrArg_of_rweq
          (Pushout.inl (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀))
          (rweq_congrArg_const a₀ p))
      exact rweq_congrArg_refl
        (Pushout.inl (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)) a₀
    have rhs_eq : RwEq
        (Path.trans
          (Pushout.glue (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) PUnit'.unit)
          (Path.trans
            (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)
              (Path.congrArg (fun _ => b₀) p))
            (Path.symm
              (Pushout.glue (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) PUnit'.unit))))
        (Path.refl (Pushout.inl (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) a₀)) := by
      -- inrPath (congrArg (fun _ => b₀) p) ≈ refl (inr b₀)
      have inr_eq : RwEq
          (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)
            (Path.congrArg (fun _ => b₀) p))
          (Path.refl (Pushout.inr (A := A) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) b₀)) := by
        apply rweq_trans
          (rweq_congrArg_of_rweq
            (Pushout.inr (A := A) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀))
            (rweq_congrArg_const b₀ p))
        exact rweq_congrArg_refl
          (Pushout.inr (A := A) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)) b₀
      -- Let's abbreviate
      let glueW := Pushout.glue (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) PUnit'.unit
      let symGlueW := Path.symm glueW
      let reflInrB₀ := Path.refl (Pushout.inr (A := A) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) b₀)
      -- trans (inrPath ...) (symm glue) ≈ trans refl (symm glue) ≈ symm glue
      have step1 : RwEq
          (Path.trans
            (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)
              (Path.congrArg (fun _ => b₀) p))
            symGlueW)
          (Path.trans reflInrB₀ symGlueW) :=
        rweq_trans_congr_left symGlueW inr_eq
      have step2 : RwEq (Path.trans reflInrB₀ symGlueW) symGlueW :=
        rweq_cmpA_refl_left symGlueW
      have inner_eq : RwEq
          (Path.trans
            (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)
              (Path.congrArg (fun _ => b₀) p))
            symGlueW)
          symGlueW := rweq_trans step1 step2
      -- trans glue (inner) ≈ trans glue (symm glue) ≈ refl
      have step3 : RwEq (Path.trans glueW (Path.trans
            (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀)
              (Path.congrArg (fun _ => b₀) p))
            symGlueW)) (Path.trans glueW symGlueW) :=
        rweq_trans_congr_right glueW inner_eq
      have step4 : RwEq (Path.trans glueW symGlueW)
          (Path.refl (Pushout.inl (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) a₀)) :=
        rweq_cmpA_inv_right glueW
      exact rweq_trans step3 step4
    exact rweq_trans lhs_eq (rweq_symm rhs_eq)

end Wedge

end Path
end ComputationalPaths
