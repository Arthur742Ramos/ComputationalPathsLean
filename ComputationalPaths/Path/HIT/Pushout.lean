/-
# Pushout as a Higher-Inductive Type

This module defines the pushout (homotopy pushout) as a higher-inductive type,
following the computational paths framework. The pushout is the fundamental
construction needed for the Seifert-Van Kampen theorem.

## The Pushout

Given types A, B, C with maps f : C → A and g : C → B, the pushout is:

```
      C ---g---> B
      |         |
      f         inr
      |         |
      v         v
      A --inl-> Pushout A B C f g
```

with a path `glue c : inl (f c) = inr (g c)` for each c : C.

## Key Results (to be proven)

- Path characterization: paths in Pushout decompose into "words"
- Seifert-Van Kampen: π₁(Pushout) ≃ π₁(A) *_{π₁(C)} π₁(B)

## References

- Favonia & Shulman, "The Seifert-van Kampen Theorem in HoTT"
- HoTT Book, Chapter 6.8
-/

import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Homotopy.Loops
import ComputationalPaths.Path.Homotopy.FundamentalGroup
import ComputationalPaths.Path.Rewrite.Quot

namespace ComputationalPaths
namespace Path

universe u v w

/-! ## Pushout Type Definition -/

/-- Relation generating the pushout quotient: identify `inl (f c)` with
`inr (g c)` for each `c : C`. -/
inductive PushoutRel (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Sum A B → Sum A B → Prop
  | glue (c : C) : PushoutRel A B C f g (Sum.inl (f c)) (Sum.inr (g c))

/-- The pushout of a span `A ← C → B`, implemented as a quotient of `Sum A B`
by the relation generated by the glue constructor. -/
def Pushout (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Type u :=
  Quot (PushoutRel A B C f g)

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-! ## Point Constructors -/

/-- Left injection into the pushout. -/
def inl (a : A) : Pushout A B C f g :=
  Quot.mk _ (Sum.inl a)

/-- Right injection into the pushout. -/
def inr (b : B) : Pushout A B C f g :=
  Quot.mk _ (Sum.inr b)

/-! ## Path Constructor -/

/-- The gluing path: for each c : C, we have a path from inl (f c) to inr (g c).
This is the computational path witnessing the pushout square. -/
def glue (c : C) : Path (inl (f c) : Pushout A B C f g) (inr (g c)) :=
  Path.ofEq <|
    Quot.sound (PushoutRel.glue (A := A) (B := B) (C := C) (f := f) (g := g) c)

/-- Inverse of the gluing path. -/
noncomputable def glueInv (c : C) : Path (inr (g c) : Pushout A B C f g) (inl (f c)) :=
  Path.symm (glue c)

/-! ## Non-dependent Eliminator (Recursion Principle) -/

/-- Data for the non-dependent eliminator of the pushout. -/
structure RecData (D : Type v) where
  /-- Image of the left injection. -/
  onInl : A → D
  /-- Image of the right injection. -/
  onInr : B → D
  /-- The glue path maps to a path between images. -/
  onGlue : (c : C) → Path (onInl (f c)) (onInr (g c))

/-- Non-dependent eliminator for the pushout. -/
def rec {D : Type v} (data : RecData (f := f) (g := g) D) :
    Pushout A B C f g → D :=
  Quot.lift
    (fun s : Sum A B =>
      match s with
      | Sum.inl a => data.onInl a
      | Sum.inr b => data.onInr b)
    (by
      intro a b h
      cases h with
      | glue c => exact (data.onGlue c).toEq)

/-- Computation rule for rec at inl. -/
@[simp] theorem rec_inl {D : Type v} (data : RecData (f := f) (g := g) D) (a : A) :
    rec data (inl (A := A) (B := B) (C := C) (f := f) (g := g) a) = data.onInl a := rfl

/-- Computation rule for rec at inr. -/
@[simp] theorem rec_inr {D : Type v} (data : RecData (f := f) (g := g) D) (b : B) :
    rec data (inr (A := A) (B := B) (C := C) (f := f) (g := g) b) = data.onInr b := rfl

/-- **Pushout rec computation axiom**: The recursion principle computes correctly on glue paths.
This is a β-rule for the pushout HIT. -/
axiom rec_glue_rweq {D : Type v} (data : RecData (f := f) (g := g) D) (c : C) :
    RwEq
      (Path.trans
        (Path.symm (Path.ofEq (rec_inl (f := f) (g := g) data (f c))))
        (Path.trans
          (Path.congrArg (rec data) (glue (A := A) (B := B) (C := C) (f := f) (g := g) c))
          (Path.ofEq (rec_inr (f := f) (g := g) data (g c)))))
      (data.onGlue c)

/-- Computation rule for rec on the glue path.
The image of glue c under rec is (up to transport) data.onGlue c. -/
theorem rec_glue {D : Type v} (data : RecData (f := f) (g := g) D) (c : C) :
    RwEq
      (Path.trans
        (Path.symm (Path.ofEq (rec_inl (f := f) (g := g) data (f c))))
        (Path.trans
          (Path.congrArg (rec data) (glue (A := A) (B := B) (C := C) (f := f) (g := g) c))
          (Path.ofEq (rec_inr (f := f) (g := g) data (g c)))))
      (data.onGlue c) :=
  rec_glue_rweq data c

/-
The original HIT-style β-rule states an equality of computational paths.  Since
the `Path` structure remembers a concrete step list, our quotient-based
implementation validates the β-rule up to rewrite equality (`RwEq`), which is
the notion used by the rest of the development.
-/

/-! ## Dependent Eliminator (Induction Principle) -/

/-- Data for the dependent eliminator of the pushout. -/
structure IndData (D : Pushout A B C f g → Type v) where
  /-- Value at left injection points. -/
  onInl : (a : A) → D (inl a)
  /-- Value at right injection points. -/
  onInr : (b : B) → D (inr b)
  /-- Transport along glue matches the values.
  For each c : C, transporting onInl (f c) along glue c equals onInr (g c). -/
  onGlue : (c : C) →
    Path (Path.transport (D := D) (glue c) (onInl (f c))) (onInr (g c))

/-- Dependent eliminator (induction principle) for the pushout. -/
noncomputable def ind {D : Pushout A B C f g → Type v} (data : IndData (f := f) (g := g) D) :
    (x : Pushout A B C f g) → D x :=
  fun x =>
    Quot.rec (motive := fun z : Pushout A B C f g => D z)
      (fun s =>
        match s with
        | Sum.inl a => data.onInl a
        | Sum.inr b => data.onInr b)
      (by
        intro a b h
        cases h with
        | glue c =>
            -- Goal: transport along `Quot.sound (glue c)` matches the supplied `onGlue`.
            simpa [glue, Path.transport] using (data.onGlue c).toEq)
      x

/-- Computation rule for ind at inl. -/
@[simp] theorem ind_inl {D : Pushout A B C f g → Type v}
    (data : IndData (f := f) (g := g) D) (a : A) :
    ind data (inl (A := A) (B := B) (C := C) (f := f) (g := g) a) = data.onInl a := by
  rfl

/-- Computation rule for ind at inr. -/
@[simp] theorem ind_inr {D : Pushout A B C f g → Type v}
    (data : IndData (f := f) (g := g) D) (b : B) :
    ind data (inr (A := A) (B := B) (C := C) (f := f) (g := g) b) = data.onInr b := by
  rfl

/-- **Pushout ind computation axiom**: The induction principle computes correctly on glue paths.
This is a dependent β-rule for the pushout HIT. -/
axiom ind_glue_rweq {D : Pushout A B C f g → Type v}
    (data : IndData (f := f) (g := g) D) (c : C) :
    RwEq
      (Path.trans
      (Path.symm
        (Path.congrArg
          (fun x => Path.transport (D := D) (glue c) x)
          (Path.ofEq (ind_inl data (f c)))))
      (Path.trans
        (Path.apd (f := ind data) (glue c))
        (Path.ofEq (ind_inr data (g c)))))
      (data.onGlue c)

/-- Computation rule for ind on the glue path. -/
theorem ind_glue {D : Pushout A B C f g → Type v}
    (data : IndData (f := f) (g := g) D) (c : C) :
    RwEq
      (Path.trans
      (Path.symm
        (Path.congrArg
          (fun x => Path.transport (D := D) (glue c) x)
          (Path.ofEq (ind_inl data (f c)))))
      (Path.trans
        (Path.apd (f := ind data) (glue c))
        (Path.ofEq (ind_inr data (g c)))))
      (data.onGlue c) :=
  ind_glue_rweq data c

/-! ## Basic Properties -/

/-- The pushout is nonempty if A is nonempty. -/
noncomputable def ofA (a : A) : Pushout A B C f g := inl a

/-- The pushout is nonempty if B is nonempty. -/
noncomputable def ofB (b : B) : Pushout A B C f g := inr b

/-- Functorial action on paths within the left component. -/
noncomputable def inlPath {a₁ a₂ : A} (p : Path a₁ a₂) :
    Path (inl a₁ : Pushout A B C f g) (inl a₂) :=
  Path.congrArg inl p

/-- Functorial action on paths within the right component. -/
noncomputable def inrPath {b₁ b₂ : B} (p : Path b₁ b₂) :
    Path (inr b₁ : Pushout A B C f g) (inr b₂) :=
  Path.congrArg inr p

/-! ## Glue Naturality

The glue paths are natural with respect to paths in C. For any path p : c₁ =_C c₂,
we have a commuting square:

```
  inl(f c₁) ---inlPath(f*(p))---> inl(f c₂)
      |                              |
  glue(c₁)                       glue(c₂)
      |                              |
      v                              v
  inr(g c₁) ---inrPath(g*(p))---> inr(g c₂)
```

This means: inlPath(f*(p)) ⋅ glue(c₂) = glue(c₁) ⋅ inrPath(g*(p))
-/

/-- **Glue naturality axiom**: The glue path is natural with respect to paths in C.
This states that inlPath(f*(p)) ≈ glue ⋅ inrPath(g*(p)) ⋅ glue⁻¹, which captures
the commutativity of the pushout square at the level of paths. -/
axiom glue_natural_rweq_axiom {c₁ c₂ : C} (p : Path c₁ c₂) :
    RwEq (inlPath (Path.congrArg f p) : Path (inl (f c₁)) (inl (f c₂)))
         (Path.trans (glue c₁)
            (Path.trans (inrPath (Path.congrArg g p))
              (Path.symm (glue c₂))))

/-- Glue naturality in RwEq form for fundamental group calculations.
States that inlPath(f*(p)) is RwEq to glue ⋅ inrPath(g*(p)) ⋅ glue⁻¹.

Since equality proofs are proof-irrelevant, it is enough to show both sides
have the same underlying propositional equality. -/
theorem glue_natural_rweq {c₁ c₂ : C} (p : Path c₁ c₂) :
    RwEq (inlPath (Path.congrArg f p) : Path (inl (f c₁)) (inl (f c₂)))
         (Path.trans (glue c₁)
            (Path.trans (inrPath (Path.congrArg g p))
              (Path.symm (glue c₂)))) :=
  glue_natural_rweq_axiom p

/-- Glue naturality for loops: For a loop p at c₀, inlPath(f*(p)) equals
glue ⋅ inrPath(g*(p)) ⋅ glue⁻¹ up to RwEq. This is the key fact for SVK. -/
theorem glue_natural_loop_rweq (c₀ : C) (p : LoopSpace C c₀) :
    RwEq (inlPath (Path.congrArg f p) : LoopSpace (Pushout A B C f g) (inl (f c₀)))
         (Path.trans (glue c₀)
           (Path.trans (inrPath (Path.congrArg g p))
             (Path.symm (glue c₀)))) :=
  glue_natural_rweq p

/-! ## Cocone Structure -/

/-- A cocone over the span A ←f─ C ─g→ B consists of:
- A vertex type D
- Maps from A and B to D
- A proof that the two compositions C → D are equal (up to path) -/
structure Cocone (D : Type v) where
  vertexInl : A → D
  vertexInr : B → D
  commutes : (c : C) → Path (vertexInl (f c)) (vertexInr (g c))

/-- The pushout is the universal cocone. -/
noncomputable def pushoutCocone : Cocone (f := f) (g := g) (Pushout A B C f g) where
  vertexInl := inl
  vertexInr := inr
  commutes := glue

/-- Any cocone factors through the pushout. -/
noncomputable def coconeMap {D : Type v} (cocone : Cocone (f := f) (g := g) D) :
    Pushout A B C f g → D :=
  rec ⟨cocone.vertexInl, cocone.vertexInr, cocone.commutes⟩

@[simp] theorem coconeMap_inl {D : Type v} (cocone : Cocone (f := f) (g := g) D)
    (a : A) : coconeMap cocone (inl a) = cocone.vertexInl a :=
  rec_inl ⟨cocone.vertexInl, cocone.vertexInr, cocone.commutes⟩ a

@[simp] theorem coconeMap_inr {D : Type v} (cocone : Cocone (f := f) (g := g) D)
    (b : B) : coconeMap cocone (inr b) = cocone.vertexInr b :=
  rec_inr ⟨cocone.vertexInl, cocone.vertexInr, cocone.commutes⟩ b

end Pushout

/-! ## Special Cases of Pushouts -/

section SpecialCases

universe uu

/-- Unit type at any universe level. -/
inductive PUnit' : Type uu where
  | unit : PUnit'

/-- PUnit' has decidable equality (trivially, since there's only one element). -/
instance : DecidableEq PUnit' := fun a b =>
  match a, b with
  | .unit, .unit => isTrue rfl

/-- The wedge sum A ∨ B is the pushout of A ← PUnit' → B.
This is the disjoint union with basepoints identified. -/
def Wedge (A : Type uu) (B : Type uu) (a₀ : A) (b₀ : B) : Type uu :=
  Pushout A B PUnit' (fun _ => a₀) (fun _ => b₀)

namespace Wedge

variable {A : Type uu} {B : Type uu} {a₀ : A} {b₀ : B}

/-- Left injection into the wedge. -/
noncomputable def inl (a : A) : Wedge A B a₀ b₀ := Pushout.inl a

/-- Right injection into the wedge. -/
noncomputable def inr (b : B) : Wedge A B a₀ b₀ := Pushout.inr b

/-- The basepoint of the wedge (where a₀ and b₀ are identified). -/
noncomputable def basepoint : Wedge A B a₀ b₀ := inl a₀

/-- The glue path identifying the two basepoints. -/
noncomputable def glue : Path (inl a₀ : Wedge A B a₀ b₀) (inr b₀) :=
  Pushout.glue PUnit'.unit

/-- Alternative basepoint via right injection. -/
noncomputable def basepoint_path_inr :
    Path (basepoint : Wedge A B a₀ b₀) (inr b₀) := glue

end Wedge

/-- The suspension ΣA is the pushout of PUnit' ← A → PUnit'.
It adds a north pole, south pole, and meridian paths. -/
def Suspension (A : Type uu) : Type uu :=
  Pushout PUnit' PUnit' A (fun _ => PUnit'.unit) (fun _ => PUnit'.unit)

namespace Suspension

variable {A : Type uu}

/-- North pole of the suspension. -/
noncomputable def north : Suspension A := Pushout.inl PUnit'.unit

/-- South pole of the suspension. -/
noncomputable def south : Suspension A := Pushout.inr PUnit'.unit

/-- Meridian path from north to south, parameterized by a : A. -/
noncomputable def merid (a : A) : Path (north : Suspension A) south :=
  Pushout.glue a

end Suspension

end SpecialCases

/-! ## Connectedness -/

/-- A type is path-connected if any two points are connected by a path. -/
def IsPathConnected (A : Type u) : Prop :=
  ∀ a b : A, Nonempty (Path a b)

/-- A type is pointed if it has a distinguished basepoint. -/
structure Pointed (A : Type u) where
  basepoint : A

/-- A pointed connected type. -/
structure PointedConnected (A : Type u) extends Pointed A where
  connected : IsPathConnected A

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-- Explicitly: inl(a) is connected to inl(f c) via A's connectivity. -/
noncomputable def inl_to_hub (a : A) (c : C) (hA : IsPathConnected A) :
    Path (inl a : Pushout A B C f g) (inl (f c)) :=
  inlPath (Classical.choice (hA a (f c)))

/-- Explicitly: inr(b) is connected to inl(f c) via B's connectivity and glue. -/
noncomputable def inr_to_hub (b : B) (c : C) (hB : IsPathConnected B) :
    Path (inr b : Pushout A B C f g) (inl (f c)) :=
  Path.trans (inrPath (Classical.choice (hB b (g c)))) (glueInv c)

/-- Every point in the pushout is connected to inl(f c) for any c : C.

This is provable for the quotient pushout by reducing to the `Sum A B`
representative of `x`. -/
theorem path_to_hub {c : C} (hA : IsPathConnected A) (hB : IsPathConnected B)
    (x : Pushout A B C f g) : Nonempty (Path x (inl (f c))) := by
  refine Quot.inductionOn x ?_
  intro s
  cases s with
  | inl a =>
      exact ⟨inl_to_hub (A := A) (B := B) (C := C) (f := f) (g := g) a c hA⟩
  | inr b =>
      exact ⟨inr_to_hub (A := A) (B := B) (C := C) (f := f) (g := g) b c hB⟩

/-- If C is nonempty, then the pushout is path-connected when A, B, C are. -/
theorem isPathConnected_of_components
    (hA : IsPathConnected A)
    (hB : IsPathConnected B)
    (hC : Nonempty C) :
    IsPathConnected (Pushout A B C f g) := by
  intro x y
  -- Pick a hub point via C's nonemptiness
  obtain ⟨c⟩ := hC
  -- Both x and y are connected to the hub inl(f c)
  obtain ⟨px⟩ := path_to_hub (c := c) hA hB x
  obtain ⟨py⟩ := path_to_hub (c := c) hA hB y
  -- Compose: x → hub → y
  exact ⟨Path.trans px (Path.symm py)⟩

end Pushout

end Path
end ComputationalPaths
