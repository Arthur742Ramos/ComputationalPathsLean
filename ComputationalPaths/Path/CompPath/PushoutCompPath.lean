import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.RwEq
import ComputationalPaths.Path.Basic

/-
# Pushout via computational path expressions

Defines a pushout type as a quotient of `Sum A B` together with a syntax tree
of path expressions generated by `glue`, `inlPath`, and `inrPath`.  Path
expressions are quotiented by rewrite equality of their interpreted paths.

## Key Results

- `PushoutCompPath`: quotient pushout of a span `A ← C → B`.
- `PushoutCompPathExpr`: syntax trees for paths in the pushout.
- `PushoutCompPathExprQuot`: quotient of expressions by path rewrite equality.

## References

- Computational paths framework (explicit path expressions).
-/

namespace ComputationalPaths
namespace Path
namespace CompPath

universe u

/-- Unit type at any universe level (for wedge/suspension constructions). -/
inductive PUnit' : Type u where
  | unit : PUnit'

noncomputable instance : Inhabited PUnit' := ⟨PUnit'.unit⟩

noncomputable instance : Subsingleton PUnit' where
  allEq := by
    intro a b
    cases a <;> cases b <;> rfl

/-- A type is path-connected if all its points are path-connected to a basepoint.
    Note: Must be Type-valued to hold data (the basepoint), not Prop. -/
class IsPathConnected (A : Type u) : Type u where
  base : A
  connected : ∀ (x : A), Path base x

namespace IsPathConnected

variable {A : Type u} [h : IsPathConnected A]

/-- Connect any two points in a path-connected space. -/
noncomputable def connect (x y : A) : Path x y :=
  Path.trans (Path.symm (IsPathConnected.connected x)) (IsPathConnected.connected y)

end IsPathConnected

/-! ## Pushout type -/

/-- Relation generating the pushout quotient: identify `inl (f c)` with
`inr (g c)` for each `c : C`. -/
inductive PushoutCompPathRel (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Sum A B → Sum A B → Prop
  | glue (c : C) : PushoutCompPathRel A B C f g (Sum.inl (f c)) (Sum.inr (g c))

/-- Pushout of a span `A ← C → B` as a quotient of `Sum A B`. -/
noncomputable def PushoutCompPath (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Type u :=
  Quot (PushoutCompPathRel A B C f g)

namespace PushoutCompPath

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-! ## Point constructors -/

/-- Left injection into the pushout. -/
noncomputable def inl (a : A) : PushoutCompPath A B C f g :=
  Quot.mk _ (Sum.inl a)

/-- Right injection into the pushout. -/
noncomputable def inr (b : B) : PushoutCompPath A B C f g :=
  Quot.mk _ (Sum.inr b)

/-! ## Glue path -/

/-- The gluing path: `inl (f c)` is identified with `inr (g c)`. -/
noncomputable def glue (c : C) : Path (inl (f c) : PushoutCompPath A B C f g) (inr (g c)) :=
  Path.stepChain <|
    Quot.sound (PushoutCompPathRel.glue (A := A) (B := B) (C := C) (f := f) (g := g) c)

/-- Inverse of the gluing path. -/
noncomputable def glueInv (c : C) : Path (inr (g c) : PushoutCompPath A B C f g) (inl (f c)) :=
  Path.symm (glue (A := A) (B := B) (C := C) (f := f) (g := g) c)

/-! ## Path expressions -/

/-- Path expressions for the computational pushout.

These are syntax trees generated by:
- `glue` for crossing the span,
- `inlPath`/`inrPath` for internal paths,
- `refl`, `symm`, `trans` for groupoid structure.
-/
inductive PushoutCompPathExpr (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) :
    PushoutCompPath A B C f g → PushoutCompPath A B C f g → Type u
  | glue (c : C) :
      PushoutCompPathExpr A B C f g (inl (f c)) (inr (g c))
  | inlPath {a a' : A} (p : Path a a') :
      PushoutCompPathExpr A B C f g (inl a) (inl a')
  | inrPath {b b' : B} (p : Path b b') :
      PushoutCompPathExpr A B C f g (inr b) (inr b')
  | refl (x : PushoutCompPath A B C f g) :
      PushoutCompPathExpr A B C f g x x
  | symm {x y : PushoutCompPath A B C f g}
      (p : PushoutCompPathExpr A B C f g x y) :
      PushoutCompPathExpr A B C f g y x
  | trans {x y z : PushoutCompPath A B C f g}
      (p : PushoutCompPathExpr A B C f g x y)
      (q : PushoutCompPathExpr A B C f g y z) :
      PushoutCompPathExpr A B C f g x z

/-- Interpret a path expression as a computational path. -/
noncomputable def exprToPath {x y : PushoutCompPath A B C f g} :
    PushoutCompPathExpr A B C f g x y → Path x y
  | PushoutCompPathExpr.glue c => glue (A := A) (B := B) (C := C) (f := f) (g := g) c
  | PushoutCompPathExpr.inlPath p => Path.congrArg (inl (A := A) (B := B) (C := C) (f := f) (g := g)) p
  | PushoutCompPathExpr.inrPath p => Path.congrArg (inr (A := A) (B := B) (C := C) (f := f) (g := g)) p
  | PushoutCompPathExpr.refl x => Path.refl x
  | PushoutCompPathExpr.symm p => Path.symm (exprToPath p)
  | PushoutCompPathExpr.trans p q => Path.trans (exprToPath p) (exprToPath q)

/-! ## Provenance steps -/

/-- A provenance-aware step in the pushout.

`inlStep` and `inrStep` record paths coming from `A` and `B`, while
`glueStep`/`glueStepInv` record the generating gluing identifications. -/
inductive PushoutStep (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) :
    PushoutCompPath A B C f g → PushoutCompPath A B C f g → Type u
  | inlStep {a a' : A} (p : Path a a') :
      PushoutStep A B C f g (inl (A := A) (B := B) (C := C) (f := f) (g := g) a)
        (inl (A := A) (B := B) (C := C) (f := f) (g := g) a')
  | inrStep {b b' : B} (p : Path b b') :
      PushoutStep A B C f g (inr (A := A) (B := B) (C := C) (f := f) (g := g) b)
        (inr (A := A) (B := B) (C := C) (f := f) (g := g) b')
  | glueStep (c : C) :
      PushoutStep A B C f g
        (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c))
        (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c))
  | glueStepInv (c : C) :
      PushoutStep A B C f g
        (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c))
        (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c))

namespace PushoutStep

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-- Reverse the direction of a pushout step. -/
@[simp] noncomputable def symm {x y : PushoutCompPath A B C f g} :
    PushoutStep A B C f g x y → PushoutStep A B C f g y x
  | inlStep p => inlStep (Path.symm p)
  | inrStep p => inrStep (Path.symm p)
  | glueStep c => glueStepInv (A := A) (B := B) (C := C) (f := f) (g := g) c
  | glueStepInv c => glueStep (A := A) (B := B) (C := C) (f := f) (g := g) c

/-- Interpret a pushout step as a computational path. -/
noncomputable def toPath {x y : PushoutCompPath A B C f g} :
    PushoutStep A B C f g x y → Path x y
  | inlStep p =>
      Path.congrArg
        (inl (A := A) (B := B) (C := C) (f := f) (g := g)) p
  | inrStep p =>
      Path.congrArg
        (inr (A := A) (B := B) (C := C) (f := f) (g := g)) p
  | glueStep c => glue (A := A) (B := B) (C := C) (f := f) (g := g) c
  | glueStepInv c => glueInv (A := A) (B := B) (C := C) (f := f) (g := g) c

end PushoutStep

/-- A chained list of provenance-aware pushout steps. -/
inductive PushoutPath (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) :
    PushoutCompPath A B C f g → PushoutCompPath A B C f g → Type u
  | refl (x : PushoutCompPath A B C f g) :
      PushoutPath A B C f g x x
  | cons {x y z : PushoutCompPath A B C f g}
      (s : PushoutStep A B C f g x y)
      (rest : PushoutPath A B C f g y z) :
      PushoutPath A B C f g x z

namespace PushoutPath

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-- Forget provenance and interpret a `PushoutPath` as a `Path`. -/
noncomputable def toPath {x y : PushoutCompPath A B C f g} :
    PushoutPath A B C f g x y → Path x y
  | refl x => Path.refl x
  | cons s rest => Path.trans (PushoutStep.toPath (A := A) (B := B) (C := C) (f := f) (g := g) s)
      (toPath rest)

end PushoutPath

/-! ## Expression quotient -/

/-- Two expressions are equivalent if their interpreted paths are rewrite-equal. -/
noncomputable def exprRel {x y : PushoutCompPath A B C f g}
    (p q : PushoutCompPathExpr A B C f g x y) : Prop :=
  RwEqProp (exprToPath (A := A) (B := B) (C := C) (f := f) (g := g) p)
    (exprToPath (A := A) (B := B) (C := C) (f := f) (g := g) q)

@[simp] theorem exprRel_refl {x y : PushoutCompPath A B C f g}
    (p : PushoutCompPathExpr A B C f g x y) : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p p :=
  by
    let t := exprToPath (A := A) (B := B) (C := C) (f := f) (g := g) p
    refine ⟨?_⟩
    change RwEq t t
    exact rweq_trans (rweq_symm (rweq_cmpA_refl_right t)) (rweq_cmpA_refl_right t)

@[simp] theorem exprRel_symm {x y : PushoutCompPath A B C f g}
    {p q : PushoutCompPathExpr A B C f g x y}
    (h : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p q) :
    exprRel (A := A) (B := B) (C := C) (f := f) (g := g) q p :=
  let ⟨h'⟩ := h; ⟨rweq_symm h'⟩

@[simp] theorem exprRel_trans {x y : PushoutCompPath A B C f g}
    {p q r : PushoutCompPathExpr A B C f g x y}
    (h₁ : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p q)
    (h₂ : exprRel (A := A) (B := B) (C := C) (f := f) (g := g) q r) :
    exprRel (A := A) (B := B) (C := C) (f := f) (g := g) p r :=
  let ⟨h₁'⟩ := h₁; let ⟨h₂'⟩ := h₂; ⟨rweq_trans h₁' h₂'⟩

/-- Setoid on pushout path expressions. -/
noncomputable def exprSetoid (x y : PushoutCompPath A B C f g) :
    Setoid (PushoutCompPathExpr A B C f g x y) where
  r := exprRel (A := A) (B := B) (C := C) (f := f) (g := g)
  iseqv := by
    refine ⟨?refl, ?symm, ?trans⟩
    · intro p
      exact exprRel_refl (A := A) (B := B) (C := C) (f := f) (g := g) p
    · intro p q h
      exact exprRel_symm (A := A) (B := B) (C := C) (f := f) (g := g) h
    · intro p q r h₁ h₂
      exact exprRel_trans (A := A) (B := B) (C := C) (f := f) (g := g) h₁ h₂

/-- Quotient of path expressions by rewrite equality. -/
abbrev PushoutCompPathExprQuot (x y : PushoutCompPath A B C f g) : Type u :=
  Quot (exprSetoid (A := A) (B := B) (C := C) (f := f) (g := g) x y).r

/-- Embed an expression into the quotient. -/
noncomputable def exprClass {x y : PushoutCompPath A B C f g}
    (p : PushoutCompPathExpr A B C f g x y) : PushoutCompPathExprQuot (A := A) (B := B) (C := C)
      (f := f) (g := g) x y :=
  Quot.mk _ p

/-! ## Summary -/

end PushoutCompPath

/-! ## Compatibility aliases -/

/-- Alias for the computational pushout, matching the legacy name. -/
abbrev Pushout (A : Type u) (B : Type u) (C : Type u)
    (f : C → A) (g : C → B) : Type u :=
  PushoutCompPath A B C f g

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}

/-- Alias for the left injection. -/
noncomputable def inl (a : A) : Pushout A B C f g :=
  PushoutCompPath.inl (A := A) (B := B) (C := C) (f := f) (g := g) a

/-- Alias for the right injection. -/
noncomputable def inr (b : B) : Pushout A B C f g :=
  PushoutCompPath.inr (A := A) (B := B) (C := C) (f := f) (g := g) b

/-- Alias for the gluing path. -/
noncomputable def glue (c : C) : Path (inl (A := A) (B := B) (C := C) (f := f) (g := g) (f c))
    (inr (A := A) (B := B) (C := C) (f := f) (g := g) (g c)) :=
  PushoutCompPath.glue (A := A) (B := B) (C := C) (f := f) (g := g) c

/-- Alias for the left-path constructor. -/
noncomputable def inlPath {a a' : A} (p : Path a a') :
    Path (inl (A := A) (B := B) (C := C) (f := f) (g := g) a)
      (inl (A := A) (B := B) (C := C) (f := f) (g := g) a') :=
  Path.congrArg (inl (A := A) (B := B) (C := C) (f := f) (g := g)) p

/-- Alias for the right-path constructor. -/
noncomputable def inrPath {b b' : B} (p : Path b b') :
    Path (inr (A := A) (B := B) (C := C) (f := f) (g := g) b)
      (inr (A := A) (B := B) (C := C) (f := f) (g := g) b') :=
  Path.congrArg (inr (A := A) (B := B) (C := C) (f := f) (g := g)) p

end Pushout

/-- Alias for the wedge sum (pushout of unit). -/
abbrev Wedge (A : Type u) (B : Type u) (a₀ : A) (b₀ : B) : Type u :=
  Pushout A B PUnit' (fun _ => a₀) (fun _ => b₀)

namespace Pushout

variable {A : Type u} {B : Type u} {C : Type u}
variable {f : C → A} {g : C → B}
variable (c₀ : C)

/-- Naturality condition for loops in the pushout.
    This class asserts that certain rewrite equalities hold between glue paths.
    It is needed for the Seifert-Van Kampen theorem proof. -/
class HasGlueNaturalLoopRwEq : Prop where
   eq : ∀ (c : C) (p : Path c₀ c),
      RwEqProp (trans (symm (inlPath (congrArg f p))) (trans (glue c₀) (inrPath (congrArg g p))))
        (glue c)

end Pushout

namespace Wedge

variable {A : Type u} {B : Type u}
variable {a₀ : A} {b₀ : B}

noncomputable def inl (a : A) : Wedge A B a₀ b₀ :=
  Pushout.inl (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) a

noncomputable def inr (b : B) : Wedge A B a₀ b₀ :=
  Pushout.inr (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) b

noncomputable def wedgeBasepoint : Wedge A B a₀ b₀ :=
  inl (A := A) (B := B) (a₀ := a₀) (b₀ := b₀) a₀

noncomputable def glue : Path (inl (A := A) (B := B) (a₀ := a₀) (b₀ := b₀) a₀)
    (inr (A := A) (B := B) (a₀ := a₀) (b₀ := b₀) b₀) :=
  Pushout.glue (A := A) (B := B) (C := PUnit') (f := fun _ => a₀) (g := fun _ => b₀) PUnit'.unit

end Wedge

/-! ## Instance: HasGlueNaturalLoopRwEq for wedge sums -/

/-- For wedge sums where C = PUnit', the glue naturality condition holds trivially
because all paths in PUnit' are rewrite-equivalent to refl, and congrArg along
constant functions collapses to refl. -/
noncomputable instance instHasGlueNaturalLoopRwEq_Wedge {A : Type u} {B : Type u} (a₀ : A) (b₀ : B) :
    Pushout.HasGlueNaturalLoopRwEq (A := A) (B := B) (C := PUnit')
      (f := fun _ => a₀) (g := fun _ => b₀) PUnit'.unit where
  eq := fun c p => by
    -- Since PUnit' is a subsingleton, c = PUnit'.unit = c₀
    cases c
    -- Abbreviations for the pushout type parameters
    let f' : PUnit' → A := fun _ => a₀
    let g' : PUnit' → B := fun _ => b₀
    -- The goal is:
    -- RwEq (trans (symm (inlPath (congrArg f' p)))
    --             (trans (glue PUnit'.unit) (inrPath (congrArg g' p))))
    --      (glue PUnit'.unit)
    -- Since f' and g' are constant, congrArg f' p ≈ refl and congrArg g' p ≈ refl
    have h1 : RwEq (Path.congrArg f' p) (Path.refl a₀) := rweq_congrArg_const a₀ p
    have h2 : RwEq (Path.congrArg g' p) (Path.refl b₀) := rweq_congrArg_const b₀ p
    -- inlPath and inrPath are just congrArg
    let inl' := Pushout.inl (A := A) (B := B) (C := PUnit') (f := f') (g := g')
    let inr' := Pushout.inr (A := A) (B := B) (C := PUnit') (f := f') (g := g')
    let glue' := Pushout.glue (A := A) (B := B) (C := PUnit') (f := f') (g := g') PUnit'.unit
    -- inlPath (congrArg f' p) ≈ inlPath (refl a₀) = refl (inl' a₀)
    have hinl : RwEq (Pushout.inlPath (A := A) (B := B) (C := PUnit') (f := f') (g := g')
                        (congrArg f' p))
                     (Path.refl (inl' a₀)) := by
      apply rweq_trans (rweq_congrArg_of_rweq inl' h1)
      refine rweq_trans (rweq_congrArg_refl inl' a₀) ?_
      let t := Path.refl (inl' a₀)
      change RwEq t t
      exact rweq_trans (rweq_symm (rweq_cmpA_refl_right t)) (rweq_cmpA_refl_right t)
    -- inrPath (congrArg g' p) ≈ inrPath (refl b₀) = refl (inr' b₀)
    have hinr : RwEq (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := f') (g := g')
                        (congrArg g' p))
                     (Path.refl (inr' b₀)) := by
      apply rweq_trans (rweq_congrArg_of_rweq inr' h2)
      refine rweq_trans (rweq_congrArg_refl inr' b₀) ?_
      let t := Path.refl (inr' b₀)
      change RwEq t t
      exact rweq_trans (rweq_symm (rweq_cmpA_refl_right t)) (rweq_cmpA_refl_right t)
    -- symm (inlPath ...) ≈ symm refl ≈ refl
    have hsymm : RwEq (Path.symm (Pushout.inlPath (A := A) (B := B) (C := PUnit') (f := f') (g := g')
                          (congrArg f' p)))
                      (Path.refl (inl' a₀)) := by
      apply rweq_trans (rweq_symm_congr hinl)
      exact rweq_sr _
    -- Now the LHS becomes: trans refl (trans glue' refl)
    -- Step 1: simplify inner trans glue' (inrPath ...) ≈ glue'
    have hmid : RwEq (Path.trans glue'
                        (Pushout.inrPath (A := A) (B := B) (C := PUnit') (f := f') (g := g')
                          (congrArg g' p)))
                     glue' := by
      apply rweq_trans (rweq_trans_congr_right glue' hinr)
      exact rweq_cmpA_refl_right glue'
    -- Step 2: Transform the full expression
    exact ⟨rweq_trans (rweq_trans_congr_left _ hsymm)
      (rweq_trans (rweq_cmpA_refl_left _) hmid)⟩

/-! ## Legacy notation -/

/-- Legacy-style basepoint for wedge sums. -/
@[simp] noncomputable def Wedge.basepoint {A : Type u} {B : Type u} {a₀ : A} {b₀ : B} : Wedge A B a₀ b₀ :=
  Wedge.wedgeBasepoint (A := A) (B := B) (a₀ := a₀) (b₀ := b₀)
end CompPath
end Path
end ComputationalPaths
