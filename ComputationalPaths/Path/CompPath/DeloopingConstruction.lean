/-
# Delooping construction for strict groups

This module constructs a delooping `BG` for a strict group `G` in the
computational-paths setting.  The space `BG` is a one-point type, while its
loop space is presented by explicit loop expressions labelled by elements of
`G`.  Quotienting those expressions by evaluation recovers `G`.

## Key Results

- `BG`: the delooping space of a strict group
- `DeloopingOmega`: loop expressions modulo evaluation
- `deloopingOmegaEquiv`: `DeloopingOmega` is equivalent to `G`

## References

- HoTT Book, Chapter 6 (classifying spaces)
- de Queiroz et al., SAJL 2016 (computational paths)
-/

import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.SimpleEquiv
import ComputationalPaths.Path.Algebra.GroupStructures

namespace ComputationalPaths
namespace Path
namespace CompPath

open Algebra

universe u

/-! ## The delooping space -/

/-- The delooping `BG` of a group as a one-point type. -/
inductive Delooping (G : Type u) : Type u
  | base : Delooping G

/-- Basepoint of the delooping space. -/
@[simp] def deloopingBase (G : Type u) : Delooping G :=
  Delooping.base

/-- Alias for the delooping space `BG`. -/
abbrev BG (G : Type u) : Type u := Delooping G

/-! ## Loop expressions -/

/-- Loop expressions for the delooping space, generated by group elements. -/
inductive DeloopingExpr (G : Type u) : Type u
  | loop (g : G) : DeloopingExpr G
  | refl : DeloopingExpr G
  | symm (p : DeloopingExpr G) : DeloopingExpr G
  | trans (p q : DeloopingExpr G) : DeloopingExpr G

/-- Loop expressions based at the delooping basepoint. -/
abbrev DeloopingLoopExpr (G : Type u) : Type u :=
  DeloopingExpr G

section Eval

variable {G : Type u} (S : StrictGroup G)

/-- Evaluate a loop expression into the strict group. -/
@[simp] def deloopingExprEval : DeloopingLoopExpr G → G
  | DeloopingExpr.loop g => g
  | DeloopingExpr.refl => S.one
  | DeloopingExpr.symm p => S.inv (deloopingExprEval p)
  | DeloopingExpr.trans p q => S.mul (deloopingExprEval p) (deloopingExprEval q)

end Eval

/-! ## Loop quotient -/

section Quotient

variable {G : Type u} (S : StrictGroup G)

/-- Two loop expressions are equivalent when they evaluate to the same element. -/
def DeloopingRel (p q : DeloopingLoopExpr G) : Prop :=
  deloopingExprEval (S := S) p = deloopingExprEval (S := S) q

/-- Setoid of loop expressions modulo evaluation. -/
def deloopingSetoid : Setoid (DeloopingLoopExpr G) where
  r := DeloopingRel (S := S)
  iseqv := by
    refine ⟨?refl, ?symm, ?trans⟩
    · intro p
      rfl
    · intro p q hpq
      exact hpq.symm
    · intro p q r hpq hqr
      exact hpq.trans hqr

/-- The loop space `Omega(BG)` presented as a quotient of expressions. -/
abbrev DeloopingOmega : Type u :=
  Quot (deloopingSetoid (S := S)).r

/-- Alias `Omega(BG)` for the delooping loop quotient. -/
abbrev OmegaBG (S : StrictGroup G) : Type u :=
  DeloopingOmega (S := S)

/-- Encode a loop class as a group element. -/
@[simp] noncomputable def deloopingOmegaEncode :
    DeloopingOmega (S := S) → G :=
  Quot.lift (deloopingExprEval (S := S)) (by
    intro p q hpq
    exact hpq)

/-- Decode a group element as a loop class. -/
@[simp] def deloopingOmegaDecode :
    G → DeloopingOmega (S := S) :=
  fun g => Quot.mk _ (DeloopingExpr.loop g)

/-- Encoding after decoding is the identity on the group. -/
@[simp] theorem deloopingOmegaEncodeDecode (g : G) :
    deloopingOmegaEncode (S := S) (deloopingOmegaDecode (S := S) g) = g := by
  simp [deloopingOmegaEncode, deloopingOmegaDecode]

/-- Decoding after encoding is the identity on loop classes. -/
theorem deloopingOmegaDecodeEncode (x : DeloopingOmega (S := S)) :
    deloopingOmegaDecode (S := S) (deloopingOmegaEncode (S := S) x) = x := by
  refine Quot.inductionOn x ?_
  intro p
  apply Quot.sound
  change deloopingExprEval (S := S)
      (DeloopingExpr.loop (deloopingExprEval (S := S) p)) =
    deloopingExprEval (S := S) p
  simp [deloopingExprEval]

/-- `Omega(BG)` is equivalent to the underlying group. -/
noncomputable def deloopingOmegaEquiv :
    SimpleEquiv (DeloopingOmega (S := S)) G where
  toFun := deloopingOmegaEncode (S := S)
  invFun := deloopingOmegaDecode (S := S)
  left_inv := deloopingOmegaDecodeEncode (S := S)
  right_inv := deloopingOmegaEncodeDecode (S := S)

end Quotient

/-! ## Summary -/

end CompPath
end Path
end ComputationalPaths
