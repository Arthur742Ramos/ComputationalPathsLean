/-
# Rewriting system on computational paths

This module captures the fragment of the `rw`-rewrite system from the paper
concerned with symmetry and transitivity.  We provide the basic rewrite steps
and the reflexive/transitive closure `Rw`, together with its symmetric
reflexive/transitive closure `RwEq`.
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths.Path

universe u

/-- A single rewrite step between computational paths. -/
inductive Step {A : Type u} : {a b : A} → Path a b → Path a b → Prop
  | symm_refl (a : A) :
      Step (a := a) (b := a) (symm (Path.refl a)) (Path.refl a)
  | symm_symm {a b : A} (p : Path a b) :
      Step (symm (symm p)) p
  | trans_refl_left {a b : A} (p : Path a b) :
      Step (trans (Path.refl a) p) p
  | trans_refl_right {a b : A} (p : Path a b) :
      Step (trans p (Path.refl b)) p
  | trans_symm {a b : A} (p : Path a b) :
      Step (trans p (symm p)) (Path.refl a)
  | symm_trans {a b : A} (p : Path a b) :
      Step (trans (symm p) p) (Path.refl b)
  | symm_trans_congr {a b c : A} (p : Path a b) (q : Path b c) :
      Step (symm (trans p q)) (trans (symm q) (symm p))
  | trans_assoc {a b c d : A} (p : Path a b) (q : Path b c) (r : Path c d) :
      Step (trans (trans p q) r) (trans p (trans q r))

attribute [simp] Step.symm_refl Step.symm_symm Step.trans_refl_left
  Step.trans_refl_right Step.trans_symm Step.symm_trans Step.symm_trans_congr
  Step.trans_assoc

/-- Reflexive/transitive closure of rewrite steps (`rw`-reduction). -/
inductive Rw {A : Type u} {a b : A} : Path a b → Path a b → Prop
  | refl (p : Path a b) : Rw p p
  | tail {p q r : Path a b} : Rw p q → Step (a := a) (b := b) q r → Rw p r

variable {A : Type u} {a b c : A}

@[simp] theorem rw_refl (p : Path a b) : Rw p p :=
  Rw.refl p

theorem rw_of_step {p q : Path a b} (h : Step (a := a) (b := b) p q) : Rw p q :=
  Rw.tail (Rw.refl p) h

@[simp] theorem rw_symm_trans_congr {p : Path a b} {q : Path b c} :
    Rw (symm (trans p q)) (trans (symm q) (symm p)) :=
  rw_of_step (Step.symm_trans_congr p q)

/-- Helper used to prove transitivity of `Rw`. -/
def Rw.comp {p q : Path a b} (h₁ : Rw p q) : ∀ {r : Path a b}, Rw q r → Rw p r
  | _, Rw.refl _ => h₁
  | _, Rw.tail h₂ step => Rw.tail (Rw.comp h₁ h₂) step

@[simp] theorem rw_trans {p q r : Path a b} (h₁ : Rw p q) (h₂ : Rw q r) : Rw p r :=
  Rw.comp h₁ h₂

/-- Symmetric reflexive/transitive closure generated by rewrite steps. -/
inductive RwEq {A : Type u} {a b : A} : Path a b → Path a b → Prop
  | refl (p : Path a b) : RwEq p p
  | step {p q : Path a b} : Step (a := a) (b := b) p q → RwEq p q
  | symm {p q : Path a b} : RwEq p q → RwEq q p
  | trans {p q r : Path a b} : RwEq p q → RwEq q r → RwEq p r

@[simp] theorem rweq_refl (p : Path a b) : RwEq p p :=
  RwEq.refl p

theorem rweq_of_step {p q : Path a b} (h : Step (a := a) (b := b) p q) : RwEq p q :=
  RwEq.step h

@[simp] theorem rweq_symm {p q : Path a b} (h : RwEq p q) : RwEq q p :=
  match h with
  | RwEq.refl _ => RwEq.refl _
  | RwEq.step h => RwEq.symm (RwEq.step h)
  | RwEq.symm h => h
  | RwEq.trans h₁ h₂ => RwEq.trans (rweq_symm h₂) (rweq_symm h₁)

@[simp] theorem rweq_trans {p q r : Path a b} (h₁ : RwEq p q) (h₂ : RwEq q r) : RwEq p r :=
  RwEq.trans h₁ h₂

@[simp] theorem rweq_of_rw {p q : Path a b} (h : Rw p q) : RwEq p q :=
  match h with
  | Rw.refl _ => RwEq.refl _
  | Rw.tail h step => RwEq.trans (rweq_of_rw h) (RwEq.step step)

@[simp] theorem rw_congr_rweq {p q r : Path a b} (hpq : Rw p q) (hqr : RwEq q r) : RwEq p r :=
  rweq_trans (rweq_of_rw hpq) hqr

@[simp] theorem rweq_congr_rw {p q r : Path a b} (hpq : RwEq p q) (hqr : Rw q r) : RwEq p r :=
  rweq_trans hpq (rweq_of_rw hqr)

@[simp] theorem rweq_symm_trans_congr {p : Path a b} {q : Path b c} :
    RwEq (symm (trans p q)) (trans (symm q) (symm p)) :=
  rweq_of_rw (rw_symm_trans_congr (p := p) (q := q))

end ComputationalPaths.Path
