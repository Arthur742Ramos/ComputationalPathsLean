/-
# Rewriting system on computational paths

This module captures the fragment of the `rw`-rewrite system from the paper
concerned with symmetry and transitivity.  We provide the basic rewrite steps
and the reflexive/transitive closure `Rw`, together with its symmetric
reflexive/transitive closure `RwEq`.
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths.Path

universe u v w

/-- A single rewrite step between computational paths. -/
inductive Step {A : Type u} : {a b : A} → Path a b → Path a b → Prop
  | symm_refl (a : A) :
      Step (a := a) (b := a) (symm (Path.refl a)) (Path.refl a)
  | symm_symm {a b : A} (p : Path a b) :
      Step (symm (symm p)) p
  | trans_refl_left {a b : A} (p : Path a b) :
      Step (trans (Path.refl a) p) p
  | trans_refl_right {a b : A} (p : Path a b) :
      Step (trans p (Path.refl b)) p
  | trans_symm {a b : A} (p : Path a b) :
      Step (trans p (symm p)) (Path.refl a)
  | symm_trans {a b : A} (p : Path a b) :
      Step (trans (symm p) p) (Path.refl b)
  | symm_trans_congr {a b c : A} (p : Path a b) (q : Path b c) :
      Step (symm (trans p q)) (trans (symm q) (symm p))
  | trans_assoc {a b c d : A} (p : Path a b) (q : Path b c) (r : Path c d) :
      Step (trans (trans p q) r) (trans p (trans q r))

attribute [simp] Step.symm_refl Step.symm_symm Step.trans_refl_left
  Step.trans_refl_right Step.trans_symm Step.symm_trans Step.symm_trans_congr
  Step.trans_assoc

/-- Reflexive/transitive closure of rewrite steps (`rw`-reduction). -/
inductive Rw {A : Type u} {a b : A} : Path a b → Path a b → Prop
  | refl (p : Path a b) : Rw p p
  | tail {p q r : Path a b} : Rw p q → Step (a := a) (b := b) q r → Rw p r

variable {A : Type u} {a b c : A}

@[simp] theorem rw_refl (p : Path a b) : Rw p p :=
  Rw.refl p

theorem rw_of_step {p q : Path a b} (h : Step (a := a) (b := b) p q) : Rw p q :=
  Rw.tail (Rw.refl p) h

@[simp] theorem rw_symm_trans_congr {p : Path a b} {q : Path b c} :
    Rw (symm (trans p q)) (trans (symm q) (symm p)) :=
  rw_of_step (Step.symm_trans_congr p q)

@[simp] theorem rw_of_eq {p q : Path a b} (h : p = q) : Rw p q := by
  cases h
  exact rw_refl _

@[simp] theorem rw_congrArg_trans {B : Type v}
    {a b c : A} (f : A → B) (p : Path a b) (q : Path b c) :
    Rw (Path.congrArg f (Path.trans p q))
      (Path.trans (Path.congrArg f p) (Path.congrArg f q)) :=
  rw_of_eq (Path.congrArg_trans (f := f) (p := p) (q := q))

@[simp] theorem rw_congrArg_symm {B : Type v}
    {a b : A} (f : A → B) (p : Path a b) :
    Rw (Path.congrArg f (Path.symm p))
      (Path.symm (Path.congrArg f p)) :=
  rw_of_eq (Path.congrArg_symm (f := f) (p := p))

@[simp] theorem rw_mapLeft_trans {B : Type v} {C : Type w}
    {a₁ a₂ a₃ : A} (f : A → B → C)
    (p : Path a₁ a₂) (q : Path a₂ a₃) (b : B) :
    Rw (Path.mapLeft f (Path.trans p q) b)
      (Path.trans (Path.mapLeft f p b) (Path.mapLeft f q b)) :=
  rw_of_eq (Path.mapLeft_trans (f := f) (p := p) (q := q) (b := b))

@[simp] theorem rw_mapLeft_symm {B : Type v} {C : Type w}
    {a₁ a₂ : A} (f : A → B → C)
    (p : Path a₁ a₂) (b : B) :
    Rw (Path.mapLeft f (Path.symm p) b)
      (Path.symm (Path.mapLeft f p b)) :=
  rw_of_eq (Path.mapLeft_symm (f := f) (p := p) (b := b))

@[simp] theorem rw_mapRight_trans {B : Type v} {C : Type w}
    {b₁ b₂ b₃ : B} (f : A → B → C)
    (a : A) (p : Path b₁ b₂) (q : Path b₂ b₃) :
    Rw (Path.mapRight f a (Path.trans p q))
      (Path.trans (Path.mapRight f a p) (Path.mapRight f a q)) :=
  rw_of_eq (Path.mapRight_trans (f := f) (a := a) (p := p) (q := q))

@[simp] theorem rw_mapRight_symm {B : Type v} {C : Type w}
    {b₁ b₂ : B} (f : A → B → C)
    (a : A) (p : Path b₁ b₂) :
    Rw (Path.mapRight f a (Path.symm p))
      (Path.symm (Path.mapRight f a p)) :=
  rw_of_eq (Path.mapRight_symm (f := f) (a := a) (p := p))

/-- Helper used to prove transitivity of `Rw`. -/
def Rw.comp {p q : Path a b} (h₁ : Rw p q) : ∀ {r : Path a b}, Rw q r → Rw p r
  | _, Rw.refl _ => h₁
  | _, Rw.tail h₂ step => Rw.tail (Rw.comp h₁ h₂) step

@[simp] theorem rw_trans {p q r : Path a b} (h₁ : Rw p q) (h₂ : Rw q r) : Rw p r :=
  Rw.comp h₁ h₂

/-- Symmetric reflexive/transitive closure generated by rewrite steps. -/
inductive RwEq {A : Type u} {a b : A} : Path a b → Path a b → Prop
  | refl (p : Path a b) : RwEq p p
  | step {p q : Path a b} : Step (a := a) (b := b) p q → RwEq p q
  | symm {p q : Path a b} : RwEq p q → RwEq q p
  | trans {p q r : Path a b} : RwEq p q → RwEq q r → RwEq p r

@[simp] theorem rweq_refl (p : Path a b) : RwEq p p :=
  RwEq.refl p

theorem rweq_of_step {p q : Path a b} (h : Step (a := a) (b := b) p q) : RwEq p q :=
  RwEq.step h

@[simp] theorem rweq_symm {p q : Path a b} (h : RwEq p q) : RwEq q p :=
  match h with
  | RwEq.refl _ => RwEq.refl _
  | RwEq.step h => RwEq.symm (RwEq.step h)
  | RwEq.symm h => h
  | RwEq.trans h₁ h₂ => RwEq.trans (rweq_symm h₂) (rweq_symm h₁)

@[simp] theorem rweq_trans {p q r : Path a b} (h₁ : RwEq p q) (h₂ : RwEq q r) : RwEq p r :=
  RwEq.trans h₁ h₂

@[simp] theorem rweq_of_eq {p q : Path a b} (h : p = q) : RwEq p q := by
  cases h
  exact RwEq.refl _

@[simp] theorem rweq_congrArg_trans {B : Type v}
    {a b c : A} (f : A → B) (p : Path a b) (q : Path b c) :
    RwEq (Path.congrArg f (Path.trans p q))
      (Path.trans (Path.congrArg f p) (Path.congrArg f q)) :=
  rweq_of_eq (Path.congrArg_trans (f := f) (p := p) (q := q))

@[simp] theorem rweq_congrArg_symm {B : Type v}
    {a b : A} (f : A → B) (p : Path a b) :
    RwEq (Path.congrArg f (Path.symm p))
      (Path.symm (Path.congrArg f p)) :=
  rweq_of_eq (Path.congrArg_symm (f := f) (p := p))

@[simp] theorem rweq_mapLeft_trans {B : Type v} {C : Type w}
    {a₁ a₂ a₃ : A} (f : A → B → C)
    (p : Path a₁ a₂) (q : Path a₂ a₃) (b : B) :
    RwEq (Path.mapLeft f (Path.trans p q) b)
      (Path.trans (Path.mapLeft f p b) (Path.mapLeft f q b)) :=
  rweq_of_eq (Path.mapLeft_trans (f := f) (p := p) (q := q) (b := b))

@[simp] theorem rweq_mapLeft_symm {B : Type v} {C : Type w}
    {a₁ a₂ : A} (f : A → B → C)
    (p : Path a₁ a₂) (b : B) :
    RwEq (Path.mapLeft f (Path.symm p) b)
      (Path.symm (Path.mapLeft f p b)) :=
  rweq_of_eq (Path.mapLeft_symm (f := f) (p := p) (b := b))

@[simp] theorem rweq_mapRight_trans {B : Type v} {C : Type w}
    {b₁ b₂ b₃ : B} (f : A → B → C)
    (a : A) (p : Path b₁ b₂) (q : Path b₂ b₃) :
    RwEq (Path.mapRight f a (Path.trans p q))
      (Path.trans (Path.mapRight f a p) (Path.mapRight f a q)) :=
  rweq_of_eq (Path.mapRight_trans (f := f) (a := a) (p := p) (q := q))

@[simp] theorem rweq_mapRight_symm {B : Type v} {C : Type w}
    {b₁ b₂ : B} (f : A → B → C)
    (a : A) (p : Path b₁ b₂) :
    RwEq (Path.mapRight f a (Path.symm p))
      (Path.symm (Path.mapRight f a p)) :=
  rweq_of_eq (Path.mapRight_symm (f := f) (a := a) (p := p))

@[simp] theorem rweq_of_rw {p q : Path a b} (h : Rw p q) : RwEq p q :=
  match h with
  | Rw.refl _ => RwEq.refl _
  | Rw.tail h step => RwEq.trans (rweq_of_rw h) (RwEq.step step)

@[simp] theorem rw_congr_rweq {p q r : Path a b} (hpq : Rw p q) (hqr : RwEq q r) : RwEq p r :=
  rweq_trans (rweq_of_rw hpq) hqr

@[simp] theorem rweq_congr_rw {p q r : Path a b} (hpq : RwEq p q) (hqr : Rw q r) : RwEq p r :=
  rweq_trans hpq (rweq_of_rw hqr)

@[simp] theorem rweq_symm_trans_congr {p : Path a b} {q : Path b c} :
    RwEq (symm (trans p q)) (trans (symm q) (symm p)) :=
  rweq_of_rw (rw_symm_trans_congr (p := p) (q := q))

end ComputationalPaths.Path
