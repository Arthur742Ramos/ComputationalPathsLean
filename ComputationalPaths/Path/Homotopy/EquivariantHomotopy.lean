/-
# Equivariant Homotopy Theory

Lightweight definitions:
- G-spaces for strict group actions
- equivariant maps/equivalences
- fixed points
- Borel construction as a quotient

All proofs are complete.
-/

import ComputationalPaths.Path.EquivariantPaths
import ComputationalPaths.Path.Algebra.GroupStructures

namespace ComputationalPaths
namespace Path
namespace Homotopy
namespace EquivariantHomotopy

open Algebra

universe u

/-- A G-space: a type with a strict group action. -/
structure GSpace (G : Type u) (S : StrictGroup G) where
  carrier : Type u
  action : GroupAction G S carrier

/-- Equivariant map. -/
structure GMap {G : Type u} {S : StrictGroup G} (X Y : GSpace G S) where
  toFun : X.carrier → Y.carrier
  equivariant : ∀ g x, toFun (X.action.act g x) = Y.action.act g (toFun x)

/-- Fixed points X^G. -/
def FixedPoints {G : Type u} {S : StrictGroup G} (X : GSpace G S) : Type u :=
  { x : X.carrier // ∀ g : G, X.action.act g x = x }

/-- Extensionality for fixed points by underlying points. -/
theorem fixedPoints_ext {G : Type u} {S : StrictGroup G} {X : GSpace G S}
    (x y : FixedPoints X) (h : x.1 = y.1) : x = y := by
  sorry

/-- The group identity acts trivially on fixed points. -/
theorem fixedPoints_act_one {G : Type u} {S : StrictGroup G} {X : GSpace G S}
    (x : FixedPoints X) : X.action.act S.one x.1 = x.1 := by
  sorry

/-- Multiplication in G still acts trivially on fixed points. -/
theorem fixedPoints_act_mul {G : Type u} {S : StrictGroup G} {X : GSpace G S}
    (x : FixedPoints X) (g h : G) : X.action.act (S.mul g h) x.1 = x.1 := by
  sorry

/-- Restriction of an equivariant map to fixed points. -/
def GMap.onFixedPoints {G : Type u} {S : StrictGroup G} {X Y : GSpace G S}
    (f : GMap X Y) : FixedPoints X → FixedPoints Y
  | ⟨x, hx⟩ => ⟨f.toFun x, fun g => by rw [← f.equivariant, hx g]⟩

/-- Underlying value of `onFixedPoints` is `toFun` on the underlying point. -/
theorem GMap.onFixedPoints_val {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (f : GMap X Y) (x : FixedPoints X) :
    (f.onFixedPoints x).1 = f.toFun x.1 := by
  sorry

/-- The image of a fixed point is fixed. -/
theorem GMap.onFixedPoints_fixed {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (f : GMap X Y) (x : FixedPoints X) (g : G) :
    Y.action.act g (f.onFixedPoints x).1 = (f.onFixedPoints x).1 := by
  sorry

/-- Equivariance specialized at the group identity. -/
theorem GMap.equivariant_one {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (f : GMap X Y) (x : X.carrier) :
    f.toFun (X.action.act S.one x) = f.toFun x := by
  sorry

/-- Equivariance specialized at a product in the acting group. -/
theorem GMap.equivariant_mul {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (f : GMap X Y) (g h : G) (x : X.carrier) :
    f.toFun (X.action.act (S.mul g h) x) =
      Y.action.act g (Y.action.act h (f.toFun x)) := by
  sorry

/-- Borel data: EG as a contractible G-space. -/
structure BorelData (G : Type u) (S : StrictGroup G) where
  eg : GSpace G S
  contractible : ∀ x y : eg.carrier, x = y

/-- The Borel construction EG ×_G X as a quotient by the diagonal action relation. -/
def BorelSpace {G : Type u} {S : StrictGroup G}
    (bd : BorelData G S) (X : GSpace G S) : Type u :=
  Quot (fun (p q : bd.eg.carrier × X.carrier) =>
    ∃ g : G, bd.eg.action.act g p.1 = q.1 ∧ X.action.act g p.2 = q.2)

/-- Map into the Borel quotient. -/
def BorelSpace.mk {G : Type u} {S : StrictGroup G}
    (bd : BorelData G S) (X : GSpace G S) :
    bd.eg.carrier × X.carrier → BorelSpace bd X :=
  fun p => Quot.mk _ p

/-- Soundness lemma for the Borel quotient. -/
theorem BorelSpace.sound {G : Type u} {S : StrictGroup G}
    (bd : BorelData G S) (X : GSpace G S)
    (p : bd.eg.carrier × X.carrier) (g : G) :
    BorelSpace.mk bd X p =
      BorelSpace.mk bd X (bd.eg.action.act g p.1, X.action.act g p.2) :=
  Quot.sound ⟨g, rfl, rfl⟩

/-- Borel quotient respects relations generated by multiplication in `G`. -/
theorem BorelSpace.sound_mul {G : Type u} {S : StrictGroup G}
    (bd : BorelData G S) (X : GSpace G S)
    (p : bd.eg.carrier × X.carrier) (g h : G) :
    BorelSpace.mk bd X p =
      BorelSpace.mk bd X
        (bd.eg.action.act (S.mul g h) p.1, X.action.act (S.mul g h) p.2) := by
  sorry

/-- Any witness of the diagonal-action relation yields equality in the quotient. -/
theorem BorelSpace.mk_eq_of_rel {G : Type u} {S : StrictGroup G}
    (bd : BorelData G S) (X : GSpace G S)
    (p q : bd.eg.carrier × X.carrier)
    (hrel : ∃ g : G, bd.eg.action.act g p.1 = q.1 ∧ X.action.act g p.2 = q.2) :
    BorelSpace.mk bd X p = BorelSpace.mk bd X q := by
  sorry

/-- Symmetric form of `BorelSpace.sound` for one action step. -/
theorem BorelSpace.sound_symm {G : Type u} {S : StrictGroup G}
    (bd : BorelData G S) (X : GSpace G S)
    (p : bd.eg.carrier × X.carrier) (g : G) :
    BorelSpace.mk bd X (bd.eg.action.act g p.1, X.action.act g p.2) =
      BorelSpace.mk bd X p := by
  sorry

/-- Equivariant equivalence (strict inverse on points). -/
structure GEquiv {G : Type u} {S : StrictGroup G} (X Y : GSpace G S) where
  toFun : GMap X Y
  invFun : GMap Y X
  right_inv : ∀ y, toFun.toFun (invFun.toFun y) = y
  left_inv : ∀ x, invFun.toFun (toFun.toFun x) = x

/-- Left inverse law for the underlying point maps. -/
theorem GEquiv.left_inv_apply {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (e : GEquiv X Y) (x : X.carrier) :
    e.invFun.toFun (e.toFun.toFun x) = x := by
  sorry

/-- Right inverse law for the underlying point maps. -/
theorem GEquiv.right_inv_apply {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (e : GEquiv X Y) (y : Y.carrier) :
    e.toFun.toFun (e.invFun.toFun y) = y := by
  sorry

/-- Left inverse law after restricting to fixed points. -/
theorem GEquiv.onFixedPoints_left_inv {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (e : GEquiv X Y) (x : FixedPoints X) :
    (e.invFun.onFixedPoints (e.toFun.onFixedPoints x)).1 = x.1 := by
  sorry

/-- Right inverse law after restricting to fixed points. -/
theorem GEquiv.onFixedPoints_right_inv {G : Type u} {S : StrictGroup G}
    {X Y : GSpace G S} (e : GEquiv X Y) (y : FixedPoints Y) :
    (e.toFun.onFixedPoints (e.invFun.onFixedPoints y)).1 = y.1 := by
  sorry

end EquivariantHomotopy
end Homotopy
end Path
end ComputationalPaths
