/-
# Free Groupoid on the Computational Path Graph

Defines the free groupoid generated by computational paths, shows that
`PathRwQuot` is the free groupoid on the Step graph, proves the universal
property and functoriality.

All proofs use the explicit `Path.trans`, `Path.symm`, `Path.refl`,
`Step`, and `RwEq` constructors from the core library.
-/

import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.RwEq
import ComputationalPaths.Path.Rewrite.Quot
namespace ComputationalPaths.Path.Algebra

open ComputationalPaths
open ComputationalPaths.Path

universe u v w

noncomputable section

/-! ## Groupoid and Functor interfaces -/

/-- Minimal groupoid interface for free-groupoid constructions. -/
structure CPGroupoid where
  Obj : Type u
  Hom : Obj → Obj → Type v
  id : (a : Obj) → Hom a a
  comp : {a b c : Obj} → Hom a b → Hom b c → Hom a c
  inv : {a b : Obj} → Hom a b → Hom b a
  comp_assoc :
    ∀ {a b c d : Obj} (f : Hom a b) (g : Hom b c) (h : Hom c d),
      comp (comp f g) h = comp f (comp g h)
  id_comp : ∀ {a b : Obj} (f : Hom a b), comp (id a) f = f
  comp_id : ∀ {a b : Obj} (f : Hom a b), comp f (id b) = f
  inv_comp : ∀ {a b : Obj} (f : Hom a b), comp (inv f) f = id b
  comp_inv : ∀ {a b : Obj} (f : Hom a b), comp f (inv f) = id a

/-- Functor between `CPGroupoid`s. -/
structure CPFunctor (G H : CPGroupoid) where
  obj : G.Obj → H.Obj
  map : {a b : G.Obj} → G.Hom a b → H.Hom (obj a) (obj b)
  map_id : ∀ a, map (G.id a) = H.id (obj a)
  map_comp :
    ∀ {a b c : G.Obj} (f : G.Hom a b) (g : G.Hom b c),
      map (G.comp f g) = H.comp (map f) (map g)

/-! ## Free groupoid laws from Step constructors -/

section FreeGroupoidLaws

variable {A : Type u}

/-- Left identity via `Step.trans_refl_left`. -/
theorem free_id_comp {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans (PathRwQuot.refl a) x = x := by
  refine Quot.inductionOn x (fun p => ?_)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_refl_left p)))

/-- Right identity via `Step.trans_refl_right`. -/
theorem free_comp_id {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans x (PathRwQuot.refl b) = x := by
  refine Quot.inductionOn x (fun p => ?_)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_refl_right p)))

/-- Associativity via `Step.trans_assoc`. -/
theorem free_comp_assoc {a b c d : A}
    (x : PathRwQuot A a b) (y : PathRwQuot A b c) (z : PathRwQuot A c d) :
    PathRwQuot.trans (PathRwQuot.trans x y) z =
      PathRwQuot.trans x (PathRwQuot.trans y z) := by
  refine Quot.inductionOn x (fun p => ?_)
  refine Quot.inductionOn y (fun q => ?_)
  refine Quot.inductionOn z (fun r => ?_)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_assoc p q r)))

/-- Left inverse via `Step.symm_trans`. -/
theorem free_inv_comp {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans (PathRwQuot.symm x) x = PathRwQuot.refl b := by
  refine Quot.inductionOn x (fun p => ?_)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.symm_trans p)))

/-- Right inverse via `Step.trans_symm`. -/
theorem free_comp_inv {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans x (PathRwQuot.symm x) = PathRwQuot.refl a := by
  refine Quot.inductionOn x (fun p => ?_)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_symm p)))

end FreeGroupoidLaws

/-! ## The Free Groupoid -/

/-- Free groupoid on the computational-path graph of `A`:
objects are vertices, morphisms are paths modulo `RwEq`. -/
noncomputable def FreeGroupoid (A : Type u) : CPGroupoid where
  Obj := A
  Hom := fun a b => PathRwQuot A a b
  id := fun a => PathRwQuot.refl a
  comp := fun x y => PathRwQuot.trans x y
  inv := fun x => PathRwQuot.symm x
  comp_assoc := fun x y z => free_comp_assoc x y z
  id_comp := fun x => free_id_comp x
  comp_id := fun x => free_comp_id x
  inv_comp := fun x => free_inv_comp x
  comp_inv := fun x => free_comp_inv x

/-- Raw paths embed as morphisms in the free groupoid. -/
noncomputable def ofPath {A : Type u} {a b : A} (p : Path a b) :
    (FreeGroupoid A).Hom a b :=
  Quot.mk _ p

/-- Every `Step` yields equality of morphisms in the free groupoid. -/
theorem ofPath_eq_of_step {A : Type u} {a b : A}
    {p q : Path a b} (h : Step p q) :
    ofPath p = ofPath (A := A) q :=
  Quot.sound (rweqProp_of_rweq (RwEq.step h))

/-- Every `RwEq` class maps to a single morphism. -/
theorem ofPath_eq_of_rweq {A : Type u} {a b : A}
    {p q : Path a b} (h : RwEq p q) :
    ofPath p = ofPath (A := A) q :=
  Quot.sound (rweqProp_of_rweq h)

/-! ## Universal Property -/

/-- Graph morphism from Step-graph of `A` into a target groupoid.
    A compatible assignment of paths to groupoid morphisms. -/
structure StepGraphMorphism (A : Type u) (G : CPGroupoid.{v, w}) where
  obj : A → G.Obj
  onPath : {a b : A} → Path a b → G.Hom (obj a) (obj b)
  onRefl : ∀ a, onPath (Path.refl a) = G.id (obj a)
  onTrans : ∀ {a b c : A} (p : Path a b) (q : Path b c),
      onPath (Path.trans p q) = G.comp (onPath p) (onPath q)
  onSymm : ∀ {a b : A} (p : Path a b),
      onPath (Path.symm p) = G.inv (onPath p)
  onStep : ∀ {a b : A} {p q : Path a b}, Step p q → onPath p = onPath q

namespace StepGraphMorphism

variable {A : Type u} {G : CPGroupoid.{v, w}}

/-- A Step-graph morphism respects the full `RwEq` closure. -/
theorem onRwEq (F : StepGraphMorphism A G)
    {a b : A} {p q : Path a b} (h : RwEq p q) :
    F.onPath p = F.onPath q := by
  induction h with
  | refl _ => rfl
  | step hStep => exact F.onStep hStep
  | symm _ ih => exact ih.symm
  | trans _ _ ih₁ ih₂ => exact ih₁.trans ih₂

/-- Canonical factorization through the quotient. -/
noncomputable def factorHom (F : StepGraphMorphism A G) {a b : A} :
    PathRwQuot A a b → G.Hom (F.obj a) (F.obj b) :=
  Quot.lift F.onPath (fun p q h => F.onRwEq (rweq_of_rweqProp h))

@[simp] theorem factorHom_mk (F : StepGraphMorphism A G)
    {a b : A} (p : Path a b) :
    F.factorHom (Quot.mk _ p) = F.onPath p := rfl

/-- The factorization as a groupoid functor from `FreeGroupoid A`. -/
noncomputable def factorFunctor (F : StepGraphMorphism A G) :
    CPFunctor (FreeGroupoid A) G where
  obj := F.obj
  map := fun x => F.factorHom x
  map_id := by
    intro a
    show F.factorHom (Quot.mk _ (Path.refl a)) = G.id (F.obj a)
    exact F.onRefl a
  map_comp := by
    intro a b c x y
    refine Quot.inductionOn x (fun p => ?_)
    refine Quot.inductionOn y (fun q => ?_)
    show F.onPath (Path.trans p q) = G.comp (F.onPath p) (F.onPath q)
    exact F.onTrans p q

/-- Uniqueness: any lift agreeing on raw paths equals `factorHom`. -/
theorem factorHom_unique (F : StepGraphMorphism A G)
    (φ : {a b : A} → PathRwQuot A a b → G.Hom (F.obj a) (F.obj b))
    (hφ : ∀ {a b : A} (p : Path a b), φ (Quot.mk _ p) = F.onPath p)
    {a b : A} (x : PathRwQuot A a b) :
    φ x = F.factorHom x := by
  refine Quot.inductionOn x (fun p => ?_)
  simp [hφ]

/-- Universal property: `factorFunctor` is the unique factorization. -/
theorem universal_property (F : StepGraphMorphism A G) :
    -- Existence: factorFunctor agrees with F on raw paths
    (∀ {a b : A} (p : Path a b),
      F.factorFunctor.map (ofPath p) = F.onPath p) ∧
    -- Uniqueness: any other lift agreeing on raw paths agrees everywhere
    (∀ (lift : {a b : A} → (FreeGroupoid A).Hom a b → G.Hom (F.obj a) (F.obj b)),
      (∀ {a b : A} (p : Path a b), lift (ofPath p) = F.onPath p) →
      ∀ {a b : A} (x : (FreeGroupoid A).Hom a b), lift x = F.factorFunctor.map x) := by
  constructor
  · intro a b p; rfl
  · intro lift hlift a b x
    refine Quot.inductionOn x (fun p => ?_)
    exact hlift p

end StepGraphMorphism

/-! ## Functoriality -/

/-- A function `f : A → B` induces a groupoid functor `FreeGroupoid A → FreeGroupoid B`
    via `Path.congrArg`. -/
noncomputable def FreeGroupoid.map {A B : Type u} (f : A → B) :
    CPFunctor (FreeGroupoid A) (FreeGroupoid B) where
  obj := f
  map := fun {a b} x =>
    Quot.lift
      (fun p => Quot.mk _ (Path.congrArg f p))
      (fun p q h =>
        Quot.sound (rweqProp_of_rweq (rweq_congrArg_of_rweq f (rweq_of_rweqProp h))))
      x
  map_id := by
    intro a
    rfl
  map_comp := by
    intro a b c x y
    refine Quot.inductionOn x (fun p => ?_)
    refine Quot.inductionOn y (fun q => ?_)
    show Quot.mk _ (Path.congrArg f (Path.trans p q)) =
      PathRwQuot.trans (Quot.mk _ (Path.congrArg f p)) (Quot.mk _ (Path.congrArg f q))
    exact Quot.sound (rweqProp_of_rweq (rweq_of_eq (Path.congrArg_trans f p q)))

/-- `FreeGroupoid.map` preserves identity functions. -/
theorem FreeGroupoid.map_id_eq {A : Type u} {a b : A} (x : (FreeGroupoid A).Hom a b) :
    (FreeGroupoid.map (id : A → A)).map x = x := by
  refine Quot.inductionOn x (fun p => ?_)
  show Quot.mk _ (Path.congrArg id p) = Quot.mk _ p
  exact Quot.sound (rweqProp_of_rweq (rweq_of_eq (Path.congrArg_id p)))

/-- `FreeGroupoid.map` preserves composition of functions. -/
theorem FreeGroupoid.map_comp_eq {A B C : Type u} (f : A → B) (g : B → C)
    {a b : A} (x : (FreeGroupoid A).Hom a b) :
    (FreeGroupoid.map g).map ((FreeGroupoid.map f).map x) =
      (FreeGroupoid.map (g ∘ f)).map x := by
  refine Quot.inductionOn x (fun p => ?_)
  show Quot.mk _ (Path.congrArg g (Path.congrArg f p)) =
    Quot.mk _ (Path.congrArg (g ∘ f) p)
  exact Quot.sound (rweqProp_of_rweq (rweq_symm (rweq_of_eq (Path.congrArg_comp g f p))))

end

end ComputationalPaths.Path.Algebra
