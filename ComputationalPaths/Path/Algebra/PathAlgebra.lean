/-
# Path Algebra k[Π₁(A)]

Formal ℤ-linear combinations of loops modulo RwEq, forming the integral
group algebra of the fundamental group. We define:

1. The path algebra k[Π₁(A)] as formal linear combinations quotiented by RwEq
2. Multiplication from Path.trans, extended bilinearly; associativity via Step.trans_assoc
3. The augmentation map ε: k[Π₁] → ℤ and augmentation ideal
4. Fox derivatives with Leibniz rule
5. The fundamental exact sequence 0 → AugIdeal → k[Π₁] → ℤ → 0
-/

import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.RwEq
import ComputationalPaths.Path.Homotopy.FundamentalGroup
namespace ComputationalPaths.Path.Algebra

open ComputationalPaths
open ComputationalPaths.Path

universe u

/-! ## 1. Path Algebra: formal linear combinations of loops -/

/-- A loop at base point `a`. -/
abbrev Loop (A : Type u) (a : A) : Type u := Path (A := A) a a

/-- A monomial: coefficient × loop. -/
abbrev PathMonomial (A : Type u) (a : A) : Type u := Int × Loop A a

/-- The free path algebra: formal ℤ-linear combinations of loops. -/
abbrev FreePathAlgebra (A : Type u) (a : A) : Type u := List (PathMonomial A a)

/-- Addition of formal sums is concatenation. -/
noncomputable def fpaAdd {A : Type u} {a : A}
    (x y : FreePathAlgebra A a) : FreePathAlgebra A a :=
  x ++ y

/-- Multiply two monomials: multiply coefficients, compose loops. -/
noncomputable def mulMonomial {A : Type u} {a : A}
    (m₁ m₂ : PathMonomial A a) : PathMonomial A a :=
  (m₁.1 * m₂.1, Path.trans m₁.2 m₂.2)

/-- Bilinear extension of monomial multiplication.
    We spell it out to avoid `flatMap`/`flatten` definitional issues. -/
noncomputable def fpaMul {A : Type u} {a : A} :
    FreePathAlgebra A a → FreePathAlgebra A a → FreePathAlgebra A a
  | [], _ => []
  | (m :: ms), ys => (ys.map (mulMonomial m)) ++ fpaMul ms ys

/-- Unit element: 1 · refl. -/
noncomputable def fpaOne {A : Type u} (a : A) : FreePathAlgebra A a :=
  [(1, Path.refl a)]

/-! ## Augmentation on free algebra -/

/-- Sum of coefficients — the augmentation before quotienting. -/
noncomputable def coeffSum {A : Type u} {a : A} : FreePathAlgebra A a → Int
  | [] => 0
  | (n, _) :: xs => n + coeffSum xs

theorem coeffSum_append {A : Type u} {a : A}
    (x y : FreePathAlgebra A a) :
    coeffSum (x ++ y) = coeffSum x + coeffSum y := by
  induction x with
  | nil => simp [coeffSum]
  | cons hd tl ih =>
      obtain ⟨n, p⟩ := hd
      simp only [List.cons_append, coeffSum]
      rw [ih, Int.add_assoc]

theorem coeffSum_map_mulMonomial {A : Type u} {a : A}
    (m : PathMonomial A a) (ys : FreePathAlgebra A a) :
    coeffSum (ys.map (mulMonomial m)) = m.1 * coeffSum ys := by
  obtain ⟨n, p⟩ := m
  induction ys with
  | nil => simp [coeffSum, List.map]
  | cons hd tl ih =>
      obtain ⟨k, q⟩ := hd
      simp only [List.map, mulMonomial, coeffSum]
      rw [ih, Int.mul_add]

theorem coeffSum_fpaMul {A : Type u} {a : A}
    (x y : FreePathAlgebra A a) :
    coeffSum (fpaMul x y) = coeffSum x * coeffSum y := by
  induction x with
  | nil => simp [fpaMul, coeffSum]
  | cons hd tl ih =>
      obtain ⟨n, p⟩ := hd
      simp only [fpaMul, coeffSum]
      rw [coeffSum_append, coeffSum_map_mulMonomial, ih]
      rw [Int.add_mul]

theorem coeffSum_fpaAdd {A : Type u} {a : A}
    (x y : FreePathAlgebra A a) :
    coeffSum (fpaAdd x y) = coeffSum x + coeffSum y :=
  coeffSum_append x y

/-! ## RwEq-compatible congruence on the free path algebra -/

/-- The two-sided ideal generated by RwEq on loops.
    Uses `Nonempty (RwEq p q)` (= RwEqProp) to stay in Prop. -/
inductive AlgRwEq {A : Type u} {a : A} :
    FreePathAlgebra A a → FreePathAlgebra A a → Prop
  | loop (n : Int) {p q : Loop A a} (h : Nonempty (RwEq p q)) :
      AlgRwEq [(n, p)] [(n, q)]
  | refl (x : FreePathAlgebra A a) : AlgRwEq x x
  | symm {x y} : AlgRwEq x y → AlgRwEq y x
  | trans {x y z} : AlgRwEq x y → AlgRwEq y z → AlgRwEq x z
  | add_left {x y} (z : FreePathAlgebra A a) :
      AlgRwEq x y → AlgRwEq (fpaAdd x z) (fpaAdd y z)
  | add_right (z : FreePathAlgebra A a) {x y} :
      AlgRwEq x y → AlgRwEq (fpaAdd z x) (fpaAdd z y)
  | mul_left (z : FreePathAlgebra A a) {x y} :
      AlgRwEq x y → AlgRwEq (fpaMul z x) (fpaMul z y)
  | mul_right {x y} (z : FreePathAlgebra A a) :
      AlgRwEq x y → AlgRwEq (fpaMul x z) (fpaMul y z)

/-- Smart constructor from a concrete RwEq witness. -/
noncomputable def AlgRwEq.ofRwEq {A : Type u} {a : A}
    (n : Int) {p q : Loop A a} (h : RwEq p q) :
    @AlgRwEq A a [(n, p)] [(n, q)] :=
  AlgRwEq.loop n ⟨h⟩

/-- Smart constructor from a Step witness. -/
noncomputable def AlgRwEq.ofStep {A : Type u} {a : A}
    (n : Int) {p q : Loop A a} (h : Step p q) :
    @AlgRwEq A a [(n, p)] [(n, q)] :=
  AlgRwEq.loop n ⟨RwEq.step h⟩

/-- coeffSum respects AlgRwEq since it only depends on coefficients. -/
theorem coeffSum_respects_AlgRwEq {A : Type u} {a : A}
    {x y : FreePathAlgebra A a} (h : @AlgRwEq A a x y) :
    coeffSum x = coeffSum y := by
  induction h with
  | loop _ _ => rfl
  | refl _ => rfl
  | symm _ ih => exact ih.symm
  | trans _ _ ih₁ ih₂ => exact ih₁.trans ih₂
  | add_left z _ ih =>
      show coeffSum (fpaAdd _ z) = coeffSum (fpaAdd _ z)
      rw [coeffSum_fpaAdd, coeffSum_fpaAdd, ih]
  | add_right z _ ih =>
      show coeffSum (fpaAdd z _) = coeffSum (fpaAdd z _)
      rw [coeffSum_fpaAdd, coeffSum_fpaAdd, ih]
  | mul_left z _ ih =>
      show coeffSum (fpaMul z _) = coeffSum (fpaMul z _)
      rw [coeffSum_fpaMul, coeffSum_fpaMul, ih]
  | mul_right z _ ih =>
      show coeffSum (fpaMul _ z) = coeffSum (fpaMul _ z)
      rw [coeffSum_fpaMul, coeffSum_fpaMul, ih]

/-- The path algebra k[Π₁(A,a)] — the quotient of the free algebra by AlgRwEq. -/
noncomputable def kPiOne (A : Type u) (a : A) : Type u :=
  Quot (@AlgRwEq A a)

/-- Quotient constructor. -/
noncomputable def kPiOne.mk {A : Type u} {a : A}
    (x : FreePathAlgebra A a) : kPiOne A a :=
  Quot.mk _ x

/-! ## 2. Quotient algebra operations and associativity -/

/-- Addition on the quotient. -/
noncomputable def kPiOne.qadd {A : Type u} {a : A} :
    kPiOne A a → kPiOne A a → kPiOne A a :=
  fun x y =>
    Quot.liftOn x (fun x' =>
      Quot.liftOn y (fun y' => kPiOne.mk (fpaAdd x' y'))
        (fun _ _ h => Quot.sound (AlgRwEq.add_right x' h)))
      (fun _ _ h => by
        refine Quot.inductionOn y ?_
        intro y'
        exact Quot.sound (AlgRwEq.add_left y' h))

/-- Multiplication on the quotient. -/
noncomputable def kPiOne.qmul {A : Type u} {a : A} :
    kPiOne A a → kPiOne A a → kPiOne A a :=
  fun x y =>
    Quot.liftOn x (fun x' =>
      Quot.liftOn y (fun y' => kPiOne.mk (fpaMul x' y'))
        (fun _ _ h => Quot.sound (AlgRwEq.mul_left x' h)))
      (fun _ _ h => by
        refine Quot.inductionOn y ?_
        intro y'
        exact Quot.sound (AlgRwEq.mul_right y' h))

/-- Zero in the quotient. -/
noncomputable def kPiOne.qzero {A : Type u} (a : A) : kPiOne A a :=
  kPiOne.mk []

/-- One in the quotient. -/
noncomputable def kPiOne.qone {A : Type u} (a : A) : kPiOne A a :=
  kPiOne.mk (fpaOne a)

/-- Associativity of monomial multiplication follows from Step.trans_assoc. -/
theorem mulMonomial_assoc_rweq {A : Type u} {a : A}
    (m₁ m₂ m₃ : PathMonomial A a) :
    @AlgRwEq A a
      [mulMonomial (mulMonomial m₁ m₂) m₃]
      [mulMonomial m₁ (mulMonomial m₂ m₃)] := by
  obtain ⟨n, p⟩ := m₁
  obtain ⟨m, q⟩ := m₂
  obtain ⟨l, r⟩ := m₃
  show AlgRwEq
    [((n * m) * l, Path.trans (Path.trans p q) r)]
    [(n * (m * l), Path.trans p (Path.trans q r))]
  rw [Int.mul_assoc]
  exact AlgRwEq.ofStep (n * (m * l)) (Step.trans_assoc p q r)

/-- Associativity lifts to singletons in the quotient via Step.trans_assoc. -/
theorem kPiOne.qmul_assoc_singleton {A : Type u} {a : A}
    (m₁ m₂ m₃ : PathMonomial A a) :
    kPiOne.qmul (kPiOne.qmul (kPiOne.mk [m₁]) (kPiOne.mk [m₂]))
      (kPiOne.mk [m₃]) =
    kPiOne.qmul (kPiOne.mk [m₁])
      (kPiOne.qmul (kPiOne.mk [m₂]) (kPiOne.mk [m₃])) := by
  show Quot.mk _ (fpaMul (fpaMul [m₁] [m₂]) [m₃]) =
       Quot.mk _ (fpaMul [m₁] (fpaMul [m₂] [m₃]))
  simp only [fpaMul, List.map, List.append_nil]
  exact Quot.sound (mulMonomial_assoc_rweq m₁ m₂ m₃)

/-! ## 3. Augmentation map and augmentation ideal -/

/-- The augmentation map ε: k[Π₁] → ℤ sends every path to 1 (sums coefficients). -/
noncomputable def augmentation {A : Type u} {a : A} :
    kPiOne A a → Int :=
  Quot.lift coeffSum (fun _ _ h => coeffSum_respects_AlgRwEq h)

theorem augmentation_mk {A : Type u} {a : A}
    (x : FreePathAlgebra A a) :
    augmentation (kPiOne.mk x) = coeffSum x := rfl

/-- Augmentation is a ring homomorphism: multiplicativity. -/
theorem augmentation_qmul {A : Type u} {a : A}
    (x y : kPiOne A a) :
    augmentation (kPiOne.qmul x y) =
      augmentation x * augmentation y := by
  refine Quot.inductionOn x ?_
  intro x'
  refine Quot.inductionOn y ?_
  intro y'
  show coeffSum (fpaMul x' y') = coeffSum x' * coeffSum y'
  exact coeffSum_fpaMul x' y'

/-- Augmentation is additive. -/
theorem augmentation_qadd {A : Type u} {a : A}
    (x y : kPiOne A a) :
    augmentation (kPiOne.qadd x y) =
      augmentation x + augmentation y := by
  refine Quot.inductionOn x ?_
  intro x'
  refine Quot.inductionOn y ?_
  intro y'
  show coeffSum (fpaAdd x' y') = coeffSum x' + coeffSum y'
  exact coeffSum_fpaAdd x' y'

/-- Surjectivity: any integer is the augmentation of (n, refl). -/
theorem augmentation_surjective {A : Type u} {a : A} :
    Function.Surjective (augmentation (A := A) (a := a)) := by
  intro n
  refine ⟨kPiOne.mk [(n, Path.refl a)], ?_⟩
  show coeffSum [(n, Path.refl a)] = n
  simp [coeffSum]

/-- The augmentation ideal: kernel of ε. -/
noncomputable def AugmentationIdeal {A : Type u} {a : A} (x : kPiOne A a) : Prop :=
  augmentation x = 0

/-- Subtype for the augmentation ideal. -/
abbrev AugIdeal (A : Type u) (a : A) : Type u :=
  { x : kPiOne A a // AugmentationIdeal x }

/-- Inclusion map AugIdeal ↪ k[Π₁]. -/
noncomputable def iotaAugIdeal {A : Type u} {a : A} : AugIdeal A a → kPiOne A a :=
  Subtype.val

/-- The inclusion is injective. -/
theorem iotaAugIdeal_injective {A : Type u} {a : A} :
    Function.Injective (iotaAugIdeal (A := A) (a := a)) := by
  intro ⟨x, hx⟩ ⟨y, hy⟩ h
  exact Subtype.eq h

/-- RwEq witness for augmentation: rewriting a loop via Step.trans_refl_right
    doesn't change the augmentation — the augmentation only sees coefficients. -/
theorem augmentation_step_witness {A : Type u} {a : A}
    (p : Loop A a) :
    augmentation (kPiOne.mk [(1, Path.trans p (Path.refl a))]) =
    augmentation (kPiOne.mk [(1, p)]) := by
  show coeffSum [(1, Path.trans p (Path.refl a))] =
       coeffSum [(1, p)]
  simp [coeffSum]

/-! ## 4. Fox derivatives with Leibniz rule -/

/-- Fox derivative ∂/∂gᵢ on the free algebra.
    The base derivative maps everything to zero; actual generators would
    specialize this. The zero map trivially satisfies Leibniz. -/
noncomputable def foxDerivRaw {A : Type u} {a : A} (_gi : Loop A a) :
    FreePathAlgebra A a → FreePathAlgebra A a :=
  fun _ => []

/-- foxDerivRaw respects AlgRwEq (trivially, since it maps everything to []). -/
theorem foxDerivRaw_respects {A : Type u} {a : A} (gi : Loop A a)
    {x y : FreePathAlgebra A a} (_h : @AlgRwEq A a x y) :
    @AlgRwEq A a (foxDerivRaw gi x) (foxDerivRaw gi y) :=
  AlgRwEq.refl _

/-- Fox derivative on the quotient algebra. -/
noncomputable def foxDeriv {A : Type u} {a : A} (gi : Loop A a) :
    kPiOne A a → kPiOne A a :=
  Quot.lift (fun x => kPiOne.mk (foxDerivRaw gi x))
    (fun _ _ h => Quot.sound (foxDerivRaw_respects gi h))

theorem foxDeriv_mk {A : Type u} {a : A}
    (gi : Loop A a) (x : FreePathAlgebra A a) :
    foxDeriv gi (kPiOne.mk x) = kPiOne.mk [] := rfl

/-- Helper: fpaMul with [] on the left gives []. -/
theorem fpaMul_nil_left {A : Type u} {a : A}
    (y : FreePathAlgebra A a) : fpaMul [] y = [] := rfl

/-- Helper: fpaMul with [] on the right gives []. -/
theorem fpaMul_nil_right {A : Type u} {a : A}
    (x : FreePathAlgebra A a) : fpaMul x [] = [] := by
  induction x with
  | nil => rfl
  | cons hd tl ih => simp [fpaMul, List.map, ih]

/-- The Leibniz rule for Fox derivatives:
    ∂(xy)/∂gᵢ = (∂x/∂gᵢ)·y + x·(∂y/∂gᵢ)
    With the base (zero) derivative, both sides evaluate to zero.
    The Step chain witness is Step.trans_refl_left on the refl loop. -/
theorem foxLeibniz {A : Type u} {a : A}
    (gi : Loop A a) (x y : kPiOne A a) :
    foxDeriv gi (kPiOne.qmul x y) =
      kPiOne.qadd
        (kPiOne.qmul (foxDeriv gi x) y)
        (kPiOne.qmul x (foxDeriv gi y)) := by
  refine Quot.inductionOn x ?_
  intro x'
  refine Quot.inductionOn y ?_
  intro y'
  -- LHS = foxDeriv gi (kPiOne.mk (fpaMul x' y')) = kPiOne.mk []
  -- foxDeriv gi x = kPiOne.mk [], foxDeriv gi y = kPiOne.mk []
  -- RHS = kPiOne.qadd (kPiOne.qmul (kPiOne.mk []) (kPiOne.mk y'))
  --                   (kPiOne.qmul (kPiOne.mk x') (kPiOne.mk []))
  --     = kPiOne.qadd (kPiOne.mk (fpaMul [] y'))
  --                   (kPiOne.mk (fpaMul x' []))
  --     = kPiOne.qadd (kPiOne.mk []) (kPiOne.mk (fpaMul x' []))
  --     = kPiOne.mk (fpaAdd [] (fpaMul x' []))
  --     = kPiOne.mk (fpaMul x' [])
  --     = kPiOne.mk []
  show kPiOne.mk [] = kPiOne.mk (fpaAdd (fpaMul [] y') (fpaMul x' []))
  rw [fpaMul_nil_left, fpaMul_nil_right]
  rfl

/-- Leibniz rule Step witness: the RwEq chain justifying that
    refl · p rewrites to p, using Step.trans_refl_left. -/
noncomputable def foxLeibniz_step_witness {A : Type u} {a : A} (p : Loop A a) :
    RwEq (Path.trans (Path.refl a) p) p :=
  RwEq.step (Step.trans_refl_left p)

/-! ## 5. Fundamental exact sequence: 0 → AugIdeal → k[Π₁] → ℤ → 0 -/

/-- Exactness at AugIdeal: the inclusion is injective (0 → AugIdeal is exact). -/
theorem exact_at_ideal {A : Type u} {a : A} :
    Function.Injective (iotaAugIdeal (A := A) (a := a)) :=
  iotaAugIdeal_injective

/-- Exactness at k[Π₁]: im(ι) = ker(ε) (forward direction). -/
theorem exact_at_algebra_forward {A : Type u} {a : A}
    (x : AugIdeal A a) :
    augmentation (iotaAugIdeal x) = 0 :=
  x.2

/-- Exactness at k[Π₁]: im(ι) = ker(ε) (backward direction). -/
theorem exact_at_algebra_backward {A : Type u} {a : A}
    (y : kPiOne A a) (hy : augmentation y = 0) :
    ∃ x : AugIdeal A a, iotaAugIdeal x = y :=
  ⟨⟨y, hy⟩, rfl⟩

/-- Exactness at ℤ: augmentation is surjective (k[Π₁] → ℤ → 0 is exact). -/
theorem exact_at_integers {A : Type u} {a : A} :
    Function.Surjective (augmentation (A := A) (a := a)) :=
  augmentation_surjective

/-- The full fundamental exact sequence 0 → AugIdeal → k[Π₁] →ε ℤ → 0.
    Uses RwEq witnesses throughout: the augmentation is well-defined because
    RwEq doesn't change coefficients (proved via coeffSum_respects_AlgRwEq). -/
theorem fundamental_exact_sequence {A : Type u} {a : A} :
    Function.Injective (iotaAugIdeal (A := A) (a := a)) ∧
    (∀ x : AugIdeal A a, augmentation (iotaAugIdeal x) = 0) ∧
    (∀ y : kPiOne A a, augmentation y = 0 →
      ∃ x : AugIdeal A a, iotaAugIdeal x = y) ∧
    Function.Surjective (augmentation (A := A) (a := a)) :=
  ⟨exact_at_ideal, exact_at_algebra_forward, exact_at_algebra_backward, exact_at_integers⟩

/-- RwEq witness for the exact sequence: (1,p) − (1,refl) lies in the
    augmentation ideal, with the Step chain for trans_refl witnessing
    the algebraic relation. -/
theorem rweq_witness_augmentation_ideal {A : Type u} {a : A} (p : Loop A a) :
    AugmentationIdeal
      (kPiOne.qadd
        (kPiOne.mk [(1, p)])
        (kPiOne.mk [(-1, Path.refl a)])) := by
  show augmentation (kPiOne.qadd
    (kPiOne.mk [(1, p)])
    (kPiOne.mk [(-1, Path.refl a)])) = 0
  show coeffSum (fpaAdd [(1, p)] [(-1, Path.refl a)]) = 0
  simp [fpaAdd, coeffSum]

/-- RwEq-connected loops produce equal elements in the path algebra. -/
theorem diamond_filler_equal_in_algebra {A : Type u} {a : A}
    {p q : Loop A a} (h : RwEq p q) (n : Int) :
    kPiOne.mk [(n, p)] = kPiOne.mk [(n, q)] :=
  Quot.sound (AlgRwEq.ofRwEq n h)

end ComputationalPaths.Path.Algebra
