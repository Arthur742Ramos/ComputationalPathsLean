import ComputationalPaths.Path.Basic
import ComputationalPaths.Path.Rewrite.RwEq
import ComputationalPaths.Path.Algebra.HomologicalAlgebra
import ComputationalPaths.Path.CompPath.CircleStep
import ComputationalPaths.Path.Rewrite.SimpleEquiv
/-!
# Mayer-Vietoris for computational paths

This file adds a computational-path Mayer-Vietoris segment:

* a connecting morphism `δ : H₁(A) → H₀(U∩V)` built from path decomposition;
* the long exact segment
  `H₁(U∩V) → H₁(U) ⊕ H₁(V) → H₁(A) → H₀(U∩V)`;
* exactness witnesses expressed with `Step` and `RwEq`;
* a circle application interface (`S¹` covered by two arcs).
-/

namespace ComputationalPaths.Path.Algebra

open ComputationalPaths
open ComputationalPaths.Path
open ComputationalPaths.Path.CompPath

universe u

noncomputable section

/-! ## Degree-0 homology as path-components -/

/-- Connectedness relation generated by computational paths. -/
def H0Rel {X : Type u} (x y : X) : Prop :=
  Nonempty (Path x y)

/-- Setoid of connected components. -/
def H0Setoid (X : Type u) : Setoid X where
  r := H0Rel
  iseqv :=
    { refl := by
        intro x
        exact ⟨Path.refl x⟩
      symm := by
        intro x y h
        rcases h with ⟨p⟩
        exact ⟨Path.symm p⟩
      trans := by
        intro x y z hxy hyz
        rcases hxy with ⟨p⟩
        rcases hyz with ⟨q⟩
        exact ⟨Path.trans p q⟩ }

/-- `H₀` as quotient by computational path-connectedness. -/
abbrev H0 (X : Type u) : Type u :=
  Quot (H0Setoid X).r

/-- Degree-0 class induced by a map. -/
def mapH0 {X Y : Type u} (f : X → Y) : H0 X → H0 Y :=
  Quot.lift
    (fun x : X => Quot.mk _ (f x))
    (by
      intro x y hxy
      rcases hxy with ⟨p⟩
      exact Quot.sound ⟨Path.congrArg f p⟩)

/-- Degree-1 class induced by a map. -/
def mapH1 {X Y : Type u} (f : X → Y) (x₀ : X) : H1 X x₀ → H1 Y (f x₀) :=
  Quot.lift
    (fun p : Path x₀ x₀ => Quot.mk _ (Path.congrArg f p))
    (by
      intro p q hpq
      rcases hpq with ⟨hpq⟩
      exact Quot.sound ⟨rweq_congrArg_of_rweq (f := f) hpq⟩)

/-! ## Cover data and decomposition witnesses -/

/-- Cover presentation data for `A = U ∪ V` with overlap `UV`. -/
structure CoverData where
  A : Type u
  U : Type u
  V : Type u
  UV : Type u
  iU : U → A
  iV : V → A
  iUVU : UV → U
  iUVV : UV → V
  baseUV : UV
  glue : Path (iU (iUVU baseUV)) (iV (iUVV baseUV))

namespace CoverData

/-- Basepoint in `U` selected from overlap data. -/
def baseU (M : CoverData) : M.U := M.iUVU M.baseUV

/-- Basepoint in `V` selected from overlap data. -/
def baseV (M : CoverData) : M.V := M.iUVV M.baseUV

/-- Basepoint in `A`, taken from the `U`-side of the cover. -/
def baseA (M : CoverData) : M.A := M.iU M.baseU

/-- Transport a loop in `V` to a loop at the `A` basepoint via the glue path. -/
def loopFromV (M : CoverData) (q : Path M.baseV M.baseV) : Path M.baseA M.baseA :=
  Path.trans M.glue (Path.trans (Path.congrArg M.iV q) (Path.symm M.glue))

/-- Combine `U` and `V` loops into an ambient loop in `A`. -/
def mergeLoops (M : CoverData)
    (p : Path M.baseU M.baseU) (q : Path M.baseV M.baseV) :
    Path M.baseA M.baseA :=
  Path.trans (Path.congrArg M.iU p) (M.loopFromV q)

/-- `loopFromV` is compatible with `RwEq` witnesses. -/
def loopFromV_respects {M : CoverData} {q q' : Path M.baseV M.baseV}
    (h : RwEq q q') :
    RwEq (M.loopFromV q) (M.loopFromV q') := by
  have hmap : RwEq (Path.congrArg M.iV q) (Path.congrArg M.iV q') :=
    rweq_congrArg_of_rweq (f := M.iV) h
  have hinter :
      RwEq
        (Path.trans (Path.congrArg M.iV q) (Path.symm M.glue))
        (Path.trans (Path.congrArg M.iV q') (Path.symm M.glue)) :=
    rweq_trans_congr_left (Path.symm M.glue) hmap
  exact rweq_trans_congr_right M.glue hinter

/-- `mergeLoops` is compatible with `RwEq` in both arguments. -/
def mergeLoops_respects {M : CoverData}
    {p p' : Path M.baseU M.baseU} {q q' : Path M.baseV M.baseV}
    (hp : RwEq p p') (hq : RwEq q q') :
    RwEq (M.mergeLoops p q) (M.mergeLoops p' q') := by
  exact rweq_trans_congr
    (rweq_congrArg_of_rweq (f := M.iU) hp)
    (M.loopFromV_respects hq)

end CoverData

/-- Decompose an ambient loop into `U`/`V` pieces with explicit overlap witness. -/
structure LoopDecomposition (M : CoverData) (p : Path M.baseA M.baseA) where
  uLoop : Path M.baseU M.baseU
  vLoop : Path M.baseV M.baseV
  overlapPoint : M.UV
  overlapToBase : Path overlapPoint M.baseUV
  stepWitness : Step p (M.mergeLoops uLoop vLoop)

/-- Convert the decomposition `Step` witness into a one-step `RwEq` witness. -/
def LoopDecomposition.rweqWitness {M : CoverData} {p : Path M.baseA M.baseA}
    (d : LoopDecomposition M p) :
    RwEq p (M.mergeLoops d.uLoop d.vLoop) :=
  RwEq.step d.stepWitness

/-- Mayer-Vietoris witness package: decomposition and overlap boundary step. -/
structure MayerVietorisWitness (M : CoverData) where
  decompose : ∀ p : Path M.baseA M.baseA, LoopDecomposition M p
  overlapBoundaryStep :
    ∀ p : Path M.baseUV M.baseUV,
      Step (M.mergeLoops (Path.congrArg M.iUVU p) (Path.congrArg M.iUVV p))
        (Path.refl M.baseA)

/-! ## Mayer-Vietoris maps -/

/-- `H₁(U) ⊕ H₁(V)` encoded as product. -/
abbrev H1Sum (M : CoverData) : Type u :=
  H1 M.U M.baseU × H1 M.V M.baseV

/-- Left map `H₁(U∩V) → H₁(U) ⊕ H₁(V)`. -/
def iMap (M : CoverData) : H1 M.UV M.baseUV → H1Sum M :=
  fun z => (mapH1 M.iUVU M.baseUV z, mapH1 M.iUVV M.baseUV z)

/-- Middle map `H₁(U) ⊕ H₁(V) → H₁(A)` by path concatenation after embedding. -/
noncomputable def jMap (M : CoverData) : H1Sum M → H1 M.A M.baseA :=
  fun x =>
    Quot.liftOn x.1
      (fun p =>
        Quot.liftOn x.2
          (fun q => Quot.mk _ (M.mergeLoops p q))
          (by
            intro q q' hqq'
            rcases hqq' with ⟨hqq'⟩
            exact Quot.sound ⟨M.mergeLoops_respects
              (hp := rweq_refl (p := p)) (hq := hqq')⟩))
      (by
        intro p p' hpp'
        rcases hpp' with ⟨hpp'⟩
        refine Quot.inductionOn x.2 ?_
        intro q
        exact Quot.sound ⟨M.mergeLoops_respects
          (hp := hpp') (hq := rweq_refl (p := q))⟩)

/-- Connecting morphism `δ : H₁(A) → H₀(U∩V)` from decomposition overlap points. -/
def delta (M : CoverData) (decomp : ∀ p : Path M.baseA M.baseA, LoopDecomposition M p) :
    H1 M.A M.baseA → H0 M.UV :=
  Quot.lift
    (fun p : Path M.baseA M.baseA => Quot.mk _ (decomp p).overlapPoint)
    (by
      intro p q hpq
      let dp := decomp p
      let dq := decomp q
      exact Quot.sound ⟨Path.trans dp.overlapToBase (Path.symm dq.overlapToBase)⟩)

/-- The zero class in `H₁(A)`. -/
def zeroH1 (M : CoverData) : H1 M.A M.baseA :=
  Quot.mk _ (Path.refl M.baseA)

/-- The zero class in `H₀(U∩V)`. -/
def zeroH0 (M : CoverData) : H0 M.UV :=
  Quot.mk _ M.baseUV

/-- Sequence data
`H₁(U∩V) → H₁(U) ⊕ H₁(V) → H₁(A) → H₀(U∩V)`. -/
structure MayerVietorisSequence (M : CoverData) where
  left : H1 M.UV M.baseUV → H1Sum M
  middle : H1Sum M → H1 M.A M.baseA
  right : H1 M.A M.baseA → H0 M.UV

/-- Canonical Mayer-Vietoris sequence induced by witness data. -/
def mayerVietorisSequence (M : CoverData) (W : MayerVietorisWitness M) :
    MayerVietorisSequence M where
  left := iMap M
  middle := jMap M
  right := delta M W.decompose

/-! ## Exactness via `RwEq` witnesses -/

/-- Exactness at `H₁(U) ⊕ H₁(V)`: `j ∘ i = 0` via overlap boundary `Step`. -/
theorem exact_at_pair (M : CoverData) (W : MayerVietorisWitness M)
    (z : H1 M.UV M.baseUV) :
    jMap M (iMap M z) = zeroH1 M := by
  refine Quot.inductionOn z ?_
  intro p
  show Quot.mk _ (M.mergeLoops (Path.congrArg M.iUVU p) (Path.congrArg M.iUVV p)) =
    Quot.mk _ (Path.refl M.baseA)
  exact Quot.sound ⟨RwEq.step (W.overlapBoundaryStep p)⟩

/-- Exactness at `H₁(A)` (forward): elements in `im(j)` map to `0` under `δ`. -/
theorem exact_at_h1_forward (M : CoverData) (W : MayerVietorisWitness M)
    (x : H1Sum M) :
    delta M W.decompose (jMap M x) = zeroH0 M := by
  obtain ⟨x₁, x₂⟩ := x
  refine Quot.inductionOn x₁ ?_
  intro p
  refine Quot.inductionOn x₂ ?_
  intro q
  show Quot.mk _ ((W.decompose (M.mergeLoops p q)).overlapPoint) = Quot.mk _ M.baseUV
  exact Quot.sound ⟨(W.decompose (M.mergeLoops p q)).overlapToBase⟩

/-- Surjectivity of `j` from decomposition witnesses (`Step`/`RwEq`). -/
theorem jMap_surjective (M : CoverData) (W : MayerVietorisWitness M) :
    Function.Surjective (jMap M) := by
  intro α
  refine Quot.inductionOn α ?_
  intro p
  let d := W.decompose p
  refine ⟨(Quot.mk _ d.uLoop, Quot.mk _ d.vLoop), ?_⟩
  show Quot.mk _ (M.mergeLoops d.uLoop d.vLoop) = Quot.mk _ p
  exact Quot.sound ⟨rweq_symm d.rweqWitness⟩

/-- Exactness at `H₁(A)` (backward): kernel of `δ` lies in `im(j)`. -/
theorem exact_at_h1_backward (M : CoverData) (W : MayerVietorisWitness M)
    (α : H1 M.A M.baseA)
    (_hδ : delta M W.decompose α = zeroH0 M) :
    ∃ x : H1Sum M, jMap M x = α :=
  jMap_surjective M W α

/-- Mayer-Vietoris long exact segment with exactness witnesses in `RwEq`. -/
theorem mayerVietoris_long_exact_rwEq (M : CoverData) (W : MayerVietorisWitness M) :
    (∀ z : H1 M.UV M.baseUV, jMap M (iMap M z) = zeroH1 M) ∧
    (∀ x : H1Sum M, delta M W.decompose (jMap M x) = zeroH0 M) ∧
    (∀ α : H1 M.A M.baseA,
      delta M W.decompose α = zeroH0 M → ∃ x : H1Sum M, jMap M x = α) := by
  exact ⟨exact_at_pair M W, exact_at_h1_forward M W, exact_at_h1_backward M W⟩

/-! ## Circle application: two-arc Mayer-Vietoris interface -/

/-- Data of a two-arc cover of the computational circle. -/
structure CircleArcCover where
  U : Type
  V : Type
  UV : Type
  iU : U → Circle
  iV : V → Circle
  iUVU : UV → U
  iUVV : UV → V
  baseUV : UV
  glue : Path (iU (iUVU baseUV)) (iV (iUVV baseUV))

/-- Convert circle cover data into the generic Mayer-Vietoris cover format. -/
def CircleArcCover.toCoverData (C : CircleArcCover) : CoverData where
  A := Circle
  U := C.U
  V := C.V
  UV := C.UV
  iU := C.iU
  iV := C.iV
  iUVU := C.iUVU
  iUVV := C.iUVV
  baseUV := C.baseUV
  glue := C.glue

/-- `H₁(S¹) ≅ ℤ` via Mayer-Vietoris: the two-arc cover reduces
    H₁ to winding numbers by the long exact sequence + contractibility of arcs.

    The bridge `pi1ToCirclePiOne` converts the path-based `π₁(S¹)` quotient
    into the computational circle's winding-number quotient `circlePiOne`,
    completing the chain `H₁ ≃ π₁ ≃ circlePiOne ≃ ℤ`. -/
noncomputable def circleH1EquivInt_viaMayerVietoris
    (C : CircleArcCover)
    (W : MayerVietorisWitness C.toCoverData)
    (pi1Bridge : SimpleEquiv (π₁(Circle, circleBase)) circlePiOne) :
    SimpleEquiv (H1 Circle circleBase) Int := by
  let _les := mayerVietoris_long_exact_rwEq C.toCoverData W
  exact SimpleEquiv.comp (h1EquivPi1 Circle circleBase)
    (SimpleEquiv.comp pi1Bridge CompPath.circlePiOneEquivInt)

end

end ComputationalPaths.Path.Algebra
