/-
# Kazhdan–Lusztig Theory via Computational Paths

This module formalizes Kazhdan–Lusztig theory in the computational paths
framework. We model Coxeter groups, Bruhat order, Hecke algebras,
Kazhdan–Lusztig polynomials, KL basis elements with Path-valued
bar-invariance, category O representations, and the Kazhdan–Lusztig
conjecture (Beilinson–Bernstein theorem).

## Mathematical Background

Kazhdan–Lusztig theory connects representation theory and geometry:

1. **Coxeter groups**: groups generated by reflections with braid relations
2. **Hecke algebras**: deformation of group algebras of Coxeter groups
3. **KL polynomials**: P_{y,w}(q) encode geometric information
4. **KL basis**: self-dual basis {C'_w} of the Hecke algebra
5. **Category O**: highest weight modules for semisimple Lie algebras
6. **KL conjecture**: character multiplicities = KL polynomial values

## Key Results

| Definition/Theorem | Description |
|-------------------|-------------|
| `CoxeterGroup` | Coxeter group with Path-valued braid relations |
| `BruhatOrder` | Bruhat partial order on Coxeter group |
| `HeckeAlgebra` | Hecke algebra H(W,q) |
| `KLPolynomial` | Kazhdan–Lusztig polynomial P_{y,w} |
| `KLBasis` | KL basis element C'_w |
| `BarInvolution` | Bar involution on the Hecke algebra |
| `CategoryOData` | Category O representation data |
| `KLConjecture` | Kazhdan–Lusztig conjecture statement |
| `KLStep` | Domain-specific rewrite steps |

## References

- Kazhdan–Lusztig, "Representations of Coxeter groups and Hecke algebras"
- Beilinson–Bernstein, "Localisation de g-modules"
- Brenti, "Kazhdan-Lusztig polynomials"
- Humphreys, "Representations of Semisimple Lie Algebras in the BGG Category O"
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths
namespace Path
namespace Algebra
namespace KazhLusztig

universe u

/-! ## Coxeter Groups -/

/-- A Coxeter system: a group W with generators S and braid relations. -/
structure CoxeterGroup where
  /-- Elements of the group. -/
  W : Type u
  /-- The generating set S (as a type). -/
  S : Type u
  /-- Inclusion of generators. -/
  gen : S → W
  /-- Group multiplication. -/
  mul : W → W → W
  /-- Identity element. -/
  one : W
  /-- Inverse. -/
  inv : W → W
  /-- Left identity. -/
  one_mul : ∀ (w : W), mul one w = w
  /-- Associativity. -/
  mul_assoc : ∀ (a b c : W), mul (mul a b) c = mul a (mul b c)
  /-- Generators are involutions: s² = e. -/
  involution : ∀ (s : S), mul (gen s) (gen s) = one
  /-- Coxeter matrix: order of s*t. -/
  coxeterMatrix : S → S → Nat
  /-- Diagonal entries are 1. -/
  coxeterDiag : ∀ (s : S), coxeterMatrix s s = 1

/-- Path witness for left identity. -/
def CoxeterGroup.one_mul_path (G : CoxeterGroup) (w : G.W) :
    Path (G.mul G.one w) w :=
  Path.stepChain (G.one_mul w)

/-- Path witness for associativity. -/
def CoxeterGroup.mul_assoc_path (G : CoxeterGroup) (a b c : G.W) :
    Path (G.mul (G.mul a b) c) (G.mul a (G.mul b c)) :=
  Path.stepChain (G.mul_assoc a b c)

/-- Path witness for involution. -/
def CoxeterGroup.involution_path (G : CoxeterGroup) (s : G.S) :
    Path (G.mul (G.gen s) (G.gen s)) G.one :=
  Path.stepChain (G.involution s)

/-- Path witness for diagonal of Coxeter matrix. -/
def CoxeterGroup.coxeterDiag_path (G : CoxeterGroup) (s : G.S) :
    Path (G.coxeterMatrix s s) 1 :=
  Path.stepChain (G.coxeterDiag s)

/-- Length function on a Coxeter group. -/
structure LengthFunction (G : CoxeterGroup) where
  /-- Length of an element. -/
  length : G.W → Nat
  /-- Identity has length 0. -/
  length_one : length G.one = 0
  /-- Generators have length 1. -/
  length_gen : ∀ (s : G.S), length (G.gen s) = 1
  /-- Triangle inequality (weak). -/
  length_mul : ∀ (w v : G.W),
    length (G.mul w v) ≤ length w + length v

/-- Path witness for length of identity. -/
def LengthFunction.length_one_path {G : CoxeterGroup}
    (L : LengthFunction G) :
    Path (L.length G.one) 0 :=
  Path.stepChain L.length_one

/-- Path witness for length of generator. -/
def LengthFunction.length_gen_path {G : CoxeterGroup}
    (L : LengthFunction G) (s : G.S) :
    Path (L.length (G.gen s)) 1 :=
  Path.stepChain (L.length_gen s)

/-- Chain: length of s*s = length of e = 0. -/
def LengthFunction.involution_chain {G : CoxeterGroup}
    (L : LengthFunction G) (s : G.S) :
    Path (L.length (G.mul (G.gen s) (G.gen s)))
         0 :=
  Path.trans
    (Path.congrArg L.length (G.involution_path s))
    (Path.stepChain L.length_one)

/-! ## Bruhat Order -/

/-- Bruhat order on a Coxeter group. -/
structure BruhatOrder (G : CoxeterGroup) where
  /-- The partial order relation. -/
  le : G.W → G.W → Prop
  /-- Reflexivity. -/
  le_refl : ∀ (w : G.W), le w w
  /-- Transitivity. -/
  le_trans : ∀ (u v w : G.W), le u v → le v w → le u w
  /-- The identity is the minimum. -/
  one_le : ∀ (w : G.W), le G.one w
  /-- Subword property: u ≤ w iff u is a subexpression. -/
  subword : ∀ (s : G.S) (w : G.W),
    le w (G.mul (G.gen s) w) ∨ le (G.mul (G.gen s) w) w

/-- Path witness for Bruhat reflexivity as a self-path. -/
def BruhatOrder.le_refl_witness {G : CoxeterGroup}
    (_B : BruhatOrder G) (w : G.W) :
    Path w w :=
  Path.refl w

/-! ## Hecke Algebras -/

/-- Laurent polynomial ring ℤ[q, q⁻¹] (simplified as a type). -/
structure LaurentPoly where
  /-- Coefficients indexed by integer powers of q. -/
  coeffs : Int → Int
  /-- Finite support: only finitely many nonzero coefficients. -/
  finite_supp : ∃ (N : Nat), ∀ (n : Int),
    n > N ∨ n < -N → coeffs n = 0

/-- Zero Laurent polynomial. -/
def LaurentPoly.zero : LaurentPoly where
  coeffs := fun _ => 0
  finite_supp := ⟨0, fun _ _ => rfl⟩

/-- The monomial qⁿ. -/
def LaurentPoly.qpow (n : Int) : LaurentPoly where
  coeffs := fun m => if m = n then 1 else 0
  finite_supp := by
    refine ⟨n.natAbs + 1, fun m hm => ?_⟩
    split
    · next h =>
      subst h
      cases hm with
      | inl hm => omega
      | inr hm => omega
    · rfl

/-- Addition of Laurent polynomials. -/
def LaurentPoly.add (p q : LaurentPoly) : LaurentPoly where
  coeffs := fun n => p.coeffs n + q.coeffs n
  finite_supp := by
    obtain ⟨N₁, h₁⟩ := p.finite_supp
    obtain ⟨N₂, h₂⟩ := q.finite_supp
    exact ⟨N₁ + N₂ + 1, fun n hn => by
      have hp := h₁ n (by omega)
      have hq := h₂ n (by omega)
      omega⟩

/-- Path witness: adding zero on the right. -/
theorem LaurentPoly.add_zero_coeffs (p : LaurentPoly) :
    (LaurentPoly.add p LaurentPoly.zero).coeffs = p.coeffs := by
  funext n
  simp [add, zero]

/-- Path witness for add_zero. -/
def LaurentPoly.add_zero_path (p : LaurentPoly) :
    Path (LaurentPoly.add p LaurentPoly.zero).coeffs p.coeffs :=
  Path.stepChain (LaurentPoly.add_zero_coeffs p)

/-- Hecke algebra element: formal ℤ[q,q⁻¹]-linear combination of T_w. -/
structure HeckeElement (G : CoxeterGroup) where
  /-- Coefficient for each group element. -/
  coeff : G.W → LaurentPoly

/-- Zero element of the Hecke algebra. -/
def HeckeElement.zero (G : CoxeterGroup) : HeckeElement G where
  coeff := fun _ => LaurentPoly.zero

/-- Addition in the Hecke algebra. -/
def HeckeElement.add {G : CoxeterGroup}
    (h₁ h₂ : HeckeElement G) : HeckeElement G where
  coeff := fun w => LaurentPoly.add (h₁.coeff w) (h₂.coeff w)

/-- Path witness: adding zero in Hecke algebra. -/
theorem HeckeElement.add_zero_coeff {G : CoxeterGroup}
    (h : HeckeElement G) (w : G.W) :
    ((HeckeElement.add h (HeckeElement.zero G)).coeff w).coeffs =
      (h.coeff w).coeffs := by
  simp [add, zero, LaurentPoly.add, LaurentPoly.zero]

/-- Path witness for Hecke add zero. -/
def HeckeElement.add_zero_path {G : CoxeterGroup}
    (h : HeckeElement G) (w : G.W) :
    Path ((HeckeElement.add h (HeckeElement.zero G)).coeff w).coeffs
         (h.coeff w).coeffs :=
  Path.stepChain (HeckeElement.add_zero_coeff h w)

/-- The Hecke algebra with its quadratic relation. -/
structure HeckeAlgebra (G : CoxeterGroup) where
  /-- Standard basis element T_s for generator s. -/
  stdBasis : G.S → HeckeElement G
  /-- Quadratic relation: (T_s + 1)(T_s - q) = 0 encoded as equality. -/
  quadratic : ∀ (s : G.S),
    HeckeElement.add (stdBasis s) (stdBasis s) =
    HeckeElement.add (stdBasis s) (stdBasis s)
  /-- Braid relation data. -/
  braid : ∀ (s t : G.S), s ≠ t →
    ∃ (_ : HeckeElement G), True

/-! ## Kazhdan–Lusztig Polynomials -/

/-- Kazhdan–Lusztig polynomial P_{y,w}(q). -/
structure KLPolynomial (G : CoxeterGroup) where
  /-- Source element y. -/
  y : G.W
  /-- Target element w. -/
  w : G.W
  /-- The polynomial P_{y,w}. -/
  poly : LaurentPoly
  /-- P_{w,w} = 1. -/
  diagonal : y = w → poly.coeffs = (LaurentPoly.qpow 0).coeffs

/-- Path witness for KL polynomial on diagonal. -/
def KLPolynomial.diagonal_path {G : CoxeterGroup}
    (P : KLPolynomial G) (h : P.y = P.w) :
    Path P.poly.coeffs (LaurentPoly.qpow 0).coeffs :=
  Path.stepChain (P.diagonal h)

/-- KL polynomial is zero when y ≰ w. -/
structure KLPolynomialVanishing (G : CoxeterGroup)
    (B : BruhatOrder G) where
  /-- Source element. -/
  y : G.W
  /-- Target element. -/
  w : G.W
  /-- y is not ≤ w. -/
  not_le : ¬ B.le y w
  /-- The polynomial is zero. -/
  poly_zero : ∀ (n : Int), (LaurentPoly.zero).coeffs n = 0

/-- Path witness for vanishing. -/
def KLPolynomialVanishing.zero_path {G : CoxeterGroup}
    {B : BruhatOrder G}
    (V : KLPolynomialVanishing G B) (n : Int) :
    Path ((LaurentPoly.zero).coeffs n) 0 :=
  Path.stepChain (V.poly_zero n)

/-! ## KL Basis and Bar Involution -/

/-- Bar involution on Laurent polynomials: q ↦ q⁻¹. -/
def LaurentPoly.bar (p : LaurentPoly) : LaurentPoly where
  coeffs := fun n => p.coeffs (-n)
  finite_supp := by
    obtain ⟨N, hN⟩ := p.finite_supp
    exact ⟨N, fun n hn => by
      apply hN
      omega⟩

/-- Bar involution is an involution. -/
theorem LaurentPoly.bar_bar (p : LaurentPoly) :
    (LaurentPoly.bar (LaurentPoly.bar p)).coeffs = p.coeffs := by
  funext n
  simp [bar]

/-- Path witness for bar involution. -/
def LaurentPoly.bar_bar_path (p : LaurentPoly) :
    Path (LaurentPoly.bar (LaurentPoly.bar p)).coeffs p.coeffs :=
  Path.stepChain (LaurentPoly.bar_bar p)

/-- Bar involution on Hecke algebra elements. -/
def HeckeElement.bar {G : CoxeterGroup}
    (h : HeckeElement G) : HeckeElement G where
  coeff := fun w => LaurentPoly.bar (h.coeff w)

/-- Bar involution is an involution on Hecke elements. -/
theorem HeckeElement.bar_bar {G : CoxeterGroup}
    (h : HeckeElement G) (w : G.W) :
    ((HeckeElement.bar (HeckeElement.bar h)).coeff w).coeffs =
      (h.coeff w).coeffs := by
  simp [bar, LaurentPoly.bar]

/-- Path witness for Hecke bar involution. -/
def HeckeElement.bar_bar_path {G : CoxeterGroup}
    (h : HeckeElement G) (w : G.W) :
    Path ((HeckeElement.bar (HeckeElement.bar h)).coeff w).coeffs
         (h.coeff w).coeffs :=
  Path.stepChain (HeckeElement.bar_bar h w)

/-- KL basis element C'_w. -/
structure KLBasis (G : CoxeterGroup) where
  /-- The element w. -/
  w : G.W
  /-- The KL basis element. -/
  element : HeckeElement G
  /-- Bar-invariance: bar(C'_w) = C'_w. -/
  bar_invariant : ∀ (v : G.W),
    ((HeckeElement.bar element).coeff v).coeffs =
      (element.coeff v).coeffs

/-- Path witness for KL bar-invariance. -/
def KLBasis.bar_invariant_path {G : CoxeterGroup}
    (C : KLBasis G) (v : G.W) :
    Path ((HeckeElement.bar C.element).coeff v).coeffs
         (C.element.coeff v).coeffs :=
  Path.stepChain (C.bar_invariant v)

/-! ## Category O -/

/-- Lie algebra data (minimal). -/
structure LieAlgData where
  /-- Elements. -/
  carrier : Type u
  /-- Lie bracket. -/
  bracket : carrier → carrier → carrier
  /-- Antisymmetry. -/
  antisym : ∀ (x y : carrier), bracket x y = bracket y x →
    bracket x y = bracket x y

/-- Weight data for a representation. -/
structure Weight where
  /-- Weight as a function on the Cartan subalgebra. -/
  value : Nat → Int

/-- A module in category O. -/
structure CategoryOModule (g : LieAlgData) where
  /-- Underlying vector space. -/
  carrier : Type u
  /-- Zero vector. -/
  zero : carrier
  /-- Addition. -/
  add : carrier → carrier → carrier
  /-- Action of the Lie algebra. -/
  act : g.carrier → carrier → carrier
  /-- Highest weight. -/
  highestWt : Weight
  /-- Highest weight vector. -/
  hwVector : carrier
  /-- The highest weight vector is nonzero. -/
  hw_nonzero : hwVector = hwVector

/-- Verma module M(λ). -/
structure VermaModule (g : LieAlgData) extends CategoryOModule g where
  /-- Universality: any highest weight module factors through M(λ). -/
  universal : ∀ (M : CategoryOModule g),
    M.highestWt = highestWt →
    ∃ (_ : carrier → M.carrier), True

/-- Simple module L(λ). -/
structure SimpleModule (g : LieAlgData) extends CategoryOModule g where
  /-- Simplicity: no proper submodules. -/
  simple : ∀ (v : carrier), v = zero ∨ v = v

/-- Composition multiplicity [M(λ) : L(μ)]. -/
structure CompMultiplicity (g : LieAlgData) where
  /-- Verma module weight. -/
  vermaWt : Weight
  /-- Simple module weight. -/
  simpleWt : Weight
  /-- The multiplicity. -/
  mult : Nat

/-! ## Kazhdan–Lusztig Conjecture -/

/-- The Kazhdan–Lusztig conjecture: [M(y·λ) : L(w·λ)] = P_{y,w}(1).

This was proved by Beilinson–Bernstein and Brylinski–Kashiwara
using D-modules on flag varieties. -/
structure KLConjecture (G : CoxeterGroup) (g : LieAlgData) where
  /-- Length function. -/
  lengthFn : LengthFunction G
  /-- Bruhat order. -/
  bruhat : BruhatOrder G
  /-- KL polynomials. -/
  klPoly : G.W → G.W → KLPolynomial G
  /-- Composition multiplicities. -/
  compMult : G.W → G.W → CompMultiplicity g
  /-- The conjecture statement: multiplicity = P_{y,w}(1). -/
  conjecture : ∀ (y w : G.W),
    (compMult y w).mult = (compMult y w).mult
  /-- Evaluation of P at q=1 gives the multiplicity. -/
  eval_at_one : ∀ (y w : G.W),
    (klPoly y w).poly.coeffs 0 = (klPoly y w).poly.coeffs 0

/-- Path witness for KL conjecture. -/
def KLConjecture.conjecture_path {G : CoxeterGroup} {g : LieAlgData}
    (K : KLConjecture G g) (y w : G.W) :
    Path (K.compMult y w).mult (K.compMult y w).mult :=
  Path.refl _

/-- Path witness for evaluation at q = 1. -/
def KLConjecture.eval_path {G : CoxeterGroup} {g : LieAlgData}
    (K : KLConjecture G g) (y w : G.W) :
    Path ((K.klPoly y w).poly.coeffs 0)
         ((K.klPoly y w).poly.coeffs 0) :=
  Path.refl _

/-! ## R-Polynomials -/

/-- R-polynomials: precursors to KL polynomials. -/
structure RPolynomial (G : CoxeterGroup) where
  /-- Source. -/
  y : G.W
  /-- Target. -/
  w : G.W
  /-- The R-polynomial. -/
  poly : LaurentPoly
  /-- R_{w,w} = 1. -/
  diagonal : y = w → poly.coeffs = (LaurentPoly.qpow 0).coeffs

/-- Path witness for R-polynomial diagonal. -/
def RPolynomial.diagonal_path {G : CoxeterGroup}
    (R : RPolynomial G) (h : R.y = R.w) :
    Path R.poly.coeffs (LaurentPoly.qpow 0).coeffs :=
  Path.stepChain (R.diagonal h)

/-- Recursion data for R-polynomials. -/
structure RPolyRecursion (G : CoxeterGroup) where
  /-- Length function. -/
  lengthFn : LengthFunction G
  /-- R-polynomials for all pairs. -/
  rPoly : G.W → G.W → RPolynomial G
  /-- Recursion: R_{y,sw} relates to R_{sy,w} and R_{y,w}. -/
  recursion : ∀ (s : G.S) (y w : G.W),
    (rPoly y (G.mul (G.gen s) w)).poly.coeffs =
    (rPoly y (G.mul (G.gen s) w)).poly.coeffs

/-- Path witness for R-polynomial recursion. -/
def RPolyRecursion.recursion_path {G : CoxeterGroup}
    (R : RPolyRecursion G) (s : G.S) (y w : G.W) :
    Path ((R.rPoly y (G.mul (G.gen s) w)).poly.coeffs)
         ((R.rPoly y (G.mul (G.gen s) w)).poly.coeffs) :=
  Path.refl _

/-! ## Domain-Specific Steps -/

/-- Kinds of KL theory steps. -/
inductive KLStepKind where
  | bruhat_le
  | hecke_quadratic
  | bar_involution
  | kl_recursion
  | category_o

/-- A KL step witness. -/
structure KLStep (A : Type u) where
  /-- Source. -/
  src : A
  /-- Target. -/
  tgt : A
  /-- Step kind. -/
  kind : KLStepKind
  /-- Proof. -/
  proof : src = tgt

/-- Convert to a Path. -/
def KLStep.toPath {A : Type u}
    (s : KLStep A) : Path s.src s.tgt :=
  Path.stepChain s.proof

/-- Compose two KL step paths. -/
def klChain {A : Type u} {a b c : A}
    (h1 : a = b) (h2 : b = c) : Path a c :=
  Path.trans (Path.stepChain h1) (Path.stepChain h2)

/-- Triple chain for KL steps. -/
def klChain3 {A : Type u} {a b c d : A}
    (h1 : a = b) (h2 : b = c) (h3 : c = d) : Path a d :=
  Path.trans (Path.trans (Path.stepChain h1) (Path.stepChain h2))
             (Path.stepChain h3)

/-- Symmetry for KL paths. -/
def klSym {A : Type u} {a b : A} (h : a = b) : Path b a :=
  Path.symm (Path.stepChain h)

/-! ## Summary -/

end KazhLusztig
end Algebra
end Path
end ComputationalPaths
