/-
# Monoid Theory of Computational Paths

Free monoids, monoid presentations, word problem as path existence,
Green's relations (L, R, J, H, D) — all built from `Path`, `Step`,
`trans`, `symm`.

## Main results (20+ theorems/defs)
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths.Path.Algebra.MonoidPathPaths

open ComputationalPaths.Path

universe u v

variable {A : Type u} {B : Type v}

/-! ## Path Monoid structure -/

/-- A monoid structure witnessed by paths. -/
structure PathMonoid (M : Type u) where
  e   : M
  mul : M → M → M
  mul_assoc : ∀ x y z : M, mul (mul x y) z = mul x (mul y z)
  mul_one   : ∀ x : M, mul x e = x
  one_mul   : ∀ x : M, mul e x = x

/-- Path witnessing associativity. -/
def assoc_path (PM : PathMonoid A) (x y z : A) :
    Path (PM.mul (PM.mul x y) z) (PM.mul x (PM.mul y z)) :=
  Path.ofEq (PM.mul_assoc x y z)

/-- Path witnessing right identity. -/
def mul_one_path (PM : PathMonoid A) (x : A) :
    Path (PM.mul x PM.e) x :=
  Path.ofEq (PM.mul_one x)

/-- Path witnessing left identity. -/
def one_mul_path (PM : PathMonoid A) (x : A) :
    Path (PM.mul PM.e x) x :=
  Path.ofEq (PM.one_mul x)

/-! ## Free Monoid on a type -/

/-- Free monoid is `List A` with concatenation. -/
def FreeMonoid (A : Type u) : PathMonoid (List A) where
  e := []
  mul := List.append
  mul_assoc x y z := List.append_assoc x y z
  mul_one x := List.append_nil x
  one_mul x := List.nil_append x

/-- Path in the free monoid: associativity of concatenation. -/
def free_assoc_path (x y z : List A) :
    Path ((x ++ y) ++ z) (x ++ (y ++ z)) :=
  Path.ofEq (List.append_assoc x y z)

/-- Path in the free monoid: right identity. -/
def free_nil_right (x : List A) : Path (x ++ []) x :=
  Path.ofEq (List.append_nil x)

/-- Path in the free monoid: left identity. -/
def free_nil_left (x : List A) : Path ([] ++ x) x :=
  Path.ofEq (List.nil_append x)

/-! ## Monoid Homomorphisms -/

/-- A monoid homomorphism. -/
structure PathMonoidHom (PM₁ : PathMonoid A) (PM₂ : PathMonoid B) where
  toFun : A → B
  map_mul : ∀ x y : A, toFun (PM₁.mul x y) = PM₂.mul (toFun x) (toFun y)
  map_one : toFun PM₁.e = PM₂.e

/-- Path witnessing homomorphism preserves multiplication. -/
def hom_mul_path {PM₁ : PathMonoid A} {PM₂ : PathMonoid B}
    (f : PathMonoidHom PM₁ PM₂) (x y : A) :
    Path (f.toFun (PM₁.mul x y)) (PM₂.mul (f.toFun x) (f.toFun y)) :=
  Path.ofEq (f.map_mul x y)

/-- Path witnessing homomorphism preserves identity. -/
def hom_one_path {PM₁ : PathMonoid A} {PM₂ : PathMonoid B}
    (f : PathMonoidHom PM₁ PM₂) :
    Path (f.toFun PM₁.e) PM₂.e :=
  Path.ofEq f.map_one

/-- Composition of monoid homomorphisms. -/
def compMonoidHom {C : Type v} {PM₁ : PathMonoid A} {PM₂ : PathMonoid B} {PM₃ : PathMonoid C}
    (f : PathMonoidHom PM₁ PM₂) (g : PathMonoidHom PM₂ PM₃) :
    PathMonoidHom PM₁ PM₃ where
  toFun x := g.toFun (f.toFun x)
  map_mul x y := by rw [f.map_mul, g.map_mul]
  map_one := by rw [f.map_one, g.map_one]

/-! ## Presentations and Word Problem -/

/-- A monoid presentation: generators and relations as pairs of words. -/
structure Presentation where
  numGens  : Nat
  relations : List (List Nat × List Nat)

/-- A word in the free monoid on generators `{0, ..., n-1}`. -/
abbrev Word := List Nat

/-- One-step rewrite: replace a subword according to a relation.
    We model this abstractly: a derivation step witnesses that
    two words are related by one relation application. -/
structure DerivStep (P : Presentation) where
  source : Word
  target : Word
  rel_idx : Nat
  valid : rel_idx < P.relations.length

/-- The word problem: do two words represent the same element?
    This is equivalent to existence of a path between them. -/
def WordEquiv (_P : Presentation) (w₁ w₂ : Word) : Prop :=
  ∃ _ : Path w₁ w₂, True

/-- Reflexivity of word equivalence. -/
theorem word_equiv_refl (P : Presentation) (w : Word) :
    WordEquiv P w w :=
  ⟨Path.refl w, trivial⟩

/-- Symmetry of word equivalence. -/
theorem word_equiv_symm (P : Presentation) (w₁ w₂ : Word)
    (h : WordEquiv P w₁ w₂) : WordEquiv P w₂ w₁ := by
  obtain ⟨p, _⟩ := h
  exact ⟨Path.symm p, trivial⟩

/-- Transitivity of word equivalence. -/
theorem word_equiv_trans (P : Presentation) (w₁ w₂ w₃ : Word)
    (h₁ : WordEquiv P w₁ w₂) (h₂ : WordEquiv P w₂ w₃) :
    WordEquiv P w₁ w₃ := by
  obtain ⟨p₁, _⟩ := h₁
  obtain ⟨p₂, _⟩ := h₂
  exact ⟨Path.trans p₁ p₂, trivial⟩

/-! ## Green's Relations -/

/-- Right ideal membership: `a` is in the right ideal generated by `b`
    if `a = b * s` for some `s`. -/
def InRightIdeal (PM : PathMonoid A) (a b : A) : Prop :=
  ∃ s : A, a = PM.mul b s

/-- Left ideal membership: `a` is in the left ideal generated by `b`
    if `a = s * b` for some `s`. -/
def InLeftIdeal (PM : PathMonoid A) (a b : A) : Prop :=
  ∃ s : A, a = PM.mul s b

/-- Two-sided ideal membership. -/
def InIdeal (PM : PathMonoid A) (a b : A) : Prop :=
  ∃ s t : A, a = PM.mul s (PM.mul b t)

/-- Green's R-relation: `a R b` iff `aM = bM`. -/
def GreenR (PM : PathMonoid A) (a b : A) : Prop :=
  InRightIdeal PM a b ∧ InRightIdeal PM b a

/-- Green's L-relation: `a L b` iff `Ma = Mb`. -/
def GreenL (PM : PathMonoid A) (a b : A) : Prop :=
  InLeftIdeal PM a b ∧ InLeftIdeal PM b a

/-- Green's J-relation: `a J b` iff `MaM = MbM`. -/
def GreenJ (PM : PathMonoid A) (a b : A) : Prop :=
  InIdeal PM a b ∧ InIdeal PM b a

/-- Green's H-relation: intersection of R and L. -/
def GreenH (PM : PathMonoid A) (a b : A) : Prop :=
  GreenR PM a b ∧ GreenL PM a b

/-- Green's D-relation: composition of L and R. -/
def GreenD (PM : PathMonoid A) (a b : A) : Prop :=
  ∃ c : A, GreenL PM a c ∧ GreenR PM c b

/-- R is reflexive. -/
theorem greenR_refl (PM : PathMonoid A) (a : A) : GreenR PM a a :=
  ⟨⟨PM.e, (PM.mul_one a).symm⟩, ⟨PM.e, (PM.mul_one a).symm⟩⟩

/-- L is reflexive. -/
theorem greenL_refl (PM : PathMonoid A) (a : A) : GreenL PM a a :=
  ⟨⟨PM.e, (PM.one_mul a).symm⟩, ⟨PM.e, (PM.one_mul a).symm⟩⟩

/-- R is symmetric. -/
theorem greenR_symm (PM : PathMonoid A) (a b : A) :
    GreenR PM a b → GreenR PM b a := fun ⟨h1, h2⟩ => ⟨h2, h1⟩

/-- L is symmetric. -/
theorem greenL_symm (PM : PathMonoid A) (a b : A) :
    GreenL PM a b → GreenL PM b a := fun ⟨h1, h2⟩ => ⟨h2, h1⟩

/-- J is symmetric. -/
theorem greenJ_symm (PM : PathMonoid A) (a b : A) :
    GreenJ PM a b → GreenJ PM b a := fun ⟨h1, h2⟩ => ⟨h2, h1⟩

/-- H is symmetric. -/
theorem greenH_symm (PM : PathMonoid A) (a b : A) :
    GreenH PM a b → GreenH PM b a :=
  fun ⟨hr, hl⟩ => ⟨greenR_symm PM a b hr, greenL_symm PM a b hl⟩

/-- H refines R. -/
theorem greenH_implies_R (PM : PathMonoid A) (a b : A) :
    GreenH PM a b → GreenR PM a b := fun ⟨hr, _⟩ => hr

/-- H refines L. -/
theorem greenH_implies_L (PM : PathMonoid A) (a b : A) :
    GreenH PM a b → GreenL PM a b := fun ⟨_, hl⟩ => hl

/-- Path witnessing R-reflexivity: `a = a * e`. -/
def greenR_refl_path (PM : PathMonoid A) (a : A) :
    Path a (PM.mul a PM.e) :=
  Path.symm (mul_one_path PM a)

/-- D is reflexive. -/
theorem greenD_refl (PM : PathMonoid A) (a : A) : GreenD PM a a :=
  ⟨a, greenL_refl PM a, greenR_refl PM a⟩

/-- J is reflexive. -/
theorem greenJ_refl (PM : PathMonoid A) (a : A) : GreenJ PM a a :=
  ⟨⟨PM.e, PM.e, by rw [PM.one_mul, PM.mul_one]⟩,
   ⟨PM.e, PM.e, by rw [PM.one_mul, PM.mul_one]⟩⟩

/-! ## Identity element path properties -/

/-- The identity is idempotent. -/
def identity_idempotent (PM : PathMonoid A) :
    Path (PM.mul PM.e PM.e) PM.e :=
  Path.ofEq (PM.one_mul PM.e)

/-- Path: (x * e) * y = x * y via right identity then reassociate. -/
def mul_one_cancel_path (PM : PathMonoid A) (x y : A) :
    Path (PM.mul (PM.mul x PM.e) y) (PM.mul x y) :=
  Path.ofEq (by rw [PM.mul_one])

end ComputationalPaths.Path.Algebra.MonoidPathPaths
