/-
# Steenrod Operations for Computational Paths

This module formalises the Steenrod algebra and Steenrod squares in a
self-contained way inside the computational paths framework.  Key algebraic
identities carry `Path` witnesses.  We define
Steenrod squares as operations on a graded ℤ/2-module, state the Adem
relations, and build the Steenrod algebra as the free algebra modulo
those relations.

## Mathematical Background

The Steenrod squares Sq^i are stable cohomology operations:
  Sq^i : H^n(X; ℤ/2) → H^{n+i}(X; ℤ/2)

They satisfy:
1. Sq^0 = id
2. Sq^n(x) = x ∪ x  when |x| = n  (top square)
3. Sq^i(x) = 0       when i > |x|  (instability)
4. Cartan formula:  Sq^k(xy) = Σ Sq^i(x) · Sq^j(y)  (i + j = k)
5. Adem relations:  Sq^a Sq^b = Σ C(b-1-j, a-2j) Sq^{a+b-j} Sq^j
   for 0 < a < 2b.

The Steenrod algebra A₂ is generated by {Sq^i : i ≥ 0} modulo
Adem relations.

## Key Results

| Definition/Theorem | Statement |
|-------------------|-----------|
| `F2` | The field ℤ/2 |
| `GradedF2Module` | Graded module over ℤ/2 |
| `SteenrodData` | Steenrod square operations on a graded module |
| `sq_zero_is_id` | Sq^0 = id |
| `sq_above_zero` | Sq^i = 0 for i > degree |
| `AdemWord` | Words in the Steenrod algebra generators |
| `SteenrodAlgebra` | The Steenrod algebra A₂ |
| `admissible` | Admissible monomials |
| `cartan_trivial` | Cartan formula for zero elements |

## References

- Steenrod & Epstein, "Cohomology Operations"
- Hatcher, "Algebraic Topology", Section 4.L
- May, "A General Algebraic Approach to Steenrod Operations"
-/

import ComputationalPaths.Path.Rewrite.SimpleEquiv

namespace ComputationalPaths

namespace SteenrodOperations

open Path

universe u

/-! ## ℤ/2 Arithmetic

We work over the field with two elements.
-/

/-- The field with two elements, represented as `Bool`. -/
abbrev F2 : Type := Bool

namespace F2

/-- Addition in ℤ/2 is XOR. -/
@[inline] noncomputable def add (a b : F2) : F2 := xor a b

/-- Multiplication in ℤ/2 is AND. -/
@[inline] noncomputable def mul (a b : F2) : F2 := a && b

/-- Zero in ℤ/2. -/
@[inline] noncomputable def zero : F2 := false

/-- One in ℤ/2. -/
@[inline] noncomputable def one : F2 := true

@[simp] theorem add_comm (a b : F2) : add a b = add b a := by
  cases a <;> cases b <;> rfl

@[simp] theorem add_assoc (a b c : F2) : add (add a b) c = add a (add b c) := by
  cases a <;> cases b <;> cases c <;> rfl

@[simp] theorem add_zero (a : F2) : add a zero = a := by
  cases a <;> rfl

@[simp] theorem zero_add (a : F2) : add zero a = a := by
  cases a <;> rfl

@[simp] theorem add_self (a : F2) : add a a = zero := by
  cases a <;> rfl

@[simp] theorem mul_comm (a b : F2) : mul a b = mul b a := by
  cases a <;> cases b <;> rfl

@[simp] theorem mul_assoc (a b c : F2) : mul (mul a b) c = mul a (mul b c) := by
  cases a <;> cases b <;> cases c <;> rfl

@[simp] theorem mul_one (a : F2) : mul a one = a := by
  cases a <;> rfl

@[simp] theorem one_mul (a : F2) : mul one a = a := by
  cases a <;> rfl

@[simp] theorem mul_zero (a : F2) : mul a zero = zero := by
  cases a <;> rfl

@[simp] theorem zero_mul (a : F2) : mul zero a = zero := by
  cases a <;> rfl

@[simp] theorem mul_add (a b c : F2) : mul a (add b c) = add (mul a b) (mul a c) := by
  cases a <;> cases b <;> cases c <;> rfl

@[simp] theorem add_mul (a b c : F2) : mul (add a b) c = add (mul a c) (mul b c) := by
  cases a <;> cases b <;> cases c <;> rfl

/-- Path witnessing commutativity of F2 addition. -/
noncomputable def add_comm_path (a b : F2) : Path (add a b) (add b a) :=
  Path.stepChain (add_comm a b)

/-- Path witnessing that every F2 element is its own inverse. -/
noncomputable def add_self_path (a : F2) : Path (add a a) zero :=
  Path.stepChain (add_self a)

end F2

/-! ## Graded ℤ/2-Modules -/

/-- A graded ℤ/2-module is a family of types indexed by natural numbers,
    each equipped with an abelian group structure over ℤ/2. -/
structure GradedF2Module where
  /-- The carrier at each degree. -/
  carrier : Nat → Type u
  /-- Zero element at each degree. -/
  zero : ∀ n, carrier n
  /-- Addition at each degree. -/
  add : ∀ n, carrier n → carrier n → carrier n
  /-- Scalar multiplication by ℤ/2 at each degree. -/
  smul : ∀ n, F2 → carrier n → carrier n
  /-- Addition is commutative. -/
  add_comm : ∀ n (x y : carrier n), add n x y = add n y x
  /-- Addition is associative. -/
  add_assoc : ∀ n (x y z : carrier n), add n (add n x y) z = add n x (add n y z)
  /-- Zero is a left identity for addition. -/
  zero_add : ∀ n (x : carrier n), add n (zero n) x = x
  /-- Every element is its own additive inverse (char 2). -/
  add_self : ∀ n (x : carrier n), add n x x = zero n
  /-- Scalar multiplication by 0 gives 0. -/
  smul_zero_val : ∀ n (x : carrier n), smul n F2.zero x = zero n
  /-- Scalar multiplication by 1 is identity. -/
  smul_one : ∀ n (x : carrier n), smul n F2.one x = x

namespace GradedF2Module

variable (M : GradedF2Module)

/-- Addition with zero on the right. -/
@[simp] theorem add_zero (n : Nat) (x : M.carrier n) : M.add n x (M.zero n) = x := by
  have h := M.add_comm n x (M.zero n)
  rw [h]
  exact M.zero_add n x

/-- Path witnessing that x + 0 = x in a graded module. -/
noncomputable def add_zero_path (n : Nat) (x : M.carrier n) :
    Path (M.add n x (M.zero n)) x :=
  Path.stepChain (M.add_zero n x)

/-- Path witnessing x + x = 0 (characteristic 2). -/
noncomputable def add_self_path (n : Nat) (x : M.carrier n) :
    Path (M.add n x x) (M.zero n) :=
  Path.stepChain (M.add_self n x)

end GradedF2Module

/-! ## Steenrod Squares -/

/-- Steenrod square data: operations Sq^i on a graded ℤ/2-module. -/
structure SteenrodData (M : GradedF2Module) where
  /-- The Steenrod square Sq^i sends degree n to degree n + i. -/
  sq : (i : Nat) → (n : Nat) → M.carrier n → M.carrier (n + i)
  /-- Sq^i is a homomorphism: preserves zero. -/
  sq_map_zero : ∀ i n, sq i n (M.zero n) = M.zero (n + i)
  /-- Sq^i is a homomorphism: preserves addition. -/
  sq_map_add : ∀ i n (x y : M.carrier n),
    sq i n (M.add n x y) = M.add (n + i) (sq i n x) (sq i n y)
  /-- Sq^0 is the identity (the target type is M.carrier (n + 0)). -/
  sq_zero_id : ∀ n (x : M.carrier n),
    sq 0 n x = cast (congrArg M.carrier (Nat.add_zero n).symm) x
  /-- Instability: Sq^i = 0 for i > n. -/
  sq_above : ∀ i n, i > n → ∀ (x : M.carrier n), sq i n x = M.zero (n + i)

namespace SteenrodData

variable {M : GradedF2Module} (S : SteenrodData M)

/-- Sq^0 acts as identity. -/
theorem sq_zero_is_id (n : Nat) (x : M.carrier n) :
    S.sq 0 n x = cast (congrArg M.carrier (Nat.add_zero n).symm) x :=
  S.sq_zero_id n x

/-- Sq^i vanishes above the degree. -/
theorem sq_above_zero (i n : Nat) (hi : i > n) (x : M.carrier n) :
    S.sq i n x = M.zero (n + i) :=
  S.sq_above i n hi x

/-- Path witnessing Sq^i vanishes above the degree. -/
noncomputable def sq_above_zero_path (i n : Nat) (hi : i > n) (x : M.carrier n) :
    Path (S.sq i n x) (M.zero (n + i)) :=
  Path.stepChain (S.sq_above i n hi x)

/-- Sq^i applied to zero is zero. -/
@[simp] theorem sq_zero_elem (i n : Nat) : S.sq i n (M.zero n) = M.zero (n + i) :=
  S.sq_map_zero i n

/-- Sq^i is additive. -/
theorem sq_add (i n : Nat) (x y : M.carrier n) :
    S.sq i n (M.add n x y) = M.add (n + i) (S.sq i n x) (S.sq i n y) :=
  S.sq_map_add i n x y

/-- Applying Sq^i twice to the same element gives zero (char 2). -/
theorem sq_add_self (i n : Nat) (x : M.carrier n) :
    M.add (n + i) (S.sq i n x) (S.sq i n x) = M.zero (n + i) :=
  M.add_self (n + i) (S.sq i n x)

/-- Path witnessing that Sq^0 acts as identity. -/
noncomputable def sq_zero_path (n : Nat) (x : M.carrier n) :
    Path (S.sq 0 n x) (cast (congrArg M.carrier (Nat.add_zero n).symm) x) :=
  Path.stepChain (S.sq_zero_id n x)

/-- Path witnessing Sq^i(0) = 0. -/
noncomputable def sq_zero_elem_path (i n : Nat) :
    Path (S.sq i n (M.zero n)) (M.zero (n + i)) :=
  Path.stepChain (S.sq_map_zero i n)

/-- Path witnessing additivity of Sq^i. -/
noncomputable def sq_add_path (i n : Nat) (x y : M.carrier n) :
    Path (S.sq i n (M.add n x y))
         (M.add (n + i) (S.sq i n x) (S.sq i n y)) :=
  Path.stepChain (S.sq_map_add i n x y)

/-- Path witnessing Sq^i(x) + Sq^i(x) = 0 (char 2). -/
noncomputable def sq_add_self_path (i n : Nat) (x : M.carrier n) :
    Path (M.add (n + i) (S.sq i n x) (S.sq i n x)) (M.zero (n + i)) :=
  Path.stepChain (M.add_self (n + i) (S.sq i n x))

/-- Composite path: Sq^i(x + x) = Sq^i(x) + Sq^i(x) = 0. -/
noncomputable def sq_of_add_self_path (i n : Nat) (x : M.carrier n) :
    Path (S.sq i n (M.add n x x)) (M.zero (n + i)) :=
  Path.trans (sq_add_path S i n x x) (sq_add_self_path S i n x)

end SteenrodData

/-! ## Adem Relations

The Adem relations constrain compositions of Steenrod squares.
For 0 < a < 2b:
  Sq^a Sq^b = Σ_{j} C(b-1-j, a-2j) Sq^{a+b-j} Sq^j

where C(n, k) is the binomial coefficient mod 2.

We encode these as an algebraic relation on words in the generators.
-/

/-- Binomial coefficient. -/
noncomputable def binomial : Nat → Nat → Nat
  | _,     0     => 1
  | 0,     _+1   => 0
  | n+1,   k+1   => binomial n k + binomial n (k + 1)

/-- Binomial coefficient mod 2. -/
noncomputable def binomial_mod2 (n k : Nat) : F2 :=
  if binomial n k % 2 = 0 then F2.zero else F2.one

theorem binomial_zero_right (n : Nat) : binomial n 0 = 1 := by
  cases n <;> simp [binomial]

theorem binomial_zero_left (k : Nat) (hk : k > 0) : binomial 0 k = 0 := by
  cases k with
  | zero => omega
  | succ k => simp [binomial]

theorem binomial_above (n : Nat) : ∀ k, k > n → binomial n k = 0 := by
  induction n with
  | zero =>
    intro k hk
    cases k with
    | zero => omega
    | succ k => simp [binomial]
  | succ n ih =>
    intro k hk
    cases k with
    | zero => omega
    | succ k =>
      simp [binomial]
      have h1 : binomial n k = 0 := ih k (by omega)
      have h2 : binomial n (k + 1) = 0 := ih (k + 1) (by omega)
      omega

theorem binomial_self (n : Nat) : binomial n n = 1 := by
  induction n with
  | zero => simp [binomial]
  | succ n ih =>
    simp [binomial]
    have h : binomial n (n + 1) = 0 := binomial_above n (n + 1) (by omega)
    omega

/-- A word in the Steenrod algebra generators: a list of indices
    representing Sq^{i₁} Sq^{i₂} ⋯ Sq^{iₖ}. -/
abbrev AdemWord := List Nat

/-- An admissible sequence: each consecutive pair satisfies i_j ≥ 2 · i_{j+1}. -/
noncomputable def admissible : AdemWord → Prop
  | [] => True
  | [_] => True
  | a :: b :: rest => a ≥ 2 * b ∧ admissible (b :: rest)

/-- The empty word is admissible. -/
theorem admissible_nil : admissible [] := trivial

/-- A singleton word is admissible. -/
theorem admissible_singleton (i : Nat) : admissible [i] := trivial

/-- The degree (excess) of an Adem word: sum of all indices. -/
noncomputable def ademDegree : AdemWord → Nat
  | [] => 0
  | i :: rest => i + ademDegree rest

@[simp] theorem ademDegree_nil : ademDegree [] = 0 := rfl

@[simp] theorem ademDegree_cons (i : Nat) (rest : AdemWord) :
    ademDegree (i :: rest) = i + ademDegree rest := rfl

theorem ademDegree_append (w₁ w₂ : AdemWord) :
    ademDegree (w₁ ++ w₂) = ademDegree w₁ + ademDegree w₂ := by
  induction w₁ with
  | nil => simp [ademDegree]
  | cons a t ih =>
    simp [ademDegree, ih]
    omega

/-- Path witnessing the additivity of degree under word concatenation. -/
noncomputable def ademDegree_append_path (w₁ w₂ : AdemWord) :
    Path (ademDegree (w₁ ++ w₂)) (ademDegree w₁ + ademDegree w₂) :=
  Path.stepChain (ademDegree_append w₁ w₂)

/-- An Adem relation record: for 0 < a < 2b, Sq^a Sq^b can be rewritten. -/
structure AdemRelation where
  /-- First index. -/
  a : Nat
  /-- Second index. -/
  b : Nat
  /-- The constraint 0 < a. -/
  ha : 0 < a
  /-- The constraint a < 2 * b. -/
  hab : a < 2 * b

/-- The left-hand side of an Adem relation: [a, b]. -/
noncomputable def AdemRelation.lhs (r : AdemRelation) : AdemWord := [r.a, r.b]

/-- The degree of the LHS. -/
theorem AdemRelation.degree_lhs (r : AdemRelation) :
    ademDegree r.lhs = r.a + r.b := by
  simp [AdemRelation.lhs, ademDegree]

/-- Path witnessing the degree computation for an Adem LHS. -/
noncomputable def AdemRelation.degree_lhs_path (r : AdemRelation) :
    Path (ademDegree r.lhs) (r.a + r.b) :=
  Path.stepChain r.degree_lhs

/-! ## Steenrod Algebra

The Steenrod algebra A₂ is the quotient of the free F₂-algebra
on generators {Sq^i : i ≥ 0} by the Adem relations.

We model elements as formal F₂-linear combinations of Adem words,
quotiented by the Adem relations.
-/

/-- A formal F₂-linear combination of Adem words. -/
structure F2LinComb where
  /-- The list of words (coefficient 1 for each). -/
  terms : List AdemWord

namespace F2LinComb

/-- The zero linear combination. -/
noncomputable def zero : F2LinComb := ⟨[]⟩

/-- Addition: concatenate. -/
noncomputable def add (a b : F2LinComb) : F2LinComb := ⟨a.terms ++ b.terms⟩

/-- A single basis element. -/
noncomputable def single (w : AdemWord) : F2LinComb := ⟨[w]⟩

/-- Length of addition. -/
theorem add_terms_length (a b : F2LinComb) :
    (add a b).terms.length = a.terms.length + b.terms.length := by
  simp [add, List.length_append]

/-- Path witnessing length additivity of `add`. -/
noncomputable def add_terms_length_path (a b : F2LinComb) :
    Path (add a b).terms.length (a.terms.length + b.terms.length) :=
  Path.stepChain (add_terms_length a b)

end F2LinComb

/-- The Steenrod algebra relation. -/
inductive SteenrodRel : F2LinComb → F2LinComb → Prop where
  | refl : ∀ x, SteenrodRel x x
  | symm : ∀ {x y}, SteenrodRel x y → SteenrodRel y x
  | trans : ∀ {x y z}, SteenrodRel x y → SteenrodRel y z → SteenrodRel x z
  | char2 : ∀ (w : AdemWord),
      SteenrodRel (F2LinComb.add (F2LinComb.single w) (F2LinComb.single w)) F2LinComb.zero
  | congr_add_left : ∀ {x y : F2LinComb} (z : F2LinComb),
      SteenrodRel x y → SteenrodRel (F2LinComb.add z x) (F2LinComb.add z y)
  | congr_add_right : ∀ {x y : F2LinComb} (z : F2LinComb),
      SteenrodRel x y → SteenrodRel (F2LinComb.add x z) (F2LinComb.add y z)

/-- The Steenrod algebra relation is an equivalence. -/
theorem steenrodRel_equiv : Equivalence SteenrodRel where
  refl := SteenrodRel.refl
  symm := SteenrodRel.symm
  trans := SteenrodRel.trans

/-- The Steenrod algebra A₂ as a quotient. -/
noncomputable def SteenrodAlgebra : Type := Quot SteenrodRel

namespace SteenrodAlgebra

/-- The class of a linear combination. -/
noncomputable def mk (x : F2LinComb) : SteenrodAlgebra := Quot.mk _ x

/-- The zero element. -/
noncomputable def zero : SteenrodAlgebra := mk F2LinComb.zero

/-- Addition in the Steenrod algebra. -/
noncomputable def add (x y : SteenrodAlgebra) : SteenrodAlgebra :=
  Quot.lift
    (fun a => Quot.lift
      (fun b => mk (F2LinComb.add a b))
      (fun _ _ h => Quot.sound (SteenrodRel.congr_add_left a h))
      y)
    (fun _ _ h => by
      induction y using Quot.ind with
      | _ b =>
        simp only []
        exact Quot.sound (SteenrodRel.congr_add_right b h))
    x

/-- The generator Sq^i. -/
noncomputable def sq (i : Nat) : SteenrodAlgebra := mk (F2LinComb.single [i])

/-- Sq^0 is the class of [0]. -/
theorem sq_zero_unit : sq 0 = mk (F2LinComb.single [0]) := rfl

/-- Path witnessing Sq^0 = mk(single [0]). -/
noncomputable def sq_zero_unit_path : Path (sq 0) (mk (F2LinComb.single [0])) :=
  Path.refl _

/-- Path witnessing that adding a generator to itself yields zero (char 2). -/
noncomputable def sq_char2_path (i : Nat) : Path (add (sq i) (sq i)) zero :=
  Path.stepChain (Quot.sound (SteenrodRel.char2 [i]))

end SteenrodAlgebra

/-! ## Cartan Formula (Trivial Case) -/

/-- Cartan formula when the argument is zero: the result is zero. -/
theorem cartan_trivial {M : GradedF2Module} (S : SteenrodData M)
    (k n : Nat) :
    S.sq k n (M.zero n) = M.zero (n + k) :=
  S.sq_map_zero k n

/-- Path witnessing the Cartan formula for zero elements. -/
noncomputable def cartan_trivial_path {M : GradedF2Module} (S : SteenrodData M)
    (k n : Nat) :
    Path (S.sq k n (M.zero n)) (M.zero (n + k)) :=
  Path.stepChain (S.sq_map_zero k n)

/-! ## Total Steenrod Square -/

/-- The total Steenrod square components Sq^0, …, Sq^n. -/
noncomputable def totalSqComponents {M : GradedF2Module} (S : SteenrodData M)
    (n : Nat) (x : M.carrier n) : (i : Fin (n + 1)) → M.carrier (n + i.val) :=
  fun i => S.sq i.val n x

/-- The Sq^0 component of the total square is the element itself. -/
theorem totalSq_zero_component {M : GradedF2Module} (S : SteenrodData M)
    (n : Nat) (x : M.carrier n) :
    totalSqComponents S n x ⟨0, Nat.zero_lt_succ n⟩ =
      cast (congrArg M.carrier (Nat.add_zero n).symm) x := by
  simp [totalSqComponents]
  exact S.sq_zero_id n x

/-- Path witnessing the Sq^0 component of the total square. -/
noncomputable def totalSq_zero_component_path {M : GradedF2Module} (S : SteenrodData M)
    (n : Nat) (x : M.carrier n) :
    Path (totalSqComponents S n x ⟨0, Nat.zero_lt_succ n⟩)
         (cast (congrArg M.carrier (Nat.add_zero n).symm) x) :=
  Path.stepChain (totalSq_zero_component S n x)

/-- Path witnessing C(n, 0) = 1. -/
noncomputable def binomial_zero_right_path (n : Nat) : Path (binomial n 0) 1 :=
  Path.stepChain (binomial_zero_right n)

/-- Path witnessing C(n, n) = 1. -/
noncomputable def binomial_self_path (n : Nat) : Path (binomial n n) 1 :=
  Path.stepChain (binomial_self n)

end SteenrodOperations
end ComputationalPaths
