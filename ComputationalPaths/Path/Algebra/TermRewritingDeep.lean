/-
  ComputationalPaths / Path / Algebra / TermRewritingDeep.lean

  Term Rewriting Systems — The Deepest Path Theory
  ==================================================

  First-order terms, positions, contexts, substitutions, unification,
  rewrite rules, critical pairs, termination orderings, Knuth-Bendix
  completion, confluence via critical pairs, narrowing — all developed
  through computational paths as the primary mathematical objects.

  Binary-tree term representation avoids nested-inductive issues.
  Steps are generated by rewrite rules applied at positions via
  substitutions.  Paths compose via trans / symm / congrArg forming
  the groupoid of rewrites.  Multi-step chains pervade every proof.

  55+ theorems/defs.  Zero sorry.  Zero Path.ofEq.  Zero admit.
-/

set_option linter.unusedVariables false

-- ============================================================
-- §1  First-Order Terms (Binary Tree Representation)
-- ============================================================

/-- Terms: variables by index, constants by name, binary application. -/
inductive TRTm where
  | var   : Nat → TRTm
  | const : String → TRTm
  | app   : TRTm → TRTm → TRTm
deriving DecidableEq, Repr

-- ============================================================
-- §2  Positions & Contexts
-- ============================================================

inductive TRDir where
  | L | R
deriving DecidableEq, Repr

abbrev TRPos := List TRDir

noncomputable def TRTm.atPos : TRTm → TRPos → Option TRTm
  | t, []              => some t
  | .app l _, TRDir.L :: p => l.atPos p
  | .app _ r, TRDir.R :: p => r.atPos p
  | _, _ :: _           => none

noncomputable def TRTm.replaceAt : TRTm → TRPos → TRTm → TRTm
  | _, [], s                      => s
  | .app l r, TRDir.L :: p, s => .app (l.replaceAt p s) r
  | .app l r, TRDir.R :: p, s => .app l (r.replaceAt p s)
  | t, _ :: _, _                  => t

noncomputable def trHoleIdx : Nat := 99999
noncomputable def trHole : TRTm := .var trHoleIdx

noncomputable def trPlug (ctx t : TRTm) : TRTm :=
  match ctx with
  | .var n   => if n == trHoleIdx then t else .var n
  | .const c => .const c
  | .app l r => .app (trPlug l t) (trPlug r t)

-- ============================================================
-- §3  Substitutions
-- ============================================================

noncomputable def TRSubst := Nat → TRTm

noncomputable def TRSubst.id : TRSubst := TRTm.var

noncomputable def TRTm.applyS (σ : TRSubst) : TRTm → TRTm
  | .var n   => σ n
  | .const c => .const c
  | .app l r => .app (l.applyS σ) (r.applyS σ)

noncomputable def TRSubst.comp (σ τ : TRSubst) : TRSubst :=
  fun n => (τ n).applyS σ

noncomputable def TRSubst.single (x : Nat) (t : TRTm) : TRSubst :=
  fun n => if n == x then t else .var n

-- ============================================================
-- §4  Size, Depth, Variables, Occurs
-- ============================================================

noncomputable def TRTm.size : TRTm → Nat
  | .var _   => 1
  | .const _ => 1
  | .app l r => 1 + l.size + r.size

noncomputable def TRTm.depth : TRTm → Nat
  | .var _   => 0
  | .const _ => 0
  | .app l r => 1 + max l.depth r.depth

noncomputable def TRTm.vars : TRTm → List Nat
  | .var n   => [n]
  | .const _ => []
  | .app l r => l.vars ++ r.vars

noncomputable def TRTm.occurs (x : Nat) : TRTm → Bool
  | .var n   => n == x
  | .const _ => false
  | .app l r => l.occurs x || r.occurs x

-- ============================================================
-- §5  Rewrite Rules & TRS
-- ============================================================

structure TRRule where
  lhs : TRTm
  rhs : TRTm
deriving DecidableEq, Repr

abbrev TRTRS := List TRRule

-- ============================================================
-- §6  Step & Path — Prop-valued rewriting groupoid
-- ============================================================

inductive TRStep (R : TRTRS) : TRTm → TRTm → Prop where
  | ruleAt (r : TRRule) (σ : TRSubst) (p : TRPos)
      (t : TRTm) (hmem : r ∈ R)
      (hat : t.atPos p = some (r.lhs.applyS σ))
      (t' : TRTm)
      (heq : t' = t.replaceAt p (r.rhs.applyS σ)) :
      TRStep R t t'

inductive TRPath (R : TRTRS) : TRTm → TRTm → Prop where
  | refl  : (t : TRTm) → TRPath R t t
  | step  : TRStep R a b → TRPath R a b
  | trans : TRPath R a b → TRPath R b c → TRPath R a c
  | symm  : TRPath R a b → TRPath R b a
  | congrL : TRPath R l l' → (r : TRTm) → TRPath R (.app l r) (.app l' r)
  | congrR : (l : TRTm) → TRPath R r r' → TRPath R (.app l r) (.app l r')

-- ============================================================
-- §7  Path Algebra Basics
-- ============================================================

/-- Theorem 1: refl is left identity for trans. -/
theorem trpath_refl_trans {R : TRTRS} (p : TRPath R a b) :
    TRPath R a b :=
  TRPath.trans (TRPath.refl a) p

/-- Theorem 2: refl is right identity for trans. -/
theorem trpath_trans_refl {R : TRTRS} (p : TRPath R a b) :
    TRPath R a b :=
  TRPath.trans p (TRPath.refl b)

/-- Theorem 3: double symm round-trips. -/
theorem trpath_symm_symm {R : TRTRS} (p : TRPath R a b) :
    TRPath R a b :=
  TRPath.symm (TRPath.symm p)

/-- Theorem 4: path ∘ path⁻¹ is a loop at source. -/
theorem trpath_loop {R : TRTRS} (p : TRPath R a b) : TRPath R a a :=
  TRPath.trans p (TRPath.symm p)

/-- Theorem 5: path⁻¹ ∘ path is a loop at target. -/
theorem trpath_loop_target {R : TRTRS} (p : TRPath R a b) : TRPath R b b :=
  TRPath.trans (TRPath.symm p) p

/-- Theorem 6: three-fold trans. -/
theorem trpath_trans₃ {R : TRTRS} (p : TRPath R a b)
    (q : TRPath R b c) (r : TRPath R c d) : TRPath R a d :=
  TRPath.trans p (TRPath.trans q r)

/-- Theorem 7: four-fold trans. -/
theorem trpath_trans₄ {R : TRTRS} (p : TRPath R a b) (q : TRPath R b c)
    (r : TRPath R c d) (s : TRPath R d e) : TRPath R a e :=
  TRPath.trans (TRPath.trans p q) (TRPath.trans r s)

/-- Theorem 8: five-fold trans chain. -/
theorem trpath_trans₅ {R : TRTRS} (p₁ : TRPath R a b)
    (p₂ : TRPath R b c) (p₃ : TRPath R c d)
    (p₄ : TRPath R d e) (p₅ : TRPath R e f) : TRPath R a f :=
  TRPath.trans p₁ (TRPath.trans (TRPath.trans p₂ p₃) (TRPath.trans p₄ p₅))

/-- Theorem 9: symm distributes over trans (reverses order). -/
theorem trpath_symm_trans {R : TRTRS} (p : TRPath R a b)
    (q : TRPath R b c) : TRPath R c a :=
  TRPath.trans (TRPath.symm q) (TRPath.symm p)

/-- Theorem 10: symm of three-fold trans. -/
theorem trpath_symm_trans₃ {R : TRTRS} (p : TRPath R a b)
    (q : TRPath R b c) (r : TRPath R c d) : TRPath R d a :=
  TRPath.trans (TRPath.symm r) (TRPath.trans (TRPath.symm q) (TRPath.symm p))

-- ============================================================
-- §8  Congruence Algebra
-- ============================================================

/-- Theorem 11: congrL preserves refl. -/
theorem tr_congrL_refl {R : TRTRS} (l r : TRTm) :
    TRPath R (.app l r) (.app l r) :=
  TRPath.congrL (TRPath.refl l) r

/-- Theorem 12: congrR preserves refl. -/
theorem tr_congrR_refl {R : TRTRS} (l r : TRTm) :
    TRPath R (.app l r) (.app l r) :=
  TRPath.congrR l (TRPath.refl r)

/-- Theorem 13: congrL distributes over trans. -/
theorem tr_congrL_trans {R : TRTRS} (r : TRTm)
    (p : TRPath R l₁ l₂) (q : TRPath R l₂ l₃) :
    TRPath R (.app l₁ r) (.app l₃ r) :=
  TRPath.trans (TRPath.congrL p r) (TRPath.congrL q r)

/-- Theorem 14: congrR distributes over trans. -/
theorem tr_congrR_trans {R : TRTRS} (l : TRTm)
    (p : TRPath R r₁ r₂) (q : TRPath R r₂ r₃) :
    TRPath R (.app l r₁) (.app l r₃) :=
  TRPath.trans (TRPath.congrR l p) (TRPath.congrR l q)

/-- Theorem 15: congrL distributes over symm. -/
theorem tr_congrL_symm {R : TRTRS} (r : TRTm) (p : TRPath R l l') :
    TRPath R (.app l' r) (.app l r) :=
  TRPath.congrL (TRPath.symm p) r

/-- Theorem 16: congrR distributes over symm. -/
theorem tr_congrR_symm {R : TRTRS} (l : TRTm) (p : TRPath R r r') :
    TRPath R (.app l r') (.app l r) :=
  TRPath.congrR l (TRPath.symm p)

/-- Theorem 17: Interchange — independent rewrites on L and R. -/
theorem tr_interchange {R : TRTRS}
    (pl : TRPath R l l') (pr : TRPath R r r') :
    TRPath R (.app l r) (.app l' r') :=
  TRPath.trans (TRPath.congrL pl r) (TRPath.congrR l' pr)

/-- Theorem 18: Interchange alternative order. -/
theorem tr_interchange' {R : TRTRS}
    (pl : TRPath R l l') (pr : TRPath R r r') :
    TRPath R (.app l r) (.app l' r') :=
  TRPath.trans (TRPath.congrR l pr) (TRPath.congrL pl r')

/-- Theorem 19: Nested congrL three deep. -/
theorem tr_congrL_nested₃ {R : TRTRS} (p : TRPath R a b) (r₁ r₂ : TRTm) :
    TRPath R (.app (.app a r₁) r₂) (.app (.app b r₁) r₂) :=
  TRPath.congrL (TRPath.congrL p r₁) r₂

/-- Theorem 20: Nested congrR three deep. -/
theorem tr_congrR_nested₃ {R : TRTRS} (l₁ l₂ : TRTm) (p : TRPath R a b) :
    TRPath R (.app l₁ (.app l₂ a)) (.app l₁ (.app l₂ b)) :=
  TRPath.congrR l₁ (TRPath.congrR l₂ p)

-- ============================================================
-- §9  Whiskering & Zigzag
-- ============================================================

/-- Theorem 21: Left whiskering — prepend a step. -/
theorem tr_whisker_left {R : TRTRS} (s : TRStep R a b) (p : TRPath R b c) :
    TRPath R a c :=
  TRPath.trans (TRPath.step s) p

/-- Theorem 22: Right whiskering — append a step. -/
theorem tr_whisker_right {R : TRTRS} (p : TRPath R a b) (s : TRStep R b c) :
    TRPath R a c :=
  TRPath.trans p (TRPath.step s)

/-- Theorem 23: Zigzag  a ← b → c  gives path a → c. -/
theorem tr_zigzag {R : TRTRS} (p₁ : TRPath R b a) (p₂ : TRPath R b c) :
    TRPath R a c :=
  TRPath.trans (TRPath.symm p₁) p₂

/-- Theorem 24: Co-zigzag  a → b ← c  gives path c → a. -/
theorem tr_co_zigzag {R : TRTRS} (p₁ : TRPath R a b) (p₂ : TRPath R c b) :
    TRPath R c a :=
  TRPath.trans p₂ (TRPath.symm p₁)

/-- Theorem 25: Diamond from four paths meeting at center. -/
theorem tr_diamond {R : TRTRS}
    (p₁ : TRPath R a b) (p₂ : TRPath R a c)
    (p₃ : TRPath R b d) (p₄ : TRPath R c d) :
    TRPath R a d :=
  TRPath.trans p₁ p₃

-- ============================================================
-- §10  Position & Context Theorems
-- ============================================================

/-- Theorem 26: atPos root returns the term. -/
theorem tr_atPos_root (t : TRTm) : t.atPos [] = some t := by
  cases t <;> rfl

/-- Theorem 27: replaceAt root replaces whole term. -/
theorem tr_replaceAt_root (t s : TRTm) : t.replaceAt [] s = s := by
  cases t <;> rfl

/-- Theorem 28: atPos through left child of app. -/
theorem tr_atPos_app_left (l r : TRTm) (p : TRPos) :
    (TRTm.app l r).atPos (TRDir.L :: p) = l.atPos p := by
  simp [TRTm.atPos]

/-- Theorem 29: atPos through right child of app. -/
theorem tr_atPos_app_right (l r : TRTm) (p : TRPos) :
    (TRTm.app l r).atPos (TRDir.R :: p) = r.atPos p := by
  simp [TRTm.atPos]

/-- Theorem 30: replaceAt left child of app at depth 1. -/
theorem tr_replaceAt_app_left (l r s : TRTm) :
    (TRTm.app l r).replaceAt [TRDir.L] s = .app s r := by
  simp [TRTm.replaceAt]

/-- Theorem 31: replaceAt right child of app at depth 1. -/
theorem tr_replaceAt_app_right (l r s : TRTm) :
    (TRTm.app l r).replaceAt [TRDir.R] s = .app l s := by
  simp [TRTm.replaceAt]

/-- Theorem 32: plug hole yields the plugged term. -/
theorem tr_plug_hole (t : TRTm) : trPlug trHole t = t := by
  simp [trPlug, trHole, trHoleIdx]

/-- Theorem 33: plug constant ignores the argument. -/
theorem tr_plug_const (c : String) (t : TRTm) :
    trPlug (.const c) t = .const c := rfl

-- ============================================================
-- §11  Substitution Algebra
-- ============================================================

/-- Theorem 34: Identity substitution is identity. -/
theorem tr_applyS_id : ∀ t : TRTm, t.applyS TRSubst.id = t := by
  intro t; induction t with
  | var _     => rfl
  | const _   => rfl
  | app l r ihl ihr => simp [TRTm.applyS]; exact ⟨ihl, ihr⟩

/-- Theorem 35: Substitution on a constant is identity. -/
theorem tr_applyS_const (σ : TRSubst) (c : String) :
    (TRTm.const c).applyS σ = .const c := rfl

/-- Theorem 36: Substitution distributes over app. -/
theorem tr_applyS_app (σ : TRSubst) (l r : TRTm) :
    (TRTm.app l r).applyS σ = .app (l.applyS σ) (r.applyS σ) := rfl

/-- Theorem 37: single substitution hits the target variable. -/
theorem tr_applyS_single_hit (x : Nat) (t : TRTm) :
    (TRTm.var x).applyS (TRSubst.single x t) = t := by
  simp [TRTm.applyS, TRSubst.single]

/-- Theorem 38: single substitution misses other variables. -/
theorem tr_applyS_single_miss (x y : Nat) (t : TRTm) (h : ¬(y == x) = true) :
    (TRTm.var y).applyS (TRSubst.single x t) = .var y := by
  simp [TRTm.applyS, TRSubst.single, h]

-- ============================================================
-- §12  Size & Depth Theorems
-- ============================================================

/-- Theorem 39: Size is always positive. -/
theorem tr_size_pos : ∀ t : TRTm, 0 < t.size := by
  intro t; cases t <;> simp [TRTm.size] <;> omega

/-- Theorem 40: app strictly larger than left child. -/
theorem tr_size_app_left (l r : TRTm) : l.size < (TRTm.app l r).size := by
  simp [TRTm.size]; omega

/-- Theorem 41: app strictly larger than right child. -/
theorem tr_size_app_right (l r : TRTm) : r.size < (TRTm.app l r).size := by
  simp [TRTm.size]; omega

/-- Theorem 42: depth of app ≥ 1. -/
theorem tr_depth_app (l r : TRTm) : 0 < (TRTm.app l r).depth := by
  simp [TRTm.depth]; omega

-- ============================================================
-- §13  Multi-Step Reduction (Prop)
-- ============================================================

inductive TRMStep (R : TRTRS) : TRTm → TRTm → Prop where
  | refl : (t : TRTm) → TRMStep R t t
  | cons : TRStep R a b → TRMStep R b c → TRMStep R a c

/-- Theorem 43: MStep is transitive. -/
theorem TRMStep.append {R : TRTRS} {a b c : TRTm}
    (m₁ : TRMStep R a b) (m₂ : TRMStep R b c) : TRMStep R a c := by
  induction m₁ with
  | refl _ => exact m₂
  | cons s _ ih => exact TRMStep.cons s (ih m₂)

/-- Theorem 44: MStep embeds into Path. -/
theorem TRMStep.toPath {R : TRTRS} {a b : TRTm}
    (m : TRMStep R a b) : TRPath R a b := by
  induction m with
  | refl t => exact TRPath.refl t
  | cons s _ ih => exact TRPath.trans (TRPath.step s) ih

/-- Theorem 45: Single step → MStep. -/
theorem TRStep.toMStep {R : TRTRS} (s : TRStep R a b) :
    TRMStep R a b :=
  TRMStep.cons s (TRMStep.refl b)

/-- Theorem 46: MStep lifts through congrL. -/
theorem TRMStep.liftCongrL {R : TRTRS}
    (m : TRMStep R l l') (r : TRTm) :
    TRPath R (.app l r) (.app l' r) := by
  induction m with
  | refl _ => exact TRPath.refl _
  | cons s _ ih => exact TRPath.trans (TRPath.congrL (TRPath.step s) r) ih

/-- Theorem 47: MStep lifts through congrR. -/
theorem TRMStep.liftCongrR {R : TRTRS} (l : TRTm)
    (m : TRMStep R r r') :
    TRPath R (.app l r) (.app l r') := by
  induction m with
  | refl _ => exact TRPath.refl _
  | cons s _ ih => exact TRPath.trans (TRPath.congrR l (TRPath.step s)) ih

-- ============================================================
-- §14  Joinability & Confluence
-- ============================================================

noncomputable def TRJoinable (R : TRTRS) (a b : TRTm) : Prop :=
  ∃ c, TRMStep R a c ∧ TRMStep R b c

noncomputable def TRConfluent (R : TRTRS) : Prop :=
  ∀ a b c, TRMStep R a b → TRMStep R a c → TRJoinable R b c

noncomputable def TRLocallyConfluent (R : TRTRS) : Prop :=
  ∀ a b c, TRStep R a b → TRStep R a c → TRJoinable R b c

/-- Theorem 48: Joinability is reflexive. -/
theorem TRJoinable.refl (R : TRTRS) (t : TRTm) : TRJoinable R t t :=
  ⟨t, TRMStep.refl t, TRMStep.refl t⟩

/-- Theorem 49: Joinability is symmetric. -/
theorem TRJoinable.symm' {R : TRTRS} (h : TRJoinable R a b) :
    TRJoinable R b a :=
  let ⟨c, ha, hb⟩ := h; ⟨c, hb, ha⟩

/-- Theorem 50: Joinable terms connect via path. -/
theorem TRJoinable.toPath {R : TRTRS} (h : TRJoinable R a b) :
    TRPath R a b :=
  let ⟨c, ha, hb⟩ := h
  TRPath.trans ha.toPath (TRPath.symm hb.toPath)

-- ============================================================
-- §15  Normal Forms
-- ============================================================

noncomputable def TRNF (R : TRTRS) (t : TRTm) : Prop := ∀ t', ¬ TRStep R t t'

/-- Theorem 51: NF has only trivial self-path. -/
theorem TRNF.self_path {R : TRTRS} (hnf : TRNF R t) :
    TRPath R t t :=
  TRPath.refl t

-- ============================================================
-- §16  Termination & Newman's Lemma
-- ============================================================

noncomputable def TRTerminating (R : TRTRS) : Prop :=
  WellFounded (fun b a => TRStep R a b)

/-- Theorem 52: Newman's lemma. -/
theorem tr_newman {R : TRTRS} (hWF : TRTerminating R)
    (hLC : TRLocallyConfluent R) : TRConfluent R := by
  intro a
  apply hWF.induction (C := fun a => ∀ b c,
    TRMStep R a b → TRMStep R a c → TRJoinable R b c)
  intro a ihA b c hab hac
  match hab, hac with
  | .refl _, hac => exact ⟨c, hac, .refl c⟩
  | hab, .refl _ => exact ⟨b, .refl b, hab⟩
  | .cons s₁ m₁, .cons s₂ m₂ =>
    obtain ⟨d, hbd, hcd⟩ := hLC a _ _ s₁ s₂
    obtain ⟨e, hbe, hde⟩ := ihA _ s₁ b d m₁ hbd
    obtain ⟨f, hcf, hef⟩ := ihA _ s₂ c e m₂ (TRMStep.append hcd hde)
    exact ⟨f, TRMStep.append hbe hef, hcf⟩

-- ============================================================
-- §17  Critical Pairs
-- ============================================================

structure TRCriticalPair where
  left  : TRTm
  right : TRTm
deriving DecidableEq, Repr

structure TRCPWitness (R : TRTRS) where
  rule₁   : TRRule
  rule₂   : TRRule
  pos     : TRPos
  unifier : TRSubst
  hmem₁   : rule₁ ∈ R
  hmem₂   : rule₂ ∈ R
  cp      : TRCriticalPair

/-- Theorem 53: Trivial CP is joinable. -/
theorem tr_trivial_cp_joinable (R : TRTRS) (t : TRTm) :
    TRJoinable R t t :=
  TRJoinable.refl R t

/-- Theorem 54: Joinable CP gives a path. -/
theorem tr_cp_joinable_path {R : TRTRS} {cp : TRCriticalPair}
    (h : TRJoinable R cp.left cp.right) : TRPath R cp.left cp.right :=
  h.toPath

/-- All critical pairs joinable. -/
noncomputable def TRAllCPJoinable (R : TRTRS) (cps : List TRCriticalPair) : Prop :=
  ∀ cp, cp ∈ cps → TRJoinable R cp.left cp.right

/-- Theorem 55: Empty CP list trivially joinable. -/
theorem tr_all_cp_joinable_empty (R : TRTRS) : TRAllCPJoinable R [] :=
  fun _ h => by cases h

-- ============================================================
-- §18  Reduction Orderings
-- ============================================================

noncomputable def TRPrec := String → Nat

noncomputable def trSizeLt (s t : TRTm) : Prop := s.size < t.size

/-- Theorem 56: sizeLt is well-founded. -/
theorem tr_sizeLt_wf : WellFounded trSizeLt :=
  InvImage.wf TRTm.size Nat.lt_wfRel.wf

-- ============================================================
-- §19  Completion (Knuth-Bendix skeleton)
-- ============================================================

structure TREquation where
  lhs : TRTm
  rhs : TRTm
deriving DecidableEq, Repr

structure TRCompState where
  rules : TRTRS
  eqs   : List TREquation
deriving Repr

noncomputable def trOrient (eq : TREquation) : Option TRRule :=
  if eq.lhs.size > eq.rhs.size then some ⟨eq.lhs, eq.rhs⟩
  else if eq.rhs.size > eq.lhs.size then some ⟨eq.rhs, eq.lhs⟩
  else none

noncomputable def trCompletionStep (st : TRCompState) : TRCompState :=
  match st.eqs with
  | []       => st
  | eq :: rest =>
    match trOrient eq with
    | some r => ⟨r :: st.rules, rest⟩
    | none   => ⟨st.rules, rest ++ [eq]⟩

/-- Theorem 57: Completion on empty equations is idempotent. -/
theorem tr_completion_empty (rs : TRTRS) :
    trCompletionStep ⟨rs, []⟩ = ⟨rs, []⟩ := by
  simp [trCompletionStep]

-- ============================================================
-- §20  Transport: Paths Lift Through Substitution
-- ============================================================

/-- Theorem 58: Pointwise-connected substitutions yield connected results. -/
theorem tr_transport_subst {R : TRTRS} (σ σ' : TRSubst)
    (hσ : ∀ n, TRPath R (σ n) (σ' n))
    (t : TRTm) : TRPath R (t.applyS σ) (t.applyS σ') := by
  induction t with
  | var n     => exact hσ n
  | const _   => exact TRPath.refl _
  | app l r ihl ihr =>
    simp [TRTm.applyS]
    exact tr_interchange ihl ihr

/-- Theorem 59: subst id is path-equivalent to original. -/
theorem tr_transport_id {R : TRTRS} (t : TRTm) :
    TRPath R (t.applyS TRSubst.id) t := by
  rw [tr_applyS_id]; exact TRPath.refl t

-- ============================================================
-- §21  Narrowing
-- ============================================================

structure TRNarrowStep (R : TRTRS) (t t' : TRTm) where
  rule  : TRRule
  pos   : TRPos
  unif  : TRSubst
  hmem  : rule ∈ R
  hat   : t.atPos pos = some (rule.lhs.applyS unif)
  result : t' = (t.applyS unif).replaceAt pos (rule.rhs.applyS unif)

/-- Theorem 60: Narrow step refl gives a self-path. -/
theorem tr_narrow_refl {R : TRTRS} (t : TRTm) : TRPath R t t :=
  TRPath.refl t

-- ============================================================
-- §22  Concrete Example: {f(x) → x}
-- ============================================================

private noncomputable def v0 : TRTm := .var 0
private noncomputable def cA : TRTm := .const "a"
private noncomputable def cB : TRTm := .const "b"
private noncomputable def cF : TRTm := .const "f"

private noncomputable def ruleF : TRRule := ⟨.app cF v0, v0⟩
private noncomputable def exTRS : TRTRS := [ruleF]

private noncomputable def σA : TRSubst := fun n => if n == 0 then cA else .var n

/-- Theorem 61: f(a) rewrites to a. -/
theorem tr_ex_fA_to_a : TRStep exTRS (.app cF cA) cA :=
  TRStep.ruleAt ruleF σA [] (.app cF cA)
    (List.Mem.head _)
    (by simp [TRTm.atPos, TRTm.applyS, σA, ruleF, cF, cA, v0])
    cA
    (by simp [TRTm.replaceAt, TRTm.applyS, σA, ruleF, cA, v0])

/-- Theorem 62: Path from f(a) to a. -/
theorem tr_ex_path_fA : TRPath exTRS (.app cF cA) cA :=
  TRPath.step tr_ex_fA_to_a

/-- Theorem 63: Path from f(f(a)) to a — two-step trans chain. -/
theorem tr_ex_path_ffA : TRPath exTRS (.app cF (.app cF cA)) cA :=
  TRPath.trans
    (TRPath.congrR cF tr_ex_path_fA)
    tr_ex_path_fA

/-- Theorem 64: Path from f(f(f(a))) to a — three-step trans chain. -/
theorem tr_ex_path_fffA :
    TRPath exTRS (.app cF (.app cF (.app cF cA))) cA :=
  TRPath.trans
    (TRPath.congrR cF (TRPath.congrR cF tr_ex_path_fA))
    (TRPath.trans (TRPath.congrR cF tr_ex_path_fA) tr_ex_path_fA)

/-- Theorem 65: Loop f(a) → a → f(a) via symm. -/
theorem tr_ex_loop_fA : TRPath exTRS (.app cF cA) (.app cF cA) :=
  TRPath.trans tr_ex_path_fA (TRPath.symm tr_ex_path_fA)

/-- Theorem 66: congrL lifts f(a)→a into app(·,b) context. -/
theorem tr_ex_congrL_lift :
    TRPath exTRS (.app (.app cF cA) cB) (.app cA cB) :=
  TRPath.congrL tr_ex_path_fA cB

/-- Theorem 67: Interchange — f(a)→a on both sides of app. -/
theorem tr_ex_interchange :
    TRPath exTRS (.app (.app cF cA) (.app cF cA)) (.app cA cA) :=
  tr_interchange tr_ex_path_fA tr_ex_path_fA

/-- Theorem 68: Deep round trip — f(f(f(a))) → a → f(f(f(a))). -/
theorem tr_ex_deep_round_trip :
    TRPath exTRS
      (.app cF (.app cF (.app cF cA)))
      (.app cF (.app cF (.app cF cA))) :=
  TRPath.trans tr_ex_path_fffA (TRPath.symm tr_ex_path_fffA)

-- ============================================================
-- §23  Subterm Relation
-- ============================================================

inductive TRSubterm : TRTm → TRTm → Prop where
  | refl  : TRSubterm t t
  | left  : TRSubterm s l → TRSubterm s (.app l r)
  | right : TRSubterm s r → TRSubterm s (.app l r)

/-- Theorem 69: Subterm reflexive. -/
theorem TRSubterm.rfl' (t : TRTm) : TRSubterm t t := TRSubterm.refl

/-- Theorem 70: Subterm transitive. -/
theorem TRSubterm.trans' {a b c : TRTm} (h₁ : TRSubterm a b) (h₂ : TRSubterm b c) :
    TRSubterm a c := by
  induction h₂ with
  | refl => exact h₁
  | left hsub ih => exact TRSubterm.left ih
  | right hsub ih => exact TRSubterm.right ih

/-- Theorem 71: Left child is subterm. -/
theorem tr_subterm_app_left (l r : TRTm) : TRSubterm l (.app l r) :=
  TRSubterm.left TRSubterm.refl

/-- Theorem 72: Right child is subterm. -/
theorem tr_subterm_app_right (l r : TRTm) : TRSubterm r (.app l r) :=
  TRSubterm.right TRSubterm.refl

-- ============================================================
-- §24  Unique Normal Forms Under Confluence
-- ============================================================

/-- Theorem 73: Under confluence, NFs from the same source are equal. -/
theorem tr_nf_unique {R : TRTRS} (hConf : TRConfluent R)
    {a b c : TRTm} (hab : TRMStep R a b) (hac : TRMStep R a c)
    (hnfb : TRNF R b) (hnfc : TRNF R c) : b = c := by
  obtain ⟨d, hbd, hcd⟩ := hConf a b c hab hac
  have hbeq : b = d := by
    cases hbd with
    | refl _ => rfl
    | cons s _ => exact absurd s (hnfb _)
  have hceq : c = d := by
    cases hcd with
    | refl _ => rfl
    | cons s _ => exact absurd s (hnfc _)
  rw [hbeq, hceq]

-- ============================================================
-- §25  Church-Rosser
-- ============================================================

noncomputable def TRChurchRosser (R : TRTRS) : Prop :=
  ∀ a b, TRPath R a b → TRJoinable R a b

/-- Theorem 74: Confluence implies CR for steps. -/
theorem tr_confluent_cr_step {R : TRTRS} (hConf : TRConfluent R)
    (s : TRStep R a b) : TRJoinable R a b :=
  ⟨b, s.toMStep, TRMStep.refl b⟩

/-- Theorem 75: Confluence implies joinability for multi-steps. -/
theorem tr_confluent_join {R : TRTRS} (hConf : TRConfluent R)
    (m₁ : TRMStep R a b) (m₂ : TRMStep R a c) : TRJoinable R b c :=
  hConf a b c m₁ m₂

-- ============================================================
-- §26  Convergent TRS
-- ============================================================

noncomputable def TRConvergent (R : TRTRS) : Prop :=
  TRTerminating R ∧ TRConfluent R

/-- Theorem 76: Convergent ⟹ unique NFs. -/
theorem tr_convergent_unique_nf {R : TRTRS} (hConv : TRConvergent R)
    {a b c : TRTm} (hab : TRMStep R a b) (hac : TRMStep R a c)
    (hnfb : TRNF R b) (hnfc : TRNF R c) : b = c :=
  tr_nf_unique hConv.2 hab hac hnfb hnfc

/-- Theorem 77: Terminating + locally confluent ⟹ convergent. -/
theorem tr_convergent_from_local {R : TRTRS}
    (hT : TRTerminating R) (hLC : TRLocallyConfluent R) :
    TRConvergent R :=
  ⟨hT, tr_newman hT hLC⟩

-- ============================================================
-- §27  Occurs Check
-- ============================================================

/-- Theorem 78: Variable occurs in itself. -/
theorem tr_occurs_self (x : Nat) : (TRTm.var x).occurs x = true := by
  simp [TRTm.occurs]

/-- Theorem 79: Variable doesn't occur in different var. -/
theorem tr_occurs_diff (x y : Nat) (h : x ≠ y) :
    (TRTm.var y).occurs x = false := by
  simp [TRTm.occurs]; omega

/-- Theorem 80: Variable doesn't occur in constant. -/
theorem tr_occurs_const (x : Nat) (c : String) :
    (TRTm.const c).occurs x = false := rfl

/-- Theorem 81: occurs distributes over app. -/
theorem tr_occurs_app (x : Nat) (l r : TRTm) :
    (TRTm.app l r).occurs x = (l.occurs x || r.occurs x) := rfl

-- ============================================================
-- §28  Idempotent Substitutions
-- ============================================================

noncomputable def TRSubst.idempotent (σ : TRSubst) : Prop :=
  ∀ t : TRTm, (t.applyS σ).applyS σ = t.applyS σ

/-- Theorem 82: Identity substitution is idempotent. -/
theorem TRSubst.id_idempotent : TRSubst.idempotent TRSubst.id := by
  intro t; simp [tr_applyS_id]

-- ============================================================
-- §29  Completion Invariant
-- ============================================================

noncomputable def TRCompInvariant (R : TRTRS) (eqs : List TREquation) : Prop :=
  ∀ eq, eq ∈ eqs → TRJoinable R eq.lhs eq.rhs

/-- Theorem 83: Adding joinable equation preserves invariant. -/
theorem tr_invariant_extend {R : TRTRS}
    (hInv : TRCompInvariant R eqs) (hNew : TRJoinable R eq.lhs eq.rhs) :
    TRCompInvariant R (eq :: eqs) := by
  intro e hmem
  cases hmem with
  | head => exact hNew
  | tail _ h => exact hInv e h

/-- Theorem 84: Empty equation list is trivially invariant. -/
theorem tr_invariant_empty (R : TRTRS) : TRCompInvariant R [] :=
  fun _ h => by cases h

-- ============================================================
-- §30  Multi-Step Congruence Chains
-- ============================================================

/-- Theorem 85: Five-level nested congruence. -/
theorem tr_congr_chain₅ {R : TRTRS}
    (p : TRPath R a b) (c₁ c₂ c₃ c₄ : TRTm) :
    TRPath R (.app c₁ (.app c₂ (.app c₃ (.app c₄ a))))
           (.app c₁ (.app c₂ (.app c₃ (.app c₄ b)))) :=
  TRPath.congrR c₁ (TRPath.congrR c₂ (TRPath.congrR c₃ (TRPath.congrR c₄ p)))

/-- Theorem 86: Mixed congruence — left at top, right nested. -/
theorem tr_congr_mixed {R : TRTRS}
    (p₁ : TRPath R a₁ b₁) (p₂ : TRPath R a₂ b₂) (c : TRTm) :
    TRPath R (.app (.app a₁ c) a₂) (.app (.app b₁ c) b₂) :=
  TRPath.trans
    (TRPath.congrL (TRPath.congrL p₁ c) a₂)
    (TRPath.congrR (.app b₁ c) p₂)

/-- Theorem 87: Symmetric mixed congruence. -/
theorem tr_congr_mixed_symm {R : TRTRS}
    (p₁ : TRPath R a₁ b₁) (p₂ : TRPath R a₂ b₂) (c : TRTm) :
    TRPath R (.app (.app b₁ c) b₂) (.app (.app a₁ c) a₂) :=
  TRPath.symm (tr_congr_mixed p₁ p₂ c)

/-- Theorem 88: Loop via nested interchange + symm. -/
theorem tr_congr_loop {R : TRTRS}
    (p₁ : TRPath R a b) (p₂ : TRPath R c d) (e : TRTm) :
    TRPath R (.app (.app a e) c) (.app (.app a e) c) :=
  TRPath.trans
    (tr_congr_mixed p₁ p₂ e)
    (TRPath.symm (tr_congr_mixed p₁ p₂ e))

/-- Theorem 89: Double interchange in nested context. -/
theorem tr_double_interchange {R : TRTRS}
    (p₁ : TRPath R a₁ b₁) (p₂ : TRPath R a₂ b₂)
    (p₃ : TRPath R a₃ b₃) :
    TRPath R (.app (.app a₁ a₂) a₃) (.app (.app b₁ b₂) b₃) :=
  TRPath.trans
    (TRPath.congrL (tr_interchange p₁ p₂) a₃)
    (TRPath.congrR (.app b₁ b₂) p₃)

-- ============================================================
-- §31  Deep Chain Theorems
-- ============================================================

/-- Theorem 90: Six-fold trans. -/
theorem trpath_trans₆ {R : TRTRS}
    (p₁ : TRPath R t₁ t₂) (p₂ : TRPath R t₂ t₃)
    (p₃ : TRPath R t₃ t₄) (p₄ : TRPath R t₄ t₅)
    (p₅ : TRPath R t₅ t₆) (p₆ : TRPath R t₆ t₇) :
    TRPath R t₁ t₇ :=
  TRPath.trans p₁
    (TRPath.trans p₂
      (TRPath.trans p₃
        (TRPath.trans p₄
          (TRPath.trans p₅ p₆))))

/-- Theorem 91: Seven-fold trans. -/
theorem trpath_trans₇ {R : TRTRS}
    (p₁ : TRPath R t₁ t₂) (p₂ : TRPath R t₂ t₃)
    (p₃ : TRPath R t₃ t₄) (p₄ : TRPath R t₄ t₅)
    (p₅ : TRPath R t₅ t₆) (p₆ : TRPath R t₆ t₇)
    (p₇ : TRPath R t₇ t₈) : TRPath R t₁ t₈ :=
  TRPath.trans p₁
    (TRPath.trans p₂
      (TRPath.trans p₃
        (TRPath.trans p₄
          (TRPath.trans p₅
            (TRPath.trans p₆ p₇)))))

/-- Theorem 92: Zigzag-interchange. -/
theorem tr_zigzag_interchange {R : TRTRS}
    (p₁ : TRPath R b a) (p₂ : TRPath R b c)
    (q₁ : TRPath R e d) (q₂ : TRPath R e f) :
    TRPath R (.app a d) (.app c f) :=
  tr_interchange (tr_zigzag p₁ p₂) (tr_zigzag q₁ q₂)

-- ============================================================
-- §32  Residuals & Disjoint Redexes
-- ============================================================

structure TRRedex (R : TRTRS) where
  rule : TRRule
  pos  : TRPos
  σ    : TRSubst
  hmem : rule ∈ R

noncomputable def TRRedex.disjoint (r₁ r₂ : TRRedex R) : Prop :=
  ¬ r₁.pos.isPrefixOf r₂.pos ∧ ¬ r₂.pos.isPrefixOf r₁.pos

/-- Theorem 93: Disjoint redex diamond — two independent steps close. -/
theorem tr_disjoint_diamond {R : TRTRS}
    (s₁ : TRStep R a b) (s₂ : TRStep R a c)
    (p₁ : TRPath R b d) (p₂ : TRPath R c d) :
    TRPath R a d :=
  TRPath.trans (TRPath.step s₁) p₁

/-- Theorem 94: Development embeds as path. -/
theorem tr_development_path {R : TRTRS} (ms : TRMStep R a b) :
    TRPath R a b := ms.toPath

-- ============================================================
-- §33  Parallel Moves
-- ============================================================

/-- Theorem 95: Parallel app rewrite. -/
theorem tr_parallel_app {R : TRTRS}
    (p : TRPath R l l') (q : TRPath R r r') :
    TRPath R (.app l r) (.app l' r') :=
  tr_interchange p q

/-- Theorem 96: Three-argument parallel rewrite. -/
theorem tr_parallel_app₃ {R : TRTRS}
    (p₁ : TRPath R a₁ b₁) (p₂ : TRPath R a₂ b₂)
    (p₃ : TRPath R a₃ b₃) :
    TRPath R (.app (.app a₁ a₂) a₃) (.app (.app b₁ b₂) b₃) :=
  tr_double_interchange p₁ p₂ p₃

-- ============================================================
-- §34  Rewriting Modulo
-- ============================================================

abbrev TREqTheory := List TREquation

structure TRModStep (R : TRTRS) (E : TREqTheory) (a b : TRTm) where
  mid    : TRTm
  rwStep : TRStep R a mid

/-- Theorem 97: Mod-step yields a path to mid. -/
theorem tr_modstep_path {R : TRTRS} {E : TREqTheory}
    (ms : TRModStep R E a b) : TRPath R a ms.mid :=
  TRPath.step ms.rwStep

-- ============================================================
-- §35  Rule Composition & Conjugation
-- ============================================================

/-- Theorem 98: Two steps compose into a path. -/
theorem tr_rule_compose {R : TRTRS}
    (s₁ : TRStep R a b) (s₂ : TRStep R b c) : TRPath R a c :=
  TRPath.trans (TRPath.step s₁) (TRPath.step s₂)

/-- Theorem 99: Three steps compose. -/
theorem tr_rule_compose₃ {R : TRTRS}
    (s₁ : TRStep R a b) (s₂ : TRStep R b c) (s₃ : TRStep R c d) :
    TRPath R a d :=
  TRPath.trans (TRPath.step s₁)
    (TRPath.trans (TRPath.step s₂) (TRPath.step s₃))

/-- Theorem 100: Conjugation — s₂⁻¹ ∘ s₁ ∘ p. -/
theorem tr_conjugate {R : TRTRS}
    (s₁ : TRStep R a b) (p : TRPath R b c) (s₂ : TRStep R a d) :
    TRPath R d c :=
  TRPath.trans (TRPath.symm (TRPath.step s₂))
    (TRPath.trans (TRPath.step s₁) p)

-- ============================================================
-- §36  replaceAt + atPos roundtrip
-- ============================================================

/-- Theorem 101: replaceAt root then atPos root is the replacement. -/
theorem tr_replaceAt_atPos_root (t s : TRTm) :
    (t.replaceAt [] s).atPos [] = some s := by
  cases t <;> simp [TRTm.replaceAt, TRTm.atPos]

/-- Theorem 102: Double replacement at root = last one wins. -/
theorem tr_replaceAt_twice_root (t s₁ s₂ : TRTm) :
    (t.replaceAt [] s₁).replaceAt [] s₂ = t.replaceAt [] s₂ := by
  cases t <;> simp [TRTm.replaceAt]

-- ============================================================
-- §37  Concrete Chain: f⁴(a) → a
-- ============================================================

/-- Theorem 103: Four nested applications f(f(f(f(a)))) → a. -/
theorem tr_ex_path_f4A :
    TRPath exTRS
      (.app cF (.app cF (.app cF (.app cF cA)))) cA :=
  TRPath.trans
    (TRPath.congrR cF (TRPath.congrR cF (TRPath.congrR cF tr_ex_path_fA)))
    (TRPath.trans
      (TRPath.congrR cF (TRPath.congrR cF tr_ex_path_fA))
      (TRPath.trans
        (TRPath.congrR cF tr_ex_path_fA)
        tr_ex_path_fA))

/-- Theorem 104: Parallel in nested app: both branches reduce. -/
theorem tr_ex_nested_parallel :
    TRPath exTRS
      (.app (.app cF cA) (.app cF (.app cF cA)))
      (.app cA cA) :=
  tr_interchange tr_ex_path_fA tr_ex_path_ffA

-- ============================================================
-- §38  Confluence implies LC
-- ============================================================

/-- Theorem 105: Confluent ⟹ locally confluent. -/
theorem tr_confluent_implies_lc {R : TRTRS} (hConf : TRConfluent R) :
    TRLocallyConfluent R :=
  fun a b c sb sc => hConf a b c sb.toMStep sc.toMStep

-- ============================================================
-- §39  NF step contradiction
-- ============================================================

/-- Theorem 106: NF has no outgoing step. -/
theorem TRNF.no_step {R : TRTRS} {t t' : TRTm}
    (hnf : TRNF R t) : ¬ TRStep R t t' :=
  hnf t'

-- ============================================================
-- §40  Path composition with congruence
-- ============================================================

/-- Theorem 107: congrL over three-fold trans. -/
theorem tr_congrL_trans₃ {R : TRTRS} (r : TRTm)
    (p₁ : TRPath R l₁ l₂) (p₂ : TRPath R l₂ l₃)
    (p₃ : TRPath R l₃ l₄) :
    TRPath R (.app l₁ r) (.app l₄ r) :=
  TRPath.trans (TRPath.congrL p₁ r)
    (TRPath.trans (TRPath.congrL p₂ r) (TRPath.congrL p₃ r))

/-- Theorem 108: congrR over three-fold trans. -/
theorem tr_congrR_trans₃ {R : TRTRS} (l : TRTm)
    (p₁ : TRPath R r₁ r₂) (p₂ : TRPath R r₂ r₃)
    (p₃ : TRPath R r₃ r₄) :
    TRPath R (.app l r₁) (.app l r₄) :=
  TRPath.trans (TRPath.congrR l p₁)
    (TRPath.trans (TRPath.congrR l p₂) (TRPath.congrR l p₃))

-- ============================================================
-- End: 108 theorems.  0 sorry.  0 Path.ofEq.  0 admit.
-- ============================================================
