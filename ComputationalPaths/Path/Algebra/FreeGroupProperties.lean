/-
# Free Group Properties

This module records baseline free-group properties needed by later developments:

## Key Results
- `freeGroupOne_is_cyclic`: Nielsen-Schreier base case (F₁ is cyclic).
- `torsionFree_one`: F₁ has no nontrivial torsion.
- `freeGroup_rank_formula_one`: rank formula base case for F₁.
- `figureEightPiOneEquivIntWords`: connect π₁(figure-eight) to free ℤ-words.

The proofs reuse the explicit word normalization in `BouquetN` and the
π₁(S¹) ≃ ℤ equivalence from `CircleStep`.
-/

-- import ComputationalPaths.Path.CompPath.BouquetN  -- TEMPORARILY DISABLED: tactic errors in encode proofs
import ComputationalPaths.Path.CompPath.CircleStep
import ComputationalPaths.Path.CompPath.FigureEightStep
import ComputationalPaths.Path.CompPath.PushoutPaths
-- import ComputationalPaths.Path.Algebra.BouquetFreeGroupOps  -- TEMPORARILY DISABLED: depends on broken BouquetN
import ComputationalPaths.Path.Rewrite.SimpleEquiv

namespace ComputationalPaths
namespace Path
namespace Algebra

open CompPath
open SimpleEquiv

universe u v

/-- Path-based equivalence structure (inverse laws witnessed by `Path`). -/
structure PathSimpleEquiv (α : Type u) (β : Type v) where
  /-- Forward map. -/
  toFun : α → β
  /-- Inverse map. -/
  invFun : β → α
  /-- Inverse after forward map is the identity, as a `Path`. -/
  left_inv : ∀ x : α, Path (invFun (toFun x)) x
  /-- Forward after inverse map is the identity, as a `Path`. -/
  right_inv : ∀ y : β, Path (toFun (invFun y)) y

/-- Convert a `SimpleEquiv` into a `PathSimpleEquiv`. -/
noncomputable def simpleEquivToPathSimpleEquiv {α : Type u} {β : Type v} (e : SimpleEquiv α β) :
    PathSimpleEquiv α β :=
  { toFun := e.toFun
    invFun := e.invFun
    left_inv := fun x => Path.stepChain (e.left_inv x)
    right_inv := fun y => Path.stepChain (e.right_inv y) }

/-! ## Rank bookkeeping -/

/-- Alias for the free group on `n` generators. -/
abbrev FreeGroup (n : Nat) : Type := BouquetFreeGroup n

/-- Rank of the free group on `n` generators. -/
noncomputable def freeGroupRank (n : Nat) : Nat := n

@[simp] theorem freeGroup_rank_zero : freeGroupRank 0 = 0 := rfl
@[simp] theorem freeGroup_rank_one : freeGroupRank 1 = 1 := rfl
@[simp] theorem freeGroup_rank_two : freeGroupRank 2 = 2 := rfl

/-- Rank formula base case: for F₁, the Nielsen-Schreier index formula collapses to 1. -/
noncomputable def freeGroup_rank_formula_one (k : Nat) :
    Path (freeGroupRank 1) (1 + k * (1 - 1)) := by
  exact Path.stepChain (by simp [freeGroupRank])

/-! ## Nielsen-Schreier base case (F₁ is cyclic) -/

/-- The cyclic subgroup of F₁ generated by the standard generator. -/
noncomputable def freeGroupOneCyclic : BouquetFreeGroup 1 → Prop :=
  fun x => ∃ k : Int, x = BouquetFreeGroup.genPow Fin'B.fzero k

/-- `intToFreeGroupOne` agrees with `genPow` at the unique generator. -/
noncomputable def intToFreeGroupOne_eq_genPow (k : Int) :
    Path (intToFreeGroupOne k) (BouquetFreeGroup.genPow Fin'B.fzero k) := by
  by_cases hk : k = 0
  · exact Path.stepChain (by simp [intToFreeGroupOne, BouquetFreeGroup.genPow, hk])
  · exact Path.stepChain (by simp [intToFreeGroupOne, BouquetFreeGroup.genPow, hk])

/-- Nielsen-Schreier base case: every element of F₁ is a power of the generator. -/
noncomputable def freeGroupOne_is_cyclic (x : BouquetFreeGroup 1) :
    freeGroupOneCyclic x := by
  refine Quot.inductionOn x ?_
  intro w
  refine ⟨bouquetWordOnePower w, ?_⟩
  have h :
      Path (Quot.mk (BouquetRel 1) w)
        (intToFreeGroupOne (bouquetWordOnePower w)) :=
    Path.stepChain (bouquetWord_one_equiv_single w)
  have h' :
      Path (intToFreeGroupOne (bouquetWordOnePower w))
        (BouquetFreeGroup.genPow Fin'B.fzero (bouquetWordOnePower w)) :=
    intToFreeGroupOne_eq_genPow (bouquetWordOnePower w)
  exact (Path.trans h h').toEq

/-! ## Word/quotient arithmetic for F₁ -/

theorem bouquetWordOnePower_concat (w₁ w₂ : BouquetWord 1) :
    bouquetWordOnePower (BouquetWord.wordConcat w₁ w₂) =
      bouquetWordOnePower w₁ + bouquetWordOnePower w₂ := by
  induction w₁ with
  | nil =>
      simp [BouquetWord.wordConcat, bouquetWordOnePower]
  | cons l rest ih =>
      simp [BouquetWord.wordConcat, bouquetWordOnePower, ih, Int.add_assoc]

theorem freeGroupOneToInt_mul (x y : BouquetFreeGroup 1) :
    freeGroupOneToInt (BouquetFreeGroup.mul x y) =
      freeGroupOneToInt x + freeGroupOneToInt y := by
  induction x using Quot.ind with
  | _ w₁ =>
      induction y using Quot.ind with
      | _ w₂ =>
          simp [BouquetFreeGroup.mul, freeGroupOneToInt, bouquetWordOnePower_concat]

theorem int_ofNat_mul_succ (k : Nat) (z : Int) :
    (Int.ofNat (Nat.succ k)) * z =
      (Int.ofNat k) * z + z := by
  calc
    (Int.ofNat (Nat.succ k)) * z = (Int.ofNat k + 1) * z := by
      simp
    _ = (Int.ofNat k) * z + 1 * z := by
      simp [Int.add_mul]
    _ = (Int.ofNat k) * z + z := by simp

theorem freeGroupOneToInt_pow (x : BouquetFreeGroup 1) (k : Nat) :
    freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x k) =
      (Int.ofNat k) * freeGroupOneToInt x := by
  induction k with
  | zero =>
      simp [freeGroupOneToInt, BouquetFreeGroup.one, bouquetWordOnePower]
  | succ k ih =>
      have hmul :=
        freeGroupOneToInt_mul
          (x := BouquetFreeGroup.pow (n := 1) x k) (y := x)
      calc
        freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x (Nat.succ k))
            = freeGroupOneToInt
                (BouquetFreeGroup.mul (BouquetFreeGroup.pow (n := 1) x k) x) := by
                  rw [BouquetFreeGroup.pow_succ]
        _ = freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x k) +
              freeGroupOneToInt x := by
              exact hmul
        _ = (Int.ofNat k) * freeGroupOneToInt x + freeGroupOneToInt x := by
              rw [ih]
        _ = (Int.ofNat (Nat.succ k)) * freeGroupOneToInt x := by
              symm
              exact int_ofNat_mul_succ k (freeGroupOneToInt x)

/-! ## Torsion-freeness for F₁ -/

noncomputable def TorsionFree (n : Nat) : Type :=
  ∀ x : BouquetFreeGroup n, ∀ k : Nat,
    k > 0 →
      Path (BouquetFreeGroup.pow (n := n) x k) (BouquetFreeGroup.one (n := n)) →
      Path x (BouquetFreeGroup.one (n := n))

noncomputable def torsionFree_zero : TorsionFree 0 := by
  intro x _ _ _
  have hsub : Subsingleton (BouquetFreeGroup 0) := bouquetFreeGroup_zero_subsingleton
  exact Path.stepChain (hsub.elim _ _)

noncomputable def torsionFree_one : TorsionFree 1 := by
  intro x k hk hpow
  have htoInt : (Int.ofNat k) * freeGroupOneToInt x = 0 := by
    calc
      (Int.ofNat k) * freeGroupOneToInt x
          = freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x k) :=
              (freeGroupOneToInt_pow x k).symm
      _ = freeGroupOneToInt (BouquetFreeGroup.one (n := 1)) := by
            rw [hpow.toEq]
      _ = 0 := by
            simp [BouquetFreeGroup.one, freeGroupOneToInt, bouquetWordOnePower]
  have hk' : (Int.ofNat k) ≠ 0 := by
    intro hk0
    have : k = 0 := by
      exact Int.ofNat_eq_zero.mp hk0
    exact (Nat.ne_of_gt hk) this
  have hx : freeGroupOneToInt x = 0 := by
    have hmul := Int.mul_eq_zero.mp htoInt
    cases hmul with
    | inl h =>
        exact (hk' h).elim
    | inr h =>
        exact h
  have hxEq : x = BouquetFreeGroup.one (n := 1) := by
    calc
      x = intToFreeGroupOne (freeGroupOneToInt x) := by
            simpa using (freeGroupOneEquivInt.left_inv x).symm
      _ = intToFreeGroupOne 0 := by simp [hx]
      _ = BouquetFreeGroup.one (n := 1) := by
            simp [intToFreeGroupOne, BouquetFreeGroup.one]
  exact Path.stepChain hxEq

/-! ## Figure-eight and bouquet connections -/

/-- Alias for the figure-eight free group computation. -/
noncomputable def figureEightPiOneEquivFreeGroup'
    [HasWedgeSVKDecodeBijective Circle Circle circleBase circleBase] :
    PathSimpleEquiv FigureEight.FigureEightPiOne FigureEightFreeGroup :=
  simpleEquivToPathSimpleEquiv FigureEight.figureEightPiOneEquivFreeGroup

/-! ## Summary -/

/-
We establish:
1. Rank bookkeeping for free groups (base cases and the rank-1 formula).
2. Nielsen-Schreier base case: F₁ is cyclic via `bouquetWord_one_equiv_single`.
3. Torsion-freeness for F₁ using the F₁ ≃ ℤ equivalence.
4. The figure-eight free group identified with free ℤ-words.
-/

end Algebra
end Path
end ComputationalPaths
