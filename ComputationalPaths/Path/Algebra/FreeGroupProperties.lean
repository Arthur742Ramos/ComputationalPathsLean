/-
# Free Group Properties

This module records baseline free-group properties needed by later developments:

## Key Results
- `freeGroupOne_is_cyclic`: Nielsen-Schreier base case (F₁ is cyclic).
- `torsionFree_one`: F₁ has no nontrivial torsion.
- `freeGroup_rank_formula_one`: rank formula base case for F₁.
- `figureEightPiOneEquivIntWords`: connect π₁(figure-eight) to free ℤ-words.

The proofs reuse the explicit word normalization in `BouquetN` and the
π₁(S¹) ≃ ℤ equivalence from `CircleStep`.
-/

import ComputationalPaths.Path.CompPath.BouquetN
import ComputationalPaths.Path.CompPath.CircleStep
import ComputationalPaths.Path.CompPath.FigureEightStep
import ComputationalPaths.Path.CompPath.PushoutPaths
import ComputationalPaths.Path.Algebra.BouquetFreeGroupOps
import ComputationalPaths.Path.Rewrite.SimpleEquiv

namespace ComputationalPaths
namespace Path
namespace Algebra

open CompPath
open SimpleEquiv

/-! ## Rank bookkeeping -/

/-- Alias for the free group on `n` generators. -/
abbrev FreeGroup (n : Nat) : Type := BouquetFreeGroup n

/-- Rank of the free group on `n` generators. -/
def freeGroupRank (n : Nat) : Nat := n

@[simp] theorem freeGroup_rank_zero : freeGroupRank 0 = 0 := rfl
@[simp] theorem freeGroup_rank_one : freeGroupRank 1 = 1 := rfl
@[simp] theorem freeGroup_rank_two : freeGroupRank 2 = 2 := rfl

/-- Rank formula base case: for F₁, the Nielsen-Schreier index formula collapses to 1. -/
theorem freeGroup_rank_formula_one (k : Nat) :
    freeGroupRank 1 = 1 + k * (1 - 1) := by
  simp [freeGroupRank]

/-! ## Nielsen-Schreier base case (F₁ is cyclic) -/

/-- The cyclic subgroup of F₁ generated by the standard generator. -/
def freeGroupOneCyclic : BouquetFreeGroup 1 → Prop :=
  fun x => ∃ k : Int, x = BouquetFreeGroup.genPow Fin'B.fzero k

/-- `intToFreeGroupOne` agrees with `genPow` at the unique generator. -/
theorem intToFreeGroupOne_eq_genPow (k : Int) :
    intToFreeGroupOne k = BouquetFreeGroup.genPow Fin'B.fzero k := by
  by_cases hk : k = 0
  · simp [intToFreeGroupOne, BouquetFreeGroup.genPow, hk]
  · simp [intToFreeGroupOne, BouquetFreeGroup.genPow, hk]

/-- Nielsen-Schreier base case: every element of F₁ is a power of the generator. -/
theorem freeGroupOne_is_cyclic (x : BouquetFreeGroup 1) :
    freeGroupOneCyclic x := by
  refine Quot.inductionOn x ?_
  intro w
  refine ⟨bouquetWordOnePower w, ?_⟩
  have h := bouquetWord_one_equiv_single w
  have h' :
      intToFreeGroupOne (bouquetWordOnePower w) =
        BouquetFreeGroup.genPow Fin'B.fzero (bouquetWordOnePower w) :=
    intToFreeGroupOne_eq_genPow (bouquetWordOnePower w)
  exact h.trans h'

/-! ## Word/quotient arithmetic for F₁ -/

theorem bouquetWordOnePower_concat (w₁ w₂ : BouquetWord 1) :
    bouquetWordOnePower (BouquetWord.wordConcat w₁ w₂) =
      bouquetWordOnePower w₁ + bouquetWordOnePower w₂ := by
  induction w₁ with
  | nil =>
      simp [BouquetWord.wordConcat, bouquetWordOnePower]
  | cons l rest ih =>
      simp [BouquetWord.wordConcat, bouquetWordOnePower, ih, Int.add_assoc]

theorem freeGroupOneToInt_mul (x y : BouquetFreeGroup 1) :
    freeGroupOneToInt (BouquetFreeGroup.mul x y) =
      freeGroupOneToInt x + freeGroupOneToInt y := by
  induction x using Quot.ind with
  | _ w₁ =>
      induction y using Quot.ind with
      | _ w₂ =>
          simp [BouquetFreeGroup.mul, freeGroupOneToInt, bouquetWordOnePower_concat]

theorem int_ofNat_mul_succ (k : Nat) (z : Int) :
    (Int.ofNat (Nat.succ k)) * z =
      (Int.ofNat k) * z + z := by
  calc
    (Int.ofNat (Nat.succ k)) * z = (Int.ofNat k + 1) * z := by
      simp
    _ = (Int.ofNat k) * z + 1 * z := by
      simp [Int.add_mul]
    _ = (Int.ofNat k) * z + z := by simp

theorem freeGroupOneToInt_pow (x : BouquetFreeGroup 1) (k : Nat) :
    freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x k) =
      (Int.ofNat k) * freeGroupOneToInt x := by
  induction k with
  | zero =>
      simp [freeGroupOneToInt, BouquetFreeGroup.one, bouquetWordOnePower]
  | succ k ih =>
      have hmul :=
        freeGroupOneToInt_mul
          (x := BouquetFreeGroup.pow (n := 1) x k) (y := x)
      calc
        freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x (Nat.succ k))
            = freeGroupOneToInt
                (BouquetFreeGroup.mul (BouquetFreeGroup.pow (n := 1) x k) x) := by
                  rw [BouquetFreeGroup.pow_succ]
        _ = freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x k) +
              freeGroupOneToInt x := by
              exact hmul
        _ = (Int.ofNat k) * freeGroupOneToInt x + freeGroupOneToInt x := by
              rw [ih]
        _ = (Int.ofNat (Nat.succ k)) * freeGroupOneToInt x := by
              symm
              exact int_ofNat_mul_succ k (freeGroupOneToInt x)

/-! ## Torsion-freeness for F₁ -/

def TorsionFree (n : Nat) : Prop :=
  ∀ x : BouquetFreeGroup n, ∀ k : Nat,
    k > 0 → BouquetFreeGroup.pow (n := n) x k = BouquetFreeGroup.one (n := n) →
    x = BouquetFreeGroup.one (n := n)

theorem torsionFree_zero : TorsionFree 0 := by
  intro x _ _ _
  have hsub : Subsingleton (BouquetFreeGroup 0) := bouquetFreeGroup_zero_subsingleton
  exact hsub.elim _ _

theorem torsionFree_one : TorsionFree 1 := by
  intro x k hk hpow
  have htoInt : (Int.ofNat k) * freeGroupOneToInt x = 0 := by
    calc
      (Int.ofNat k) * freeGroupOneToInt x
          = freeGroupOneToInt (BouquetFreeGroup.pow (n := 1) x k) :=
              (freeGroupOneToInt_pow x k).symm
      _ = freeGroupOneToInt (BouquetFreeGroup.one (n := 1)) := by
            rw [hpow]
      _ = 0 := by
            simp [BouquetFreeGroup.one, freeGroupOneToInt, bouquetWordOnePower]
  have hk' : (Int.ofNat k) ≠ 0 := by
    intro hk0
    have : k = 0 := by
      exact Int.ofNat_eq_zero.mp hk0
    exact (Nat.ne_of_gt hk) this
  have hx : freeGroupOneToInt x = 0 := by
    have hmul := Int.mul_eq_zero.mp htoInt
    cases hmul with
    | inl h =>
        exact (hk' h).elim
    | inr h =>
        exact h
  calc
    x = intToFreeGroupOne (freeGroupOneToInt x) := by
          simpa using (freeGroupOneEquivInt.left_inv x).symm
    _ = intToFreeGroupOne 0 := by simp [hx]
    _ = BouquetFreeGroup.one (n := 1) := by
          simp [intToFreeGroupOne, BouquetFreeGroup.one]

/-! ## Figure-eight and bouquet connections -/

/-- Alias for the figure-eight free group computation. -/
noncomputable def figureEightPiOneEquivFreeGroup'
    [HasWedgeSVKDecodeBijective Circle Circle circleBase circleBase] :
    SimpleEquiv FigureEight.FigureEightPiOne FigureEightFreeGroup :=
  FigureEight.figureEightPiOneEquivFreeGroup

/-! ## Summary -/

/-
We establish:
1. Rank bookkeeping for free groups (base cases and the rank-1 formula).
2. Nielsen-Schreier base case: F₁ is cyclic via `bouquetWord_one_equiv_single`.
3. Torsion-freeness for F₁ using the F₁ ≃ ℤ equivalence.
4. The figure-eight free group identified with free ℤ-words.
-/

end Algebra
end Path
end ComputationalPaths
