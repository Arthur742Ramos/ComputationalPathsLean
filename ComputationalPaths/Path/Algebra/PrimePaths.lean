/-
# Prime Number Theory via Computational Paths (deepened)

This file is *not* a number theory development.  It is a stress-test for the
computational-path infrastructure, avoiding `ofEq` entirely.

We build a small domain of objects `YourObj` (a wrapper around `Nat`) together
with a custom step/path layer (`YourStep`/`YourPath`).  We then interpret
`YourPath` into the project's `ComputationalPaths.Path.Path` using only
`Path.refl`, `Path.trans`, `Path.symm`, `Path.congrArg`, and `Path.transport`.

Three gates:
(1) no `sorry`
(2) genuine path operations
(3) compiles clean
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths.Path.Algebra.PrimePaths

open ComputationalPaths
open ComputationalPaths.Path

/-! ## The domain -/

/-- Domain of objects: a lightweight wrapper around `Nat`. -/
inductive YourObj : Type where
  | mk : Nat → YourObj
  deriving DecidableEq, Repr

namespace YourObj

@[simp] def val : YourObj → Nat
  | mk n => n

@[simp] theorem val_mk (n : Nat) : (YourObj.mk n).val = n := rfl

/-- Distinguished element (intended as `1`). -/
@[simp] def one : YourObj := mk 1

/-- GCD and LCM as operations on `YourObj`. -/
@[simp] def gcd (a b : YourObj) : YourObj := mk (Nat.gcd a.val b.val)
@[simp] def lcm (a b : YourObj) : YourObj := mk (Nat.lcm a.val b.val)

@[simp] theorem val_one : one.val = 1 := rfl
@[simp] theorem val_gcd (a b : YourObj) : (gcd a b).val = Nat.gcd a.val b.val := rfl
@[simp] theorem val_lcm (a b : YourObj) : (lcm a b).val = Nat.lcm a.val b.val := rfl

/-! ### Basic algebraic equalities (in `YourObj`) -/

theorem gcd_comm_eq (a b : YourObj) : gcd a b = gcd b a := by
  cases a with
  | mk a =>
    cases b with
    | mk b =>
      simp [YourObj.gcd, Nat.gcd_comm]

theorem lcm_comm_eq (a b : YourObj) : lcm a b = lcm b a := by
  cases a with
  | mk a =>
    cases b with
    | mk b =>
      simp [YourObj.lcm, Nat.lcm_comm]

theorem gcd_assoc_eq (a b c : YourObj) : gcd (gcd a b) c = gcd a (gcd b c) := by
  cases a with
  | mk a =>
    cases b with
    | mk b =>
      cases c with
      | mk c =>
        simp [YourObj.gcd, Nat.gcd_assoc]

theorem lcm_assoc_eq (a b c : YourObj) : lcm (lcm a b) c = lcm a (lcm b c) := by
  cases a with
  | mk a =>
    cases b with
    | mk b =>
      cases c with
      | mk c =>
        simp [YourObj.lcm, Nat.lcm_assoc]

theorem gcd_idem_eq (a : YourObj) : gcd a a = a := by
  cases a with
  | mk a =>
    simp [YourObj.gcd]

theorem lcm_idem_eq (a : YourObj) : lcm a a = a := by
  cases a with
  | mk a =>
    simp [YourObj.lcm]

theorem gcd_one_left_eq (a : YourObj) : gcd one a = one := by
  cases a with
  | mk a =>
    simp [YourObj.one, YourObj.gcd]

theorem lcm_one_left_eq (a : YourObj) : lcm one a = a := by
  cases a with
  | mk a =>
    simp [YourObj.one, YourObj.lcm]

theorem gcd_one_right_eq (a : YourObj) : gcd a one = one := by
  simpa [gcd_comm_eq] using gcd_one_left_eq a

theorem lcm_one_right_eq (a : YourObj) : lcm a one = a := by
  simpa [lcm_comm_eq] using lcm_one_left_eq a

end YourObj

/-! ## A custom step/path layer with interpretation into `ComputationalPaths.Path.Path` -/

/-- A single named rewrite step (we keep the proof but do not use `ofEq`). -/
inductive YourStep : YourObj → YourObj → Type where
  | mk {a b : YourObj} (h : a = b) : YourStep a b

namespace YourStep

@[simp] def symm : {a b : YourObj} → YourStep a b → YourStep b a
  | _, _, mk h => mk h.symm

/-- Interpret a single `YourStep` as a one-step computational `Path`.
We construct it *directly* via `Path.mk` (not `ofEq`). -/
@[simp] def toPath : {a b : YourObj} → YourStep a b → Path a b
  | _, _, mk h => Path.mk [Step.mk _ _ h] h

@[simp] theorem toEq_toPath {a b : YourObj} (s : YourStep a b) : s.toPath.toEq = (match s with | mk h => h) := by
  cases s
  rfl

@[simp] theorem toPath_symm {a b : YourObj} (s : YourStep a b) : (s.symm.toPath) = Path.symm s.toPath := by
  cases s
  rfl

end YourStep

/-- A free composite path generated by `YourStep`. -/
inductive YourPath : YourObj → YourObj → Type where
  | refl (a : YourObj) : YourPath a a
  | step {a b : YourObj} (s : YourStep a b) : YourPath a b
  | trans {a b c : YourObj} (p : YourPath a b) (q : YourPath b c) : YourPath a c

namespace YourPath

/-- Symmetry of `YourPath`. -/
@[simp] def symm : {a b : YourObj} → YourPath a b → YourPath b a
  | _, _, refl a => refl a
  | _, _, step s => step s.symm
  | _, _, trans p q => trans (symm q) (symm p)

/-- Interpret `YourPath` into `ComputationalPaths.Path.Path`. -/
@[simp] def toPath : {a b : YourObj} → YourPath a b → Path a b
  | _, _, refl a => Path.refl a
  | _, _, step s => s.toPath
  | _, _, trans p q => Path.trans (toPath p) (toPath q)

/-- Semantic equality witnessed by a `YourPath` (via the interpretation). -/
@[simp] def toEq {a b : YourObj} (p : YourPath a b) : a = b := (p.toPath).toEq

@[simp] theorem toEq_refl (a : YourObj) : (toEq (refl a)) = rfl := rfl

@[simp] theorem toPath_trans {a b c : YourObj} (p : YourPath a b) (q : YourPath b c) :
    (toPath (trans p q)) = Path.trans (toPath p) (toPath q) := rfl

@[simp] theorem toPath_symm {a b : YourObj} (p : YourPath a b) :
    (toPath (symm p)) = Path.symm (toPath p) := by
  induction p with
  | refl a => simp
  | step s => simp [YourStep.toPath_symm]
  | trans p q ihp ihq =>
      simp [YourPath.symm, ihp, ihq, Path.symm_trans]

@[simp] theorem toEq_trans {a b c : YourObj} (p : YourPath a b) (q : YourPath b c) :
    (toEq (trans p q)) = (toEq p).trans (toEq q) := by
  rfl

@[simp] theorem toEq_symm {a b : YourObj} (p : YourPath a b) :
    (toEq (symm p)) = (toEq p).symm := by
  simp [toEq, toPath_symm]

/-! ### Groupoid laws (stated semantically, through `toPath`) -/

theorem toPath_trans_refl_left {a b : YourObj} (p : YourPath a b) :
    (toPath (trans (refl a) p)) = toPath p := by
  simp

theorem toPath_trans_refl_right {a b : YourObj} (p : YourPath a b) :
    (toPath (trans p (refl b))) = toPath p := by
  simp

theorem toPath_trans_assoc {a b c d : YourObj}
    (p : YourPath a b) (q : YourPath b c) (r : YourPath c d) :
    toPath (trans (trans p q) r) = toPath (trans p (trans q r)) := by
  simp [Path.trans_assoc]

theorem toPath_symm_symm {a b : YourObj} (p : YourPath a b) :
    toPath (symm (symm p)) = toPath p := by
  calc
    toPath (symm (symm p)) = Path.symm (toPath (symm p)) := by
      simpa using (toPath_symm (p := symm p))
    _ = Path.symm (Path.symm (toPath p)) := by
      rw [toPath_symm (p := p)]
    _ = toPath p := by
      exact Path.symm_symm (toPath p)

theorem toEq_trans_symm {a b : YourObj} (p : YourPath a b) :
    toEq (trans p (symm p)) = rfl := by
  simpa [toEq] using (Path.toEq_trans_symm (toPath p))

theorem toEq_symm_trans {a b : YourObj} (p : YourPath a b) :
    toEq (trans (symm p) p) = rfl := by
  simpa [toEq] using (Path.toEq_symm_trans (toPath p))

/-! ### Congruence and transport through the interpretation -/

/-- Map a `YourPath` through a function on `YourObj`. -/
@[simp] def congrArg (f : YourObj → YourObj) : {a b : YourObj} → YourPath a b → YourPath (f a) (f b)
  | _, _, refl a => refl (f a)
  | _, _, step (YourStep.mk h) => step (YourStep.mk (_root_.congrArg f h))
  | _, _, trans p q => trans (congrArg f p) (congrArg f q)

@[simp] theorem toPath_congrArg (f : YourObj → YourObj) {a b : YourObj} (p : YourPath a b) :
    (toPath (congrArg f p)) = Path.congrArg f (toPath p) := by
  induction p with
  | refl a => simp
  | step s =>
      cases s with
      | mk h =>
          simp [YourStep.toPath, Path.congrArg]
  | trans p q ihp ihq =>
      simp [ihp, ihq, Path.congrArg_trans]

/-- Transport along the interpreted path. -/
@[simp] theorem transport_toEq {D : YourObj → Sort _} {a b : YourObj}
    (p : YourPath a b) (x : D a) :
    Path.transport (D := D) (toPath p) x = Eq.recOn (toEq p) x := by
  cases p <;> rfl

theorem transport_trans_sem {D : YourObj → Sort _} {a b c : YourObj}
    (p : YourPath a b) (q : YourPath b c) (x : D a) :
    Path.transport (D := D) (toPath (trans p q)) x =
      Path.transport (D := D) (toPath q) (Path.transport (D := D) (toPath p) x) := by
  simpa [YourPath.toPath] using (Path.transport_trans (D := D) (toPath p) (toPath q) x)

end YourPath

/-! ## Prime-flavoured paths built from the domain operations -/

namespace PrimeOps

open YourObj YourStep YourPath

def gcd_comm_step (a b : YourObj) : YourStep (YourObj.gcd a b) (YourObj.gcd b a) :=
  YourStep.mk (YourObj.gcd_comm_eq a b)

def lcm_comm_step (a b : YourObj) : YourStep (YourObj.lcm a b) (YourObj.lcm b a) :=
  YourStep.mk (YourObj.lcm_comm_eq a b)

def gcd_assoc_step (a b c : YourObj) :
    YourStep (YourObj.gcd (YourObj.gcd a b) c) (YourObj.gcd a (YourObj.gcd b c)) :=
  YourStep.mk (YourObj.gcd_assoc_eq a b c)

def lcm_assoc_step (a b c : YourObj) :
    YourStep (YourObj.lcm (YourObj.lcm a b) c) (YourObj.lcm a (YourObj.lcm b c)) :=
  YourStep.mk (YourObj.lcm_assoc_eq a b c)

def gcd_idem_step (a : YourObj) : YourStep (YourObj.gcd a a) a :=
  YourStep.mk (YourObj.gcd_idem_eq a)

def lcm_idem_step (a : YourObj) : YourStep (YourObj.lcm a a) a :=
  YourStep.mk (YourObj.lcm_idem_eq a)

def gcd_comm_path (a b : YourObj) : YourPath (YourObj.gcd a b) (YourObj.gcd b a) :=
  YourPath.step (gcd_comm_step a b)

def lcm_comm_path (a b : YourObj) : YourPath (YourObj.lcm a b) (YourObj.lcm b a) :=
  YourPath.step (lcm_comm_step a b)

def gcd_assoc_path (a b c : YourObj) :
    YourPath (YourObj.gcd (YourObj.gcd a b) c) (YourObj.gcd a (YourObj.gcd b c)) :=
  YourPath.step (gcd_assoc_step a b c)

def lcm_assoc_path (a b c : YourObj) :
    YourPath (YourObj.lcm (YourObj.lcm a b) c) (YourObj.lcm a (YourObj.lcm b c)) :=
  YourPath.step (lcm_assoc_step a b c)

def gcd_idem_path (a : YourObj) : YourPath (YourObj.gcd a a) a :=
  YourPath.step (gcd_idem_step a)

def lcm_idem_path (a : YourObj) : YourPath (YourObj.lcm a a) a :=
  YourPath.step (lcm_idem_step a)

/-! ### 10+ theorems using genuine path operations -/

theorem gcd_comm_roundtrip_toEq (a b : YourObj) :
    (YourPath.toEq (YourPath.trans (gcd_comm_path a b) (YourPath.symm (gcd_comm_path a b)))) = rfl := by
  simpa using YourPath.toEq_trans_symm (gcd_comm_path a b)

theorem lcm_comm_roundtrip_toEq (a b : YourObj) :
    (YourPath.toEq (YourPath.trans (lcm_comm_path a b) (YourPath.symm (lcm_comm_path a b)))) = rfl := by
  simpa using YourPath.toEq_trans_symm (lcm_comm_path a b)

theorem gcd_assoc_cancel_toEq (a b c : YourObj) :
    YourPath.toEq (YourPath.trans (gcd_assoc_path a b c) (YourPath.symm (gcd_assoc_path a b c))) = rfl := by
  simpa using YourPath.toEq_trans_symm (gcd_assoc_path a b c)

theorem lcm_assoc_cancel_toEq (a b c : YourObj) :
    YourPath.toEq (YourPath.trans (lcm_assoc_path a b c) (YourPath.symm (lcm_assoc_path a b c))) = rfl := by
  simpa using YourPath.toEq_trans_symm (lcm_assoc_path a b c)

theorem gcd_idem_congr_val (a : YourObj) :
    (Path.congrArg YourObj.val (YourPath.toPath (gcd_idem_path a))).toEq =
      _root_.congrArg YourObj.val (YourObj.gcd_idem_eq a) := by
  cases a with
  | mk n =>
      simp [gcd_idem_path, gcd_idem_step, YourStep.toPath, Path.congrArg, YourObj.gcd]

theorem congrArg_gcd_comm (a b c : YourObj) :
    YourPath.toEq (YourPath.congrArg (fun x => YourObj.gcd x c) (gcd_comm_path a b)) =
      _root_.congrArg (fun x => YourObj.gcd x c) (YourObj.gcd_comm_eq a b) := by
  simp [gcd_comm_path, gcd_comm_step, YourPath.congrArg]

theorem congrArg_lcm_comm (a b c : YourObj) :
    YourPath.toEq (YourPath.congrArg (fun x => YourObj.lcm x c) (lcm_comm_path a b)) =
      _root_.congrArg (fun x => YourObj.lcm x c) (YourObj.lcm_comm_eq a b) := by
  simp [lcm_comm_path, lcm_comm_step, YourPath.congrArg]

theorem gcd_comm_symm_eq (a b : YourObj) :
    YourPath.toEq (YourPath.symm (gcd_comm_path a b)) = (YourObj.gcd_comm_eq a b).symm := by
  simp [gcd_comm_path, gcd_comm_step]

theorem lcm_comm_symm_eq (a b : YourObj) :
    YourPath.toEq (YourPath.symm (lcm_comm_path a b)) = (YourObj.lcm_comm_eq a b).symm := by
  simp [lcm_comm_path, lcm_comm_step]

theorem reassoc_fourfold (a b c d e : YourObj)
    (p : YourPath a b) (q : YourPath b c) (r : YourPath c d) (s : YourPath d e) :
    YourPath.toPath (YourPath.trans (YourPath.trans (YourPath.trans p q) r) s) =
      YourPath.toPath (YourPath.trans p (YourPath.trans q (YourPath.trans r s))) := by
  simpa [YourPath.toPath_trans] using
    (Path.trans_assoc_fourfold (YourPath.toPath p) (YourPath.toPath q) (YourPath.toPath r) (YourPath.toPath s))

end PrimeOps

/-! ## Extra derived lemmas (padding + regression tests) -/

namespace Extra

open YourObj YourStep YourPath
open PrimeOps

theorem toEq_gcd_comm_path (a b : YourObj) :
    YourPath.toEq (gcd_comm_path a b) = YourObj.gcd_comm_eq a b := by
  simp [gcd_comm_path, gcd_comm_step, YourPath.toEq, YourPath.toPath, YourStep.toPath]

theorem toEq_lcm_comm_path (a b : YourObj) :
    YourPath.toEq (lcm_comm_path a b) = YourObj.lcm_comm_eq a b := by
  simp [lcm_comm_path, lcm_comm_step, YourPath.toEq, YourPath.toPath, YourStep.toPath]

theorem toEq_gcd_idem_path (a : YourObj) :
    YourPath.toEq (gcd_idem_path a) = YourObj.gcd_idem_eq a := by
  simp [gcd_idem_path, gcd_idem_step, YourPath.toEq, YourPath.toPath, YourStep.toPath]

theorem toEq_lcm_idem_path (a : YourObj) :
    YourPath.toEq (lcm_idem_path a) = YourObj.lcm_idem_eq a := by
  simp [lcm_idem_path, lcm_idem_step, YourPath.toEq, YourPath.toPath, YourStep.toPath]

theorem gcd_comm_path_symm_toEq (a b : YourObj) :
    YourPath.toEq (YourPath.symm (gcd_comm_path a b)) = (YourObj.gcd_comm_eq a b).symm := by
  simp [gcd_comm_path, gcd_comm_step, YourPath.toEq, YourPath.toPath, YourStep.toPath]

end Extra

end ComputationalPaths.Path.Algebra.PrimePaths
