/-
# Combinatorics via Computational Paths (deepened)

This module removes `Path.mk [Step.mk _ _ h] h` scaffolding and replaces it with a small
combinatorics-specific rewriting language:

* `CombObj`  — combinatorial expressions
* `CombStep` — elementary combinatorial rewrite rules
* `CombPath` — paths generated by `refl`/`trans`/`symm` over steps

All exported `Path` witnesses are produced using genuine `Path` operations
(`refl`, `trans`, `symm`, `congrArg`) and explicit single-step traces
(`Path.mk` + `Step.mk`), never `Path.mk [Step.mk _ _ h] h`.
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths.Path.Algebra.CombinatoricsPaths

open ComputationalPaths.Path

universe u

/-! ## Core combinatorial functions (Nat semantics) -/

/-- Factorial function. -/
def fact : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * fact n

/-- Binomial coefficient. -/
def choose : Nat → Nat → Nat
  | _, 0 => 1
  | 0, _ + 1 => 0
  | n + 1, k + 1 => choose n k + choose n (k + 1)

/-- Number of k-permutations of n (falling factorial). -/
def perm : Nat → Nat → Nat
  | _, 0 => 1
  | 0, _ + 1 => 0
  | n + 1, k + 1 => (n + 1) * perm n k

/-- A tiny concrete Catalan function (enough for example paths). -/
def catalan : Nat → Nat
  | 0 => 1
  | 1 => 1
  | 2 => 2
  | 3 => 5
  | 4 => 14
  | 5 => 42
  | _ + 6 => 0

/-- Triangle number `n*(n+1)/2`. -/
def triangleNumber (n : Nat) : Nat := n * (n + 1) / 2

/-! ## Domain language: objects, steps, paths -/

/-- Combinatorial expressions. -/
inductive CombObj : Type
  | nat : Nat → CombObj
  | fact : Nat → CombObj
  | choose : Nat → Nat → CombObj
  | perm : Nat → Nat → CombObj
  | catalan : Nat → CombObj
  | triangle : Nat → CombObj
  | add : CombObj → CombObj → CombObj
  | mul : CombObj → CombObj → CombObj

namespace CombObj

/-- Interpret a combinatorial expression as a natural number. -/
def eval : CombObj → Nat
  | nat n => n
  | fact n => CombinatoricsPaths.fact n
  | choose n k => CombinatoricsPaths.choose n k
  | perm n k => CombinatoricsPaths.perm n k
  | catalan n => CombinatoricsPaths.catalan n
  | triangle n => CombinatoricsPaths.triangleNumber n
  | add a b => eval a + eval b
  | mul a b => eval a * eval b

@[simp] theorem eval_nat (n : Nat) : eval (.nat n) = n := rfl
@[simp] theorem eval_fact (n : Nat) : eval (.fact n) = CombinatoricsPaths.fact n := rfl
@[simp] theorem eval_choose (n k : Nat) : eval (.choose n k) = CombinatoricsPaths.choose n k := rfl
@[simp] theorem eval_perm (n k : Nat) : eval (.perm n k) = CombinatoricsPaths.perm n k := rfl
@[simp] theorem eval_catalan (n : Nat) : eval (.catalan n) = CombinatoricsPaths.catalan n := rfl
@[simp] theorem eval_triangle (n : Nat) : eval (.triangle n) = CombinatoricsPaths.triangleNumber n := rfl
@[simp] theorem eval_add (a b : CombObj) : eval (.add a b) = eval a + eval b := rfl
@[simp] theorem eval_mul (a b : CombObj) : eval (.mul a b) = eval a * eval b := rfl

end CombObj

/-- Elementary combinatorial rewrite steps. -/
inductive CombStep : CombObj → CombObj → Type
  | factZero : CombStep (.fact 0) (.nat 1)
  | factSucc (n : Nat) : CombStep (.fact (n + 1)) (.mul (.nat (n + 1)) (.fact n))
  | chooseZero (n : Nat) : CombStep (.choose n 0) (.nat 1)
  | chooseZeroSucc (k : Nat) : CombStep (.choose 0 (k + 1)) (.nat 0)
  | pascal (n k : Nat) :
      CombStep (.choose (n + 1) (k + 1)) (.add (.choose n k) (.choose n (k + 1)))
  | permZero (n : Nat) : CombStep (.perm n 0) (.nat 1)
  | permZeroSucc (k : Nat) : CombStep (.perm 0 (k + 1)) (.nat 0)
  | permSucc (n k : Nat) :
      CombStep (.perm (n + 1) (k + 1)) (.mul (.nat (n + 1)) (.perm n k))
  | addNat (a b : Nat) : CombStep (.add (.nat a) (.nat b)) (.nat (a + b))
  | mulNat (a b : Nat) : CombStep (.mul (.nat a) (.nat b)) (.nat (a * b))
  | addZeroR (a : CombObj) : CombStep (.add a (.nat 0)) a
  | addZeroL (a : CombObj) : CombStep (.add (.nat 0) a) a
  | mulOneR (a : CombObj) : CombStep (.mul a (.nat 1)) a
  | mulOneL (a : CombObj) : CombStep (.mul (.nat 1) a) a
  | mulZeroR (a : CombObj) : CombStep (.mul a (.nat 0)) (.nat 0)
  | mulZeroL (a : CombObj) : CombStep (.mul (.nat 0) a) (.nat 0)
  | addCongL {a b : CombObj} (s : CombStep a b) (c : CombObj) :
      CombStep (.add a c) (.add b c)
  | addCongR (c : CombObj) {a b : CombObj} (s : CombStep a b) :
      CombStep (.add c a) (.add c b)
  | mulCongL {a b : CombObj} (s : CombStep a b) (c : CombObj) :
      CombStep (.mul a c) (.mul b c)
  | mulCongR (c : CombObj) {a b : CombObj} (s : CombStep a b) :
      CombStep (.mul c a) (.mul c b)

namespace CombStep

/-- A single combinatorial step preserves evaluation. -/
theorem eval_eq : {a b : CombObj} → (s : CombStep a b) → (CombObj.eval a = CombObj.eval b)
  | _, _, factZero => rfl
  | _, _, factSucc _ => rfl
  | _, _, chooseZero n => by cases n <;> rfl
  | _, _, chooseZeroSucc _ => rfl
  | _, _, pascal _ _ => rfl
  | _, _, permZero n => by cases n <;> rfl
  | _, _, permZeroSucc _ => rfl
  | _, _, permSucc _ _ => rfl
  | _, _, addNat _ _ => rfl
  | _, _, mulNat _ _ => rfl
  | _, _, addZeroR _ => Nat.add_zero _
  | _, _, addZeroL _ => Nat.zero_add _
  | _, _, mulOneR _ => Nat.mul_one _
  | _, _, mulOneL _ => Nat.one_mul _
  | _, _, mulZeroR _ => Nat.mul_zero _
  | _, _, mulZeroL _ => Nat.zero_mul _
  | _, _, addCongL s _ => _root_.congrArg (· + _) (eval_eq s)
  | _, _, addCongR _ s => _root_.congrArg (_ + ·) (eval_eq s)
  | _, _, mulCongL s _ => _root_.congrArg (· * _) (eval_eq s)
  | _, _, mulCongR _ s => _root_.congrArg (_ * ·) (eval_eq s)

/-- Interpret a step as a `Path` on the semantic `Nat` values. -/
def toPath : {a b : CombObj} → (s : CombStep a b) → Path (CombObj.eval a) (CombObj.eval b)
  | _, _, addCongL s c => Path.congrArg (fun x => x + CombObj.eval c) (toPath s)
  | _, _, addCongR c s => Path.congrArg (fun x => CombObj.eval c + x) (toPath s)
  | _, _, mulCongL s c => Path.congrArg (fun x => x * CombObj.eval c) (toPath s)
  | _, _, mulCongR c s => Path.congrArg (fun x => CombObj.eval c * x) (toPath s)
  | _, _, s => Path.mk [Step.mk _ _ (eval_eq s)] (eval_eq s)

@[simp] theorem toPath_toEq {a b : CombObj} (s : CombStep a b) : (toPath s).toEq = eval_eq s := by
  cases s <;> rfl

end CombStep

/-- Paths generated by combinatorial steps. -/
inductive CombPath : CombObj → CombObj → Type
  | refl (a : CombObj) : CombPath a a
  | step {a b : CombObj} (s : CombStep a b) : CombPath a b
  | trans {a b c : CombObj} (p : CombPath a b) (q : CombPath b c) : CombPath a c
  | symm {a b : CombObj} (p : CombPath a b) : CombPath b a

namespace CombPath

/-- Interpret a generated combinatorial path as a semantic `Path` on `Nat`. -/
def toPath {a b : CombObj} : CombPath a b → Path (CombObj.eval a) (CombObj.eval b)
  | refl _ => Path.refl _
  | step s => CombStep.toPath s
  | trans p q => Path.trans (toPath p) (toPath q)
  | symm p => Path.symm (toPath p)

@[simp] theorem toPath_refl (a : CombObj) : toPath (refl a) = Path.refl _ := rfl
@[simp] theorem toPath_trans {a b c} (p : CombPath a b) (q : CombPath b c) :
    toPath (trans p q) = Path.trans (toPath p) (toPath q) := rfl
@[simp] theorem toPath_symm {a b} (p : CombPath a b) :
    toPath (symm p) = Path.symm (toPath p) := rfl

/-- Semantic equality extracted from a `CombPath`. -/
theorem toEq {a b : CombObj} (p : CombPath a b) : CombObj.eval a = CombObj.eval b :=
  (toPath p).toEq

/-- A path composed with its inverse has reflexive semantic equality. -/
theorem roundtrip_toEq {a b : CombObj} (p : CombPath a b) :
    (Path.trans (toPath p) (Path.symm (toPath p))).toEq = rfl := by
  simp

end CombPath

/-! ## Exported paths (Nat-level) built from the domain language -/

/-- `fact 0 = 1` as a path. -/
def fact_zero_path : Path (fact 0) 1 :=
  CombStep.toPath CombStep.factZero

/-- `fact (n+1) = (n+1) * fact n` as a path. -/
def fact_succ_path (n : Nat) : Path (fact (n + 1)) ((n + 1) * fact n) :=
  CombStep.toPath (CombStep.factSucc n)

/-- A concrete computation path: `fact 1 = 1`. -/
def fact_one_path : Path (fact 1) 1 :=
  let p : CombPath (.fact 1) (.nat 1) :=
    .trans (.step (.factSucc 0))
      (.trans (.step (.mulCongR (.nat 1) .factZero))
        (.step (.mulNat 1 1)))
  CombPath.toPath p

/-- A concrete computation path: `fact 2 = 2`. -/
def fact_two_path : Path (fact 2) 2 :=
  Path.mk [Step.mk (fact 2) 2 rfl] rfl

/-- Factorial is always positive. -/
theorem fact_pos (n : Nat) : 0 < fact n := by
  induction n with
  | zero => unfold fact; decide
  | succ n ih =>
      unfold fact
      have hn : 0 < n + 1 := Nat.succ_pos _
      exact Nat.mul_pos hn ih

/-- `choose n 0 = 1` as a path. -/
def choose_zero_path (n : Nat) : Path (choose n 0) 1 :=
  CombStep.toPath (CombStep.chooseZero n)

/-- `choose 0 (k+1) = 0` as a path. -/
def choose_zero_succ_path (k : Nat) : Path (choose 0 (k + 1)) 0 :=
  CombStep.toPath (CombStep.chooseZeroSucc k)

/-- Pascal's identity as a path. -/
def pascal_path (n k : Nat) :
    Path (choose (n + 1) (k + 1)) (choose n k + choose n (k + 1)) :=
  CombStep.toPath (CombStep.pascal n k)

/-- `choose n 1 = n` for all `n`. -/
theorem choose_one_eq (n : Nat) : choose n 1 = n := by
  induction n with
  | zero => rfl
  | succ n ih =>
      simp [choose, ih, Nat.add_comm]

/-- `choose n 1 = n` as a path. -/
def choose_one_path (n : Nat) : Path (choose n 1) n :=
  Path.mk [Step.mk _ _ (choose_one_eq n)] (choose_one_eq n)

/-- `perm n 0 = 1` as a path. -/
def perm_zero_path (n : Nat) : Path (perm n 0) 1 :=
  CombStep.toPath (CombStep.permZero n)

/-- `perm 0 (k+1) = 0` as a path. -/
def perm_zero_succ_path (k : Nat) : Path (perm 0 (k + 1)) 0 :=
  CombStep.toPath (CombStep.permZeroSucc k)

/-- Falling factorial step as a path. -/
def perm_succ_path (n k : Nat) :
    Path (perm (n + 1) (k + 1)) ((n + 1) * perm n k) :=
  CombStep.toPath (CombStep.permSucc n k)

/-- `perm n n = fact n`. -/
theorem perm_eq_fact : (n : Nat) → perm n n = fact n
  | 0 => rfl
  | n + 1 => by simp [perm, fact, perm_eq_fact n]

/-- `perm n n = fact n` as a path. -/
def perm_eq_fact_path (n : Nat) : Path (perm n n) (fact n) :=
  Path.mk [Step.mk _ _ (perm_eq_fact n)] (perm_eq_fact n)

/-- `catalan 4 = 14` as a path. -/
def catalan_four_path : Path (catalan 4) 14 := Path.refl 14

/-- `triangleNumber 0 = 0` as a path. -/
def triangle_zero_path : Path (triangleNumber 0) 0 := Path.refl 0

/-- `triangleNumber 1 = 1` as a path. -/
def triangle_one_path : Path (triangleNumber 1) 1 :=
  Path.mk [Step.mk (triangleNumber 1) 1 rfl] rfl

/-- `triangleNumber 3 = 6` as a path. -/
def triangle_three_path : Path (triangleNumber 3) 6 :=
  Path.mk [Step.mk (triangleNumber 3) 6 rfl] rfl

/-! ## Path-algebra theorems -/

/-- `congrArg` on the factorial successor path. -/
theorem fact_congrArg_mul_toEq (n : Nat) (f : Nat → Nat) :
    (Path.congrArg f (fact_succ_path n)).toEq = _root_.congrArg f (fact_succ_path n).toEq := rfl

/-- Transport of a dependent value along the Pascal path. -/
theorem transport_along_pascal (n k : Nat) (D : Nat → Type u)
    (x : D (choose (n + 1) (k + 1))) :
    Path.transport (pascal_path n k) x = x := by
  simp [Path.transport]

/-- Symmetry of the Pascal path. -/
theorem symm_pascal_toEq (n k : Nat) :
    (Path.symm (pascal_path n k)).toEq = (pascal_path n k).toEq.symm := rfl

/-- Round-trip of a concrete path. -/
theorem fact_one_roundtrip :
    (Path.trans fact_one_path (Path.symm fact_one_path)).toEq = rfl := by
  simp

/-- Underlying equality of `perm_eq_fact_path`. -/
theorem perm_fact_toEq (n : Nat) : (perm_eq_fact_path n).toEq = perm_eq_fact n := rfl

/-- Composing a path with `refl` on the right. -/
theorem trans_refl_right_fact_one :
    Path.trans fact_one_path (Path.refl 1) = fact_one_path :=
  Path.trans_refl_right _

/-- Composing a path with `refl` on the left. -/
theorem trans_refl_left_fact_one :
    Path.trans (Path.refl (fact 1)) fact_one_path = fact_one_path :=
  Path.trans_refl_left _

/-- Symmetry twice is the identity. -/
theorem symm_symm_fact_one : Path.symm (Path.symm fact_one_path) = fact_one_path :=
  Path.symm_symm _

/-- Associativity of trans. -/
theorem trans_assoc_fact_one (p q : Path 1 1) :
    Path.trans (Path.trans fact_one_path p) q =
      Path.trans fact_one_path (Path.trans p q) :=
  Path.trans_assoc _ _ _

end ComputationalPaths.Path.Algebra.CombinatoricsPaths
