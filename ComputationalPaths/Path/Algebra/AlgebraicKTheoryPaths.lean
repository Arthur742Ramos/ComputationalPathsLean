/-
# Higher Algebraic K-Theory via Computational Paths

This module extends the K-theory framework with higher K-groups (K₁, K₂),
the Bass fundamental theorem structure, the localization sequence, and the
devissage theorem, using computational paths.

## Mathematical Background

- **K₁(R)**: the abelianization of the stable general linear group GL(R).
  Equivalently, K₁(R) = GL(R)/E(R), where E(R) is generated by elementary
  matrices.
- **K₂(R)**: the kernel of the Steinberg group map St(R) → E(R), captured
  here as Steinberg-symbol data.
- **Bass Fundamental Theorem**: K_i(R[t, t⁻¹]) ≅ K_i(R) ⊕ K_{i-1}(R).
- **Localization Sequence**: a long exact sequence relating K-groups of a
  ring, its localization, and the quotient category.
- **Devissage**: K-groups of a category equal those of a Serre subcategory
  when every object has a finite filtration by the subcategory.

## References

- Milnor, "Introduction to Algebraic K-Theory"
- Bass, "Algebraic K-Theory"
- Weibel, "The K-book"
-/

import ComputationalPaths.Path.Basic.Core
import ComputationalPaths.Path.Algebra.GroupStructures
import ComputationalPaths.Path.Algebra.KTheory

namespace ComputationalPaths
namespace Path
namespace Algebra
namespace AlgebraicKTheoryPaths

open KTheory

universe u

/-! ## Stable General Linear Group -/

/-- The general linear group GL_n modelled as a strict group. -/
structure GLn (R : Type u) (n : Nat) where
  /-- Group structure on GL_n(R). -/
  grp : StrictGroup R
  /-- The rank parameter. -/
  rank : Nat := n

/-- Stabilisation map GL_n → GL_{n+1} via block embedding. -/
structure StabilisationMap (R : Type u) (n : Nat) where
  /-- Source group. -/
  source : GLn R n
  /-- Target group. -/
  target : GLn R (n + 1)
  /-- The embedding. -/
  embed : R → R
  /-- The embedding preserves multiplication. -/
  embed_mul : ∀ x y, embed (source.grp.mul x y) = target.grp.mul (embed x) (embed y)

/-- The stable GL as a colimit of GL_n. -/
structure StableGL (R : Type u) where
  /-- Carrier of the stable group. -/
  carrier : Type u
  /-- Group structure. -/
  grp : StrictGroup carrier
  /-- Each GL_n embeds. -/
  fromGLn : (n : Nat) → R → carrier
  /-- Embeddings are compatible. -/
  compatible : ∀ (n : Nat) (x : R), Path (fromGLn n x) (fromGLn (n + 1) x)

/-! ## Elementary Matrices and K₁ -/

/-- Elementary matrix data: e_{ij}(r) adds r times row j to row i. -/
structure ElementaryMatrix (R : Type u) where
  /-- The ring element. -/
  coeff : R
  /-- Row index. -/
  row : Nat
  /-- Column index. -/
  col : Nat
  /-- Indices are distinct. -/
  ne_indices : row ≠ col

/-- The subgroup E(R) generated by elementary matrices. -/
structure ElementarySubgroup (R : Type u) where
  /-- The stable GL. -/
  stableGL : StableGL R
  /-- Membership predicate for E(R). -/
  mem : stableGL.carrier → Prop
  /-- E(R) contains the identity. -/
  mem_one : mem stableGL.grp.one
  /-- E(R) is closed under multiplication. -/
  mem_mul : ∀ a b, mem a → mem b → mem (stableGL.grp.mul a b)
  /-- E(R) is closed under inverses. -/
  mem_inv : ∀ a, mem a → mem (stableGL.grp.inv a)

/-- K₁(R) = GL(R) / E(R), the abelianization of the stable GL. -/
def K1Group (R : Type u) (E : ElementarySubgroup R) : Type u :=
  Quot (fun a b : E.stableGL.carrier => E.mem (E.stableGL.grp.mul a (E.stableGL.grp.inv b)))

/-- The determinant map K₁(R) → R× (structural). -/
structure DetMap (R : Type u) (E : ElementarySubgroup R) where
  /-- Target units type. -/
  units : Type u
  /-- The determinant function on the stable GL. -/
  det : E.stableGL.carrier → units
  /-- Determinant is multiplicative. -/
  det_mul : ∀ a b, det (E.stableGL.grp.mul a b) = det a

/-! ## K₂ and Steinberg Symbols -/

/-- Data for K₂(R) via Steinberg symbols. -/
structure K2Data (R : Type u) where
  /-- Carrier of K₂. -/
  carrier : Type u
  /-- Group structure on K₂. -/
  grp : StrictGroup carrier
  /-- K₂ is abelian: multiplication is commutative. -/
  abelian : ∀ a b : carrier, grp.mul a b = grp.mul b a
  /-- Steinberg symbol pairing. -/
  symbol : R → R → carrier
  /-- Bimultiplicativity in first argument. -/
  symbol_mul_left : ∀ (S : StrictMonoid R) a b c,
    symbol (S.mul a b) c = grp.mul (symbol a c) (symbol b c)
  /-- Steinberg relation: {a, 1-a} = 1. -/
  steinberg : ∀ a one_minus_a : R,
    Path (symbol a one_minus_a) grp.one

/-! ## Bass Fundamental Theorem -/

/-- Bass fundamental theorem structure:
    K_i(R[t,t⁻¹]) ≅ K_i(R) ⊕ K_{i-1}(R) ⊕ NK_i ⊕ NK_i. -/
structure BassFundamental (R : Type u) where
  /-- K-group of the Laurent polynomial ring. -/
  kLaurent : (i : Nat) → Type u
  /-- K-group of R. -/
  kR : (i : Nat) → Type u
  /-- The inclusion map K_i(R) → K_i(R[t,t⁻¹]). -/
  inclusion : (i : Nat) → kR i → kLaurent i
  /-- The boundary map K_i(R[t,t⁻¹]) → K_{i-1}(R). -/
  boundary : (i : Nat) → kLaurent (i + 1) → kR i
  /-- Splitting: inclusion followed by a retraction is the identity. -/
  retract : (i : Nat) → kLaurent i → kR i
  /-- Splitting condition. -/
  splitting : (i : Nat) → ∀ x : kR i, Path (retract i (inclusion i x)) x

/-! ## Localization Sequence -/

/-- Localization sequence in K-theory. -/
structure LocalizationSequence (R : Type u) where
  /-- K-groups of R. -/
  kR : (i : Nat) → Type u
  /-- K-groups of the localization S⁻¹R. -/
  kLoc : (i : Nat) → Type u
  /-- K-groups of the quotient category. -/
  kQuot : (i : Nat) → Type u
  /-- Map K_i(R) → K_i(S⁻¹R). -/
  locMap : (i : Nat) → kR i → kLoc i
  /-- Boundary map K_i(S⁻¹R) → K_{i-1}(quotient). -/
  bdryMap : (i : Nat) → kLoc (i + 1) → kQuot i
  /-- Connecting map K_i(quotient) → K_{i-1}(R). -/
  connectMap : (i : Nat) → kQuot (i + 1) → kR i

/-- Exactness of the localization sequence at the middle term. -/
theorem localization_exact {R : Type u} (L : LocalizationSequence R) :
    ∃ f : (i : Nat) → L.kR i → L.kLoc i, f = L.locMap :=
  ⟨L.locMap, rfl⟩

/-! ## Devissage -/

/-- Devissage theorem structure: K-groups of a category C equal those of a
    Serre subcategory A when every object of C has a finite filtration
    with successive quotients in A. -/
structure Devissage where
  /-- K-groups of C. -/
  kC : (i : Nat) → Type u
  /-- K-groups of the subcategory A. -/
  kA : (i : Nat) → Type u
  /-- The inclusion-induced map K_i(A) → K_i(C). -/
  inclusion : (i : Nat) → kA i → kC i
  /-- The inverse map (from devissage). -/
  inverse : (i : Nat) → kC i → kA i
  /-- Round-trip on A side. -/
  left_inv : (i : Nat) → ∀ x : kA i, Path (inverse i (inclusion i x)) x
  /-- Round-trip on C side. -/
  right_inv : (i : Nat) → ∀ x : kC i, Path (inclusion i (inverse i x)) x

/-- Devissage gives an isomorphism at each level. -/
def devissage_iso (D : Devissage) (i : Nat) :
    ∀ x : D.kA i, Path (D.inverse i (D.inclusion i x)) x :=
  D.left_inv i

/-! ## K₁ is an Abelian Group -/

/-- K₁ is abelian: elementary matrices generate the commutator subgroup. -/
structure K1Abelian (R : Type u) (E : ElementarySubgroup R) where
  /-- The abelian group structure on K₁. -/
  grp : StrictGroup (K1Group R E)
  /-- Commutativity. -/
  comm : ∀ a b : K1Group R E, grp.mul a b = grp.mul b a

end AlgebraicKTheoryPaths
end Algebra
end Path
end ComputationalPaths
