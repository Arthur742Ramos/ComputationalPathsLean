/-
# Equivariant Paths and Orbit Spaces

This module introduces equivariant paths for strict group actions by working in
the orbit space.  Equivariant homotopies are homotopies after passing to orbit
spaces, and the orbit projection induces the canonical map on π₁.

## Key Results

- `OrbitRel`, `OrbitSpace`, `orbitMap`: orbit space construction
- `EquivariantPath`, `equivariantPath_of_path`: equivariant paths as orbit paths
- `EquivariantHomotopy`: homotopies in the orbit space
- `orbitSpacePiOneMap`: induced map on π₁ by the orbit projection
- `orbitSpacePiOneMap_ofLoop`: orbit-space fundamental group theorem on loops
-/

import ComputationalPaths.Path.ActionGroupoid
import ComputationalPaths.Path.Homotopy.FundamentalGroupoid
import ComputationalPaths.Path.Homotopy.HoTT

namespace ComputationalPaths
namespace Path
namespace EquivariantPaths

open Algebra HoTT

universe u v w

/-! ## Orbit space -/

section OrbitSpace

variable {G : Type u} {X : Type v} {S : StrictGroup G}
variable (A : GroupAction G S X)

/-- Orbit relation generated by a strict group action. -/
def OrbitRel (x y : X) : Prop :=
  ∃ g : G, A.act g x = y

/-- Orbit space of a group action. -/
abbrev OrbitSpace : Type v :=
  Quot (OrbitRel (A := A))

/-- Projection to the orbit space. -/
def orbitMap : X → OrbitSpace A :=
  fun x => Quot.mk _ x

/-- Points related by the orbit relation have the same image in the quotient. -/
theorem orbitMap_eq_of_rel {x y : X} (h : OrbitRel (A := A) x y) :
    orbitMap A x = orbitMap A y := by
  exact Quot.sound h

/-- Acting by the group does not change the orbit class. -/
theorem orbitMap_act (g : G) (x : X) :
    orbitMap A x = orbitMap A (A.act g x) := by
  exact orbitMap_eq_of_rel (A := A) ⟨g, rfl⟩

end OrbitSpace

/-! ## Equivariant paths -/

section EquivariantPaths

variable {G : Type u} {X : Type v} {S : StrictGroup G}
variable (A : GroupAction G S X)

/-- A G-equivariant path between x and y is a path between their orbits. -/
abbrev EquivariantPath (x y : X) : Type v :=
  Path (orbitMap A x) (orbitMap A y)

/-- Project a path to the orbit space. -/
def equivariantPath_of_path {x y : X} (p : Path x y) :
    EquivariantPath A x y :=
  Path.congrArg (orbitMap A) p

/-- Equivariant paths preserve reflexivity. -/
@[simp] theorem equivariantPath_of_path_refl (x : X) :
    equivariantPath_of_path (A := A) (Path.refl x) =
      Path.refl (orbitMap A x) := by
  rfl

/-- Equivariant paths preserve symmetry. -/
@[simp] theorem equivariantPath_of_path_symm {x y : X} (p : Path x y) :
    equivariantPath_of_path (A := A) (Path.symm p) =
      Path.symm (equivariantPath_of_path (A := A) p) := by
  simp [equivariantPath_of_path]

/-- Equivariant paths preserve concatenation. -/
@[simp] theorem equivariantPath_of_path_trans {x y z : X}
    (p : Path x y) (q : Path y z) :
    equivariantPath_of_path (A := A) (Path.trans p q) =
      Path.trans (equivariantPath_of_path (A := A) p)
        (equivariantPath_of_path (A := A) q) := by
  simp [equivariantPath_of_path]

/-- Equivariant path projection respects rewrite equality. -/
noncomputable def equivariantPath_respects_rweq {x y : X} {p q : Path x y}
    (h : RwEq p q) :
    RwEq (equivariantPath_of_path (A := A) p)
      (equivariantPath_of_path (A := A) q) := by
  simpa [equivariantPath_of_path] using
    (rweq_congrArg_of_rweq (f := orbitMap A) h)

end EquivariantPaths

/-! ## Equivariant homotopies -/

section EquivariantHomotopy

variable {G : Type u} {X : Type v} {Y : Type w} {S : StrictGroup G}

/-- Equivariant homotopy: homotopy after passing to orbit spaces. -/
def EquivariantHomotopy (A : GroupAction G S X) (B : GroupAction G S Y)
    (f g : X → Y) : Type (max v w) :=
  (let _ := A
   FunHomotopy (A := X) (B := OrbitSpace B)
     (fun x => orbitMap B (f x))
     (fun x => orbitMap B (g x)))

/-- Reflexivity of equivariant homotopy. -/
@[simp] def equivariantHomotopy_refl (A : GroupAction G S X) (B : GroupAction G S Y)
    (f : X → Y) :
    EquivariantHomotopy A B f f :=
  fun _ => Path.refl _

/-- Symmetry of equivariant homotopy. -/
@[simp] def equivariantHomotopy_symm (A : GroupAction G S X) (B : GroupAction G S Y)
    {f g : X → Y} (H : EquivariantHomotopy A B f g) :
    EquivariantHomotopy A B g f :=
  fun x => Path.symm (H x)

/-- Transitivity of equivariant homotopy. -/
@[simp] def equivariantHomotopy_trans (A : GroupAction G S X) (B : GroupAction G S Y)
    {f g h : X → Y}
    (H₁ : EquivariantHomotopy A B f g)
    (H₂ : EquivariantHomotopy A B g h) :
    EquivariantHomotopy A B f h :=
  fun x => Path.trans (H₁ x) (H₂ x)

end EquivariantHomotopy

/-! ## Orbit space fundamental group theorem -/

section OrbitSpaceFundamentalGroup

variable {G : Type u} {X : Type v} {S : StrictGroup G}
variable (A : GroupAction G S X)

/-- Map on π₁ induced by the orbit projection. -/
def orbitSpacePiOneMap (x : X) :
    π₁(X, x) → π₁(OrbitSpace A, orbitMap A x) :=
  inducedPiOneMap (orbitMap A) x

/-- **Orbit Space Fundamental Group Theorem**: the orbit projection sends
    loops to their equivariant images in the orbit space. -/
theorem orbitSpacePiOneMap_ofLoop (x : X) (p : LoopSpace X x) :
    orbitSpacePiOneMap (A := A) x (LoopQuot.ofLoop p) =
      LoopQuot.ofLoop (equivariantPath_of_path (A := A) p) := by
  rfl

end OrbitSpaceFundamentalGroup

/-! ## Summary

We defined orbit spaces for strict group actions, packaged equivariant paths and
equivariant homotopies via orbit projections, and recorded the induced map on
fundamental groups for the orbit projection.
-/

end EquivariantPaths
end Path
end ComputationalPaths
