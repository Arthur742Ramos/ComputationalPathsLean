/-
# Type Theory Foundations via Computational Paths

This module formalizes type theory foundations â€” Martin-LÃ¶f type theory,
identity types, dependent products/sums, W-types, universes Ã  la Tarski,
the univalence axiom (statement), function extensionality, and propositional
truncation â€” all with `Path` coherence witnesses.

## Mathematical Background

Martin-LÃ¶f type theory (MLTT) is an intensional dependent type theory
that serves as a foundation for constructive mathematics:

1. **Martin-LÃ¶f Type Theory**: A dependent type theory with Î -types,
   Î£-types, identity types, natural numbers, and universes. The judgment
   forms are: Î“ ctx, Î“ âŠ¢ A type, Î“ âŠ¢ a : A, Î“ âŠ¢ a â‰¡ b : A.
2. **Identity Types**: Id_A(a,b) â€” the type of proofs that a = b in A.
   Equipped with refl : Id_A(a,a) and the J eliminator (path induction).
   In intensional MLTT, Id types are not necessarily propositional.
3. **Dependent Products (Î -types)**: Î (x:A).B(x) â€” the type of
   dependent functions. With introduction (Î») and elimination (app)
   satisfying Î² and Î· rules.
4. **Dependent Sums (Î£-types)**: Î£(x:A).B(x) â€” the type of
   dependent pairs. With introduction (pair) and elimination (prâ‚, prâ‚‚).
5. **W-types**: W(x:A).B(x) â€” well-founded trees with nodes labeled
   by a : A and branching type B(a). The type of well-founded trees
   is inductively generated by the constructor sup.
6. **Universes Ã  la Tarski**: A universe U is a type together with a
   decoding function El : U â†’ Type. Codes in U represent types,
   and El maps codes to their types.
7. **Univalence Axiom**: (A â‰ƒ B) â‰ƒ Id_U(A,B) â€” equivalence of types
   is equivalent to identity in the universe. This is Voevodsky's axiom.
8. **Function Extensionality**: If f(x) = g(x) for all x, then f = g.
   Follows from univalence but is independent in intensional MLTT.
9. **Propositional Truncation**: â€–Aâ€– â€” the (-1)-truncation of A,
   turning any type into a proposition (mere proposition).

## Key Results

| Definition/Theorem | Description |
|-------------------|-------------|
| `MLTTData` | Martin-LÃ¶f type theory data |
| `IdentityTypeData` | Identity type data |
| `PiTypeData` | Dependent product data |
| `SigmaTypeData` | Dependent sum data |
| `WTypeData` | W-type data |
| `UniverseData` | Universe Ã  la Tarski |
| `UnivalenceData` | Univalence axiom (statement) |
| `FunExtData` | Function extensionality |
| `PropTruncData` | Propositional truncation |
| `identity_j_path` | J eliminator coherence |
| `pi_beta_path` | Î  Î²-reduction |
| `sigma_eta_path` | Î£ Î·-expansion |
| `wtype_induction_path` | W-type induction |
| `univalence_path` | Univalence coherence |
| `funext_path` | Function extensionality coherence |
| `proptrunc_path` | Truncation coherence |

## References

- Martin-LÃ¶f, "Intuitionistic Type Theory" (Bibliopolis, 1984)
- Univalent Foundations Program, "Homotopy Type Theory" (IAS, 2013)
- NordstrÃ¶m, Petersson, Smith, "Programming in Martin-LÃ¶f's Type Theory"
- Hofmann, Streicher, "The Groupoid Interpretation of Type Theory" (1998)
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths
namespace TypeTheoryFoundations

universe u v w

/-! ## Martin-LÃ¶f Type Theory Data -/

/-- Data representing the structure of Martin-LÃ¶f type theory.
We track the judgment forms, type formers, and key metatheoretic
properties. -/
structure MLTTData where
  /-- Number of judgment forms (ctx, type, term, definitional eq). -/
  numJudgmentForms : Nat
  /-- Standard MLTT has 4 judgment forms. -/
  judgmentForms_eq : numJudgmentForms = 4
  /-- Number of type formers (Î , Î£, Id, â„•, ðŸŽ, ðŸ, ðŸ, W, U). -/
  numTypeFormers : Nat
  /-- numTypeFormers â‰¥ 4 (at minimum: Î , Î£, Id, â„•). -/
  typeFormers_ge : numTypeFormers â‰¥ 4
  /-- Whether the theory is intensional (true) or extensional (false). -/
  isIntensional : Bool
  /-- Decidability of type checking (0 = decidable). -/
  typeCheckObstruction : Nat
  /-- Type checking is decidable for intensional MLTT. -/
  typeCheck_zero : typeCheckObstruction = 0
  /-- Normalization obstruction (0 = normalizing). -/
  normalizationObstruction : Nat
  /-- MLTT is normalizing. -/
  normalization_zero : normalizationObstruction = 0
  /-- Consistency obstruction (0 = consistent). -/
  consistencyObstruction : Nat
  /-- MLTT is consistent. -/
  consistency_zero : consistencyObstruction = 0

namespace MLTTData

/-- Standard intensional MLTT. -/
def standard : MLTTData where
  numJudgmentForms := 4
  judgmentForms_eq := rfl
  numTypeFormers := 9
  typeFormers_ge := by omega
  isIntensional := true
  typeCheckObstruction := 0
  typeCheck_zero := rfl
  normalizationObstruction := 0
  normalization_zero := rfl
  consistencyObstruction := 0
  consistency_zero := rfl

/-- Extensional MLTT (equality reflection rule). -/
def extensional : MLTTData where
  numJudgmentForms := 4
  judgmentForms_eq := rfl
  numTypeFormers := 9
  typeFormers_ge := by omega
  isIntensional := false
  typeCheckObstruction := 1  -- type checking is undecidable for extensional
  typeCheck_zero := by decide
  normalizationObstruction := 0
  normalization_zero := rfl
  consistencyObstruction := 0
  consistency_zero := rfl

/-- Minimal MLTT (Î , Î£, Id, â„• only). -/
def minimal : MLTTData where
  numJudgmentForms := 4
  judgmentForms_eq := rfl
  numTypeFormers := 4
  typeFormers_ge := by omega
  isIntensional := true
  typeCheckObstruction := 0
  typeCheck_zero := rfl
  normalizationObstruction := 0
  normalization_zero := rfl
  consistencyObstruction := 0
  consistency_zero := rfl

/-- Path: 4 judgment forms. -/
def judgment_path (mltt : MLTTData) :
    Path mltt.numJudgmentForms 4 :=
  Path.ofEq mltt.judgmentForms_eq

/-- Path: normalization. -/
def normalization_path (mltt : MLTTData) :
    Path mltt.normalizationObstruction 0 :=
  Path.ofEq mltt.normalization_zero

/-- Path: consistency. -/
def consistency_path (mltt : MLTTData) :
    Path mltt.consistencyObstruction 0 :=
  Path.ofEq mltt.consistency_zero

end MLTTData

/-! ## Identity Types -/

/-- Identity type Id_A(a,b): the type of proofs of equality.
We track the introduction rule (refl), the elimination rule (J),
and the computation rule (J on refl). -/
structure IdentityTypeData where
  /-- Dimension of the type A (0 = set, 1 = groupoid, etc.). -/
  typeDimension : Nat
  /-- Number of constructors (always 1: refl). -/
  numConstructors : Nat
  /-- One constructor. -/
  constructor_eq : numConstructors = 1
  /-- J computation obstruction (0 = J(refl) computes correctly). -/
  jComputeObstruction : Nat
  /-- J computes. -/
  jCompute_zero : jComputeObstruction = 0
  /-- UIP obstruction (0 = UIP holds; non-zero = UIP may fail). -/
  uipStatus : Nat
  /-- Based path induction obstruction (0 = available). -/
  basedPathObstruction : Nat
  /-- Based path induction is available. -/
  basedPath_zero : basedPathObstruction = 0
  /-- Transport obstruction (0 = transport is definable from J). -/
  transportObstruction : Nat
  /-- Transport is definable. -/
  transport_zero : transportObstruction = 0

namespace IdentityTypeData

/-- Identity types in intensional MLTT (UIP may fail). -/
def intensional : IdentityTypeData where
  typeDimension := 1  -- groupoid level
  numConstructors := 1
  constructor_eq := rfl
  jComputeObstruction := 0
  jCompute_zero := rfl
  uipStatus := 1  -- UIP is not provable
  basedPathObstruction := 0
  basedPath_zero := rfl
  transportObstruction := 0
  transport_zero := rfl

/-- Identity types with UIP (set-level). -/
def withUIP : IdentityTypeData where
  typeDimension := 0  -- set level
  numConstructors := 1
  constructor_eq := rfl
  jComputeObstruction := 0
  jCompute_zero := rfl
  uipStatus := 0  -- UIP holds
  basedPathObstruction := 0
  basedPath_zero := rfl
  transportObstruction := 0
  transport_zero := rfl

/-- Path: J computation. -/
def identity_j_path (idt : IdentityTypeData) :
    Path idt.jComputeObstruction 0 :=
  Path.ofEq idt.jCompute_zero

/-- Path: based path induction. -/
def based_path_path (idt : IdentityTypeData) :
    Path idt.basedPathObstruction 0 :=
  Path.ofEq idt.basedPath_zero

/-- Path: transport. -/
def transport_path (idt : IdentityTypeData) :
    Path idt.transportObstruction 0 :=
  Path.ofEq idt.transport_zero

/-- Path: one constructor. -/
def constructor_path (idt : IdentityTypeData) :
    Path idt.numConstructors 1 :=
  Path.ofEq idt.constructor_eq

end IdentityTypeData

/-! ## Dependent Products (Î -types) -/

/-- Î -type: Î (x:A).B(x). The type of dependent functions.
We track the Î²-rule (computation) and Î·-rule (uniqueness). -/
structure PiTypeData where
  /-- Domain type size (number of elements, for finite types). -/
  domainSize : Nat
  /-- domainSize is positive. -/
  domainSize_pos : domainSize > 0
  /-- Total fiber size (sum of |B(a)| for a : A). -/
  totalFiberSize : Nat
  /-- Result type size (product of |B(a)|). -/
  resultSize : Nat
  /-- Î²-reduction obstruction (0 = (Î»x.t)(a) reduces to t[a/x]). -/
  betaObstruction : Nat
  /-- Î²-reduction holds. -/
  beta_zero : betaObstruction = 0
  /-- Î·-expansion obstruction (0 = f â‰¡ Î»x.f(x)). -/
  etaObstruction : Nat
  /-- Î·-expansion holds. -/
  eta_zero : etaObstruction = 0
  /-- Substitution obstruction (0 = Î  commutes with substitution). -/
  substObstruction : Nat
  /-- Substitution coherence. -/
  subst_zero : substObstruction = 0

namespace PiTypeData

/-- Simple function type (non-dependent). -/
def simple (a b : Nat) (ha : a > 0) : PiTypeData where
  domainSize := a
  domainSize_pos := ha
  totalFiberSize := a * b
  resultSize := b ^ a
  betaObstruction := 0
  beta_zero := rfl
  etaObstruction := 0
  eta_zero := rfl
  substObstruction := 0
  subst_zero := rfl

/-- Identity function type. -/
def identity (a : Nat) (ha : a > 0) : PiTypeData where
  domainSize := a
  domainSize_pos := ha
  totalFiberSize := a
  resultSize := 1  -- only one identity function
  betaObstruction := 0
  beta_zero := rfl
  etaObstruction := 0
  eta_zero := rfl
  substObstruction := 0
  subst_zero := rfl

/-- Path: Î²-reduction. -/
def pi_beta_path (pt : PiTypeData) :
    Path pt.betaObstruction 0 :=
  Path.ofEq pt.beta_zero

/-- Path: Î·-expansion. -/
def pi_eta_path (pt : PiTypeData) :
    Path pt.etaObstruction 0 :=
  Path.ofEq pt.eta_zero

/-- Path: substitution. -/
def pi_subst_path (pt : PiTypeData) :
    Path pt.substObstruction 0 :=
  Path.ofEq pt.subst_zero

end PiTypeData

/-! ## Dependent Sums (Î£-types) -/

/-- Î£-type: Î£(x:A).B(x). The type of dependent pairs.
We track the introduction (pairing) and elimination (projections). -/
structure SigmaTypeData where
  /-- Base type size. -/
  baseSize : Nat
  /-- baseSize is positive. -/
  baseSize_pos : baseSize > 0
  /-- Total fiber size. -/
  totalFiberSize : Nat
  /-- Result type size = totalFiberSize (disjoint union of fibers). -/
  resultSize : Nat
  /-- result = totalFiber. -/
  result_eq : resultSize = totalFiberSize
  /-- First projection obstruction (0 = prâ‚(a,b) â‰¡ a). -/
  proj1Obstruction : Nat
  /-- First projection computes. -/
  proj1_zero : proj1Obstruction = 0
  /-- Second projection obstruction (0 = prâ‚‚(a,b) â‰¡ b). -/
  proj2Obstruction : Nat
  /-- Second projection computes. -/
  proj2_zero : proj2Obstruction = 0
  /-- Î·-rule obstruction (0 = (prâ‚(p), prâ‚‚(p)) â‰¡ p). -/
  etaObstruction : Nat
  /-- Î·-rule holds. -/
  eta_zero : etaObstruction = 0

namespace SigmaTypeData

/-- Simple product type (non-dependent). -/
def product (a b : Nat) (ha : a > 0) : SigmaTypeData where
  baseSize := a
  baseSize_pos := ha
  totalFiberSize := a * b
  resultSize := a * b
  result_eq := rfl
  proj1Obstruction := 0
  proj1_zero := rfl
  proj2Obstruction := 0
  proj2_zero := rfl
  etaObstruction := 0
  eta_zero := rfl

/-- Unit type as empty Î£. -/
def unit : SigmaTypeData where
  baseSize := 1
  baseSize_pos := by omega
  totalFiberSize := 1
  resultSize := 1
  result_eq := rfl
  proj1Obstruction := 0
  proj1_zero := rfl
  proj2Obstruction := 0
  proj2_zero := rfl
  etaObstruction := 0
  eta_zero := rfl

/-- Path: Î£ Î·-expansion. -/
def sigma_eta_path (st : SigmaTypeData) :
    Path st.etaObstruction 0 :=
  Path.ofEq st.eta_zero

/-- Path: first projection. -/
def sigma_proj1_path (st : SigmaTypeData) :
    Path st.proj1Obstruction 0 :=
  Path.ofEq st.proj1_zero

/-- Path: second projection. -/
def sigma_proj2_path (st : SigmaTypeData) :
    Path st.proj2Obstruction 0 :=
  Path.ofEq st.proj2_zero

/-- Path: result size. -/
def sigma_result_path (st : SigmaTypeData) :
    Path st.resultSize st.totalFiberSize :=
  Path.ofEq st.result_eq

end SigmaTypeData

/-! ## W-types -/

/-- W-type: W(x:A).B(x). Well-founded trees with nodes labeled by a : A
and B(a)-many branches. The constructor is sup : (a : A) â†’ (B(a) â†’ W) â†’ W.
The eliminator is structural recursion on the tree. -/
structure WTypeData where
  /-- Number of node labels (|A|). -/
  numLabels : Nat
  /-- numLabels is positive. -/
  numLabels_pos : numLabels > 0
  /-- Maximum branching factor (max |B(a)|). -/
  maxBranching : Nat
  /-- Well-foundedness obstruction (0 = well-founded). -/
  wellFoundedObstruction : Nat
  /-- W-type is well-founded. -/
  wellFounded_zero : wellFoundedObstruction = 0
  /-- Induction principle obstruction (0 = induction holds). -/
  inductionObstruction : Nat
  /-- Induction principle holds. -/
  induction_zero : inductionObstruction = 0
  /-- Uniqueness of recursion obstruction. -/
  recursionObstruction : Nat
  /-- Recursion is well-defined. -/
  recursion_zero : recursionObstruction = 0
  /-- Initiality obstruction (0 = W-type is initial algebra). -/
  initialityObstruction : Nat
  /-- Initiality holds. -/
  initiality_zero : initialityObstruction = 0

namespace WTypeData

/-- Natural numbers as W-type: A = {zero, succ}, B(zero) = âˆ…, B(succ) = {*}. -/
def natW : WTypeData where
  numLabels := 2
  numLabels_pos := by omega
  maxBranching := 1
  wellFoundedObstruction := 0
  wellFounded_zero := rfl
  inductionObstruction := 0
  induction_zero := rfl
  recursionObstruction := 0
  recursion_zero := rfl
  initialityObstruction := 0
  initiality_zero := rfl

/-- Binary trees: A = {leaf, node}, B(leaf) = âˆ…, B(node) = {left, right}. -/
def binaryTree : WTypeData where
  numLabels := 2
  numLabels_pos := by omega
  maxBranching := 2
  wellFoundedObstruction := 0
  wellFounded_zero := rfl
  inductionObstruction := 0
  induction_zero := rfl
  recursionObstruction := 0
  recursion_zero := rfl
  initialityObstruction := 0
  initiality_zero := rfl

/-- General W-type with n labels and max branching k. -/
def general (n k : Nat) (hn : n > 0) : WTypeData where
  numLabels := n
  numLabels_pos := hn
  maxBranching := k
  wellFoundedObstruction := 0
  wellFounded_zero := rfl
  inductionObstruction := 0
  induction_zero := rfl
  recursionObstruction := 0
  recursion_zero := rfl
  initialityObstruction := 0
  initiality_zero := rfl

/-- Path: W-type induction. -/
def wtype_induction_path (wt : WTypeData) :
    Path wt.inductionObstruction 0 :=
  Path.ofEq wt.induction_zero

/-- Path: well-foundedness. -/
def wtype_wellfounded_path (wt : WTypeData) :
    Path wt.wellFoundedObstruction 0 :=
  Path.ofEq wt.wellFounded_zero

/-- Path: initiality. -/
def wtype_initiality_path (wt : WTypeData) :
    Path wt.initialityObstruction 0 :=
  Path.ofEq wt.initiality_zero

/-- Path: recursion. -/
def wtype_recursion_path (wt : WTypeData) :
    Path wt.recursionObstruction 0 :=
  Path.ofEq wt.recursion_zero

end WTypeData

/-! ## Universes Ã  la Tarski -/

/-- Universe Ã  la Tarski: a type U with a decoding function El : U â†’ Type.
Elements of U are "codes" for types. The universe hierarchy
Uâ‚€ : Uâ‚ : Uâ‚‚ : â‹¯ with lifting maps. -/
structure UniverseData where
  /-- Universe level. -/
  level : Nat
  /-- Number of type formers closed under this universe. -/
  numClosed : Nat
  /-- numClosed â‰¥ 4 (Î , Î£, Id, â„• at minimum). -/
  numClosed_ge : numClosed â‰¥ 4
  /-- Cumulativity obstruction (0 = U_i âŠ† U_{i+1}). -/
  cumulativityObstruction : Nat
  /-- Cumulativity holds. -/
  cumulativity_zero : cumulativityObstruction = 0
  /-- Russell paradox avoidance: U_i : U_{i+1}, NOT U_i : U_i. -/
  paradoxObstruction : Nat
  /-- No paradox. -/
  paradox_zero : paradoxObstruction = 0
  /-- El is injective obstruction (0 = injective). -/
  injectivityObstruction : Nat
  /-- El is injective. -/
  injectivity_zero : injectivityObstruction = 0

namespace UniverseData

/-- Universe level 0. -/
def u0 : UniverseData where
  level := 0
  numClosed := 9
  numClosed_ge := by omega
  cumulativityObstruction := 0
  cumulativity_zero := rfl
  paradoxObstruction := 0
  paradox_zero := rfl
  injectivityObstruction := 0
  injectivity_zero := rfl

/-- Universe level n. -/
def uN (n : Nat) : UniverseData where
  level := n
  numClosed := 9
  numClosed_ge := by omega
  cumulativityObstruction := 0
  cumulativity_zero := rfl
  paradoxObstruction := 0
  paradox_zero := rfl
  injectivityObstruction := 0
  injectivity_zero := rfl

/-- Path: cumulativity. -/
def universe_cumulative_path (ud : UniverseData) :
    Path ud.cumulativityObstruction 0 :=
  Path.ofEq ud.cumulativity_zero

/-- Path: no paradox. -/
def universe_paradox_path (ud : UniverseData) :
    Path ud.paradoxObstruction 0 :=
  Path.ofEq ud.paradox_zero

/-- Path: injectivity. -/
def universe_injectivity_path (ud : UniverseData) :
    Path ud.injectivityObstruction 0 :=
  Path.ofEq ud.injectivity_zero

end UniverseData

/-! ## Univalence Axiom -/

/-- The univalence axiom: (A â‰ƒ B) â‰ƒ Id_U(A,B). This identifies
equivalence of types with identity in the universe. We track the
axiom's components and consequences. -/
structure UnivalenceData where
  /-- Universe level at which univalence is stated. -/
  universeLevel : Nat
  /-- idToEquiv is an equivalence obstruction (0 = is equivalence). -/
  idToEquivObstruction : Nat
  /-- idToEquiv is an equivalence. -/
  idToEquiv_zero : idToEquivObstruction = 0
  /-- Consistency with MLTT obstruction (0 = consistent).
      Note: univalence is consistent with MLTT by the simplicial set model. -/
  consistencyObstruction : Nat
  /-- Consistency holds. -/
  consistency_zero : consistencyObstruction = 0
  /-- Incompatibility with UIP (univalence implies NOT UIP in general). -/
  incompatibleWithUIP : Bool
  /-- Univalence is incompatible with UIP. -/
  uip_incompat : incompatibleWithUIP = true
  /-- Function extensionality follows from univalence. -/
  impliesFunExt : Bool
  /-- FunExt follows. -/
  funext_follows : impliesFunExt = true

namespace UnivalenceData

/-- Standard univalence at level 0. -/
def standard : UnivalenceData where
  universeLevel := 0
  idToEquivObstruction := 0
  idToEquiv_zero := rfl
  consistencyObstruction := 0
  consistency_zero := rfl
  incompatibleWithUIP := true
  uip_incompat := rfl
  impliesFunExt := true
  funext_follows := rfl

/-- Univalence at arbitrary level. -/
def atLevel (n : Nat) : UnivalenceData where
  universeLevel := n
  idToEquivObstruction := 0
  idToEquiv_zero := rfl
  consistencyObstruction := 0
  consistency_zero := rfl
  incompatibleWithUIP := true
  uip_incompat := rfl
  impliesFunExt := true
  funext_follows := rfl

/-- Path: univalence (idToEquiv is equivalence). -/
def univalence_path (ua : UnivalenceData) :
    Path ua.idToEquivObstruction 0 :=
  Path.ofEq ua.idToEquiv_zero

/-- Path: consistency. -/
def univalence_consistency_path (ua : UnivalenceData) :
    Path ua.consistencyObstruction 0 :=
  Path.ofEq ua.consistency_zero

/-- Path: implies funext. -/
def univalence_funext_path (ua : UnivalenceData) :
    Path ua.impliesFunExt true :=
  Path.ofEq ua.funext_follows

end UnivalenceData

/-! ## Function Extensionality -/

/-- Function extensionality: pointwise equal functions are equal.
âˆ€f g : Î (x:A).B(x). (âˆ€x. f(x) = g(x)) â†’ f = g. -/
structure FunExtData where
  /-- Domain type size. -/
  domainSize : Nat
  /-- domainSize is positive. -/
  domainSize_pos : domainSize > 0
  /-- Whether funext holds in the system. -/
  funextHolds : Bool
  /-- Funext holds. -/
  funext_true : funextHolds = true
  /-- Whether funext is provable from univalence. -/
  fromUnivalence : Bool
  /-- Funext follows from univalence. -/
  from_univalence_true : fromUnivalence = true
  /-- Whether funext is independent of intensional MLTT. -/
  independentOfMLTT : Bool
  /-- Funext is independent. -/
  independent_true : independentOfMLTT = true
  /-- Obstruction to deriving funext (0 = derivable with UA). -/
  derivationObstruction : Nat
  /-- Derivable. -/
  derivation_zero : derivationObstruction = 0

namespace FunExtData

/-- Standard function extensionality. -/
def standard (n : Nat) (hn : n > 0) : FunExtData where
  domainSize := n
  domainSize_pos := hn
  funextHolds := true
  funext_true := rfl
  fromUnivalence := true
  from_univalence_true := rfl
  independentOfMLTT := true
  independent_true := rfl
  derivationObstruction := 0
  derivation_zero := rfl

/-- Path: funext. -/
def funext_path (fe : FunExtData) :
    Path fe.funextHolds true :=
  Path.ofEq fe.funext_true

/-- Path: from univalence. -/
def from_univalence_path (fe : FunExtData) :
    Path fe.fromUnivalence true :=
  Path.ofEq fe.from_univalence_true

/-- Path: derivation. -/
def funext_derivation_path (fe : FunExtData) :
    Path fe.derivationObstruction 0 :=
  Path.ofEq fe.derivation_zero

end FunExtData

/-! ## Propositional Truncation -/

/-- Propositional truncation â€–Aâ€–: the (-1)-truncation of A.
â€–Aâ€– is a proposition (all elements are equal) such that
A â†’ â€–Aâ€– (surjection) and â€–Aâ€– â†’ P for any proposition P with A â†’ P. -/
structure PropTruncData where
  /-- Original type size (number of elements). -/
  originalSize : Nat
  /-- originalSize is positive. -/
  originalSize_pos : originalSize > 0
  /-- Truncated type size (always 1 if inhabited, 0 if empty). -/
  truncatedSize : Nat
  /-- Truncated is at most 1. -/
  truncated_le : truncatedSize â‰¤ 1
  /-- Surjection obstruction (0 = |_| : A â†’ â€–Aâ€– exists). -/
  surjectionObstruction : Nat
  /-- Surjection exists. -/
  surjection_zero : surjectionObstruction = 0
  /-- Elimination into propositions obstruction (0 = elimination exists). -/
  elimObstruction : Nat
  /-- Elimination exists. -/
  elim_zero : elimObstruction = 0
  /-- Propositional obstruction (0 = â€–Aâ€– is a proposition). -/
  propObstruction : Nat
  /-- â€–Aâ€– is a proposition. -/
  prop_zero : propObstruction = 0

namespace PropTruncData

/-- Truncation of a singleton (already a proposition). -/
def singleton : PropTruncData where
  originalSize := 1
  originalSize_pos := by omega
  truncatedSize := 1
  truncated_le := by omega
  surjectionObstruction := 0
  surjection_zero := rfl
  elimObstruction := 0
  elim_zero := rfl
  propObstruction := 0
  prop_zero := rfl

/-- Truncation of a type with n elements. -/
def ofSize (n : Nat) (hn : n > 0) : PropTruncData where
  originalSize := n
  originalSize_pos := hn
  truncatedSize := 1
  truncated_le := by omega
  surjectionObstruction := 0
  surjection_zero := rfl
  elimObstruction := 0
  elim_zero := rfl
  propObstruction := 0
  prop_zero := rfl

/-- Path: propositional truncation is a proposition. -/
def proptrunc_path (pt : PropTruncData) :
    Path pt.propObstruction 0 :=
  Path.ofEq pt.prop_zero

/-- Path: surjection. -/
def proptrunc_surjection_path (pt : PropTruncData) :
    Path pt.surjectionObstruction 0 :=
  Path.ofEq pt.surjection_zero

/-- Path: elimination. -/
def proptrunc_elim_path (pt : PropTruncData) :
    Path pt.elimObstruction 0 :=
  Path.ofEq pt.elim_zero

/-- Path: truncated size â‰¤ 1. -/
def proptrunc_size_path (pt : PropTruncData) :
    Path (min pt.truncatedSize 1) pt.truncatedSize :=
  Path.ofEq (Nat.min_eq_left pt.truncated_le)

end PropTruncData

/-! ## Higher Inductive Types -/

/-- Higher inductive types (HITs): types with both point constructors
and path constructors. The circle SÂ¹ is the prototypical example:
SÂ¹ has a point base and a path loop : base = base. -/
structure HITData where
  /-- Number of point constructors. -/
  numPointConstructors : Nat
  /-- numPointConstructors â‰¥ 1. -/
  numPoint_pos : numPointConstructors â‰¥ 1
  /-- Number of path constructors. -/
  numPathConstructors : Nat
  /-- Total constructors. -/
  totalConstructors : Nat
  /-- total = point + path. -/
  total_eq : totalConstructors = numPointConstructors + numPathConstructors
  /-- Elimination principle obstruction (0 = elimination exists). -/
  elimObstruction : Nat
  /-- Elimination exists. -/
  elim_zero : elimObstruction = 0
  /-- Computation on point constructors obstruction. -/
  pointComputeObstruction : Nat
  /-- Point computation holds. -/
  pointCompute_zero : pointComputeObstruction = 0

namespace HITData

/-- Circle SÂ¹: one point (base), one path (loop). -/
def circle : HITData where
  numPointConstructors := 1
  numPoint_pos := by omega
  numPathConstructors := 1
  totalConstructors := 2
  total_eq := rfl
  elimObstruction := 0
  elim_zero := rfl
  pointComputeObstruction := 0
  pointCompute_zero := rfl

/-- Suspension: two points (north, south), one path (merid). -/
def suspension : HITData where
  numPointConstructors := 2
  numPoint_pos := by omega
  numPathConstructors := 1
  totalConstructors := 3
  total_eq := rfl
  elimObstruction := 0
  elim_zero := rfl
  pointComputeObstruction := 0
  pointCompute_zero := rfl

/-- Pushout: three points, glue paths. -/
def pushout : HITData where
  numPointConstructors := 3
  numPoint_pos := by omega
  numPathConstructors := 1
  totalConstructors := 4
  total_eq := rfl
  elimObstruction := 0
  elim_zero := rfl
  pointComputeObstruction := 0
  pointCompute_zero := rfl

/-- Path: elimination. -/
def hit_elim_path (hit : HITData) :
    Path hit.elimObstruction 0 :=
  Path.ofEq hit.elim_zero

/-- Path: total constructors. -/
def hit_total_path (hit : HITData) :
    Path hit.totalConstructors (hit.numPointConstructors + hit.numPathConstructors) :=
  Path.ofEq hit.total_eq

end HITData

/-! ## Truncation Levels -/

/-- Truncation levels (h-levels): a type A is n-truncated if all
its identity types are (n-1)-truncated. Key levels:
-2 = contractible, -1 = proposition, 0 = set, 1 = groupoid. -/
structure TruncationLevel where
  /-- Truncation level (offset by 2: 0 = (-2)-truncated, 1 = (-1)-truncated, etc.). -/
  level : Nat
  /-- Number of elements (for finite types at level 0+). -/
  numElements : Nat
  /-- At level â‰¤ 1 (propositional), numElements â‰¤ 1. -/
  prop_bound : level â‰¤ 1 â†’ numElements â‰¤ 1
  /-- Closure under Î -types obstruction (0 = closed). -/
  piClosureObstruction : Nat
  /-- Î -closure holds. -/
  piClosure_zero : piClosureObstruction = 0
  /-- Closure under Î£-types obstruction. -/
  sigmaClosureObstruction : Nat
  /-- Î£-closure holds. -/
  sigmaClosure_zero : sigmaClosureObstruction = 0

namespace TruncationLevel

/-- Contractible type (level -2, encoded as 0). -/
def contractible : TruncationLevel where
  level := 0
  numElements := 1
  prop_bound := fun _ => by omega
  piClosureObstruction := 0
  piClosure_zero := rfl
  sigmaClosureObstruction := 0
  sigmaClosure_zero := rfl

/-- Proposition (level -1, encoded as 1). -/
def proposition : TruncationLevel where
  level := 1
  numElements := 1
  prop_bound := fun _ => by omega
  piClosureObstruction := 0
  piClosure_zero := rfl
  sigmaClosureObstruction := 0
  sigmaClosure_zero := rfl

/-- Set (level 0, encoded as 2). -/
def set_ (n : Nat) : TruncationLevel where
  level := 2
  numElements := n
  prop_bound := fun h => by omega
  piClosureObstruction := 0
  piClosure_zero := rfl
  sigmaClosureObstruction := 0
  sigmaClosure_zero := rfl

/-- Path: Î -closure. -/
def pi_closure_path (tl : TruncationLevel) :
    Path tl.piClosureObstruction 0 :=
  Path.ofEq tl.piClosure_zero

/-- Path: Î£-closure. -/
def sigma_closure_path (tl : TruncationLevel) :
    Path tl.sigmaClosureObstruction 0 :=
  Path.ofEq tl.sigmaClosure_zero

end TruncationLevel

/-! ## Master Coherence Paths -/

/-- Master: MLTT consistency. -/
def master_mltt_consistency_path :
    Path MLTTData.standard.consistencyObstruction 0 :=
  MLTTData.standard.consistency_path

/-- Master: J computation. -/
def master_j_path :
    Path IdentityTypeData.intensional.jComputeObstruction 0 :=
  IdentityTypeData.intensional.identity_j_path

/-- Master: Î  Î²-reduction. -/
def master_pi_beta_path :
    Path (PiTypeData.simple 2 3 (by omega)).betaObstruction 0 :=
  (PiTypeData.simple 2 3 (by omega)).pi_beta_path

/-- Master: Î£ Î·-expansion. -/
def master_sigma_eta_path :
    Path SigmaTypeData.unit.etaObstruction 0 :=
  SigmaTypeData.unit.sigma_eta_path

/-- Master: W-type induction. -/
def master_wtype_path :
    Path WTypeData.natW.inductionObstruction 0 :=
  WTypeData.natW.wtype_induction_path

/-- Master: univalence. -/
def master_univalence_path :
    Path UnivalenceData.standard.idToEquivObstruction 0 :=
  UnivalenceData.standard.univalence_path

/-- Master: function extensionality. -/
def master_funext_path :
    Path (FunExtData.standard 1 (by omega)).derivationObstruction 0 :=
  (FunExtData.standard 1 (by omega)).funext_derivation_path

/-- Master: propositional truncation. -/
def master_proptrunc_path :
    Path PropTruncData.singleton.propObstruction 0 :=
  PropTruncData.singleton.proptrunc_path

/-- Master: HIT elimination. -/
def master_hit_path :
    Path HITData.circle.elimObstruction 0 :=
  HITData.circle.hit_elim_path

/-- Master: truncation level Î -closure. -/
def master_trunc_path :
    Path TruncationLevel.contractible.piClosureObstruction 0 :=
  TruncationLevel.contractible.pi_closure_path

end TypeTheoryFoundations
end ComputationalPaths
