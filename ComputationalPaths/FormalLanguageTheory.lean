/-
# Formal Language Theory via Computational Paths

This module formalizes formal language theory — the Chomsky hierarchy
(Type 0-3), closure properties across the hierarchy, decision problems,
the word problem for groups, automatic structures, tree automata, and
weighted automata — all with `Path` coherence witnesses.

## Mathematical Background

Formal language theory classifies languages by the computational power
needed to recognize or generate them:

1. **Chomsky Hierarchy**: Four levels of formal grammars/languages:
   - Type 3 (Regular): recognized by finite automata, generated by
     regular (right-linear) grammars.
   - Type 2 (Context-Free): recognized by pushdown automata, generated
     by context-free grammars.
   - Type 1 (Context-Sensitive): recognized by linear bounded automata,
     generated by context-sensitive grammars (|α| ≤ |β| for α → β).
   - Type 0 (Recursively Enumerable): recognized by Turing machines,
     generated by unrestricted grammars.
2. **Closure Properties**: Regular languages are closed under all Boolean
   operations, concatenation, and Kleene star. CFLs are closed under
   union, concatenation, and star but NOT intersection or complement.
   CSLs are closed under all Boolean operations. RE languages are closed
   under union, intersection, concatenation, and star but NOT complement.
3. **Decision Problems**: Membership, emptiness, finiteness, equivalence,
   containment, and universality. Decidability varies across the hierarchy:
   all decidable for regular, membership/emptiness decidable for CFL,
   membership decidable for CSL, only membership semi-decidable for RE.
4. **Word Problem for Groups**: Given a finitely presented group G = ⟨S|R⟩,
   determine if a word over S represents the identity. Novikov-Boone:
   undecidable in general, decidable for hyperbolic groups (linear time),
   automatic groups (quadratic time).
5. **Automatic Structures**: A structure is automatic if its domain and
   relations are recognized by synchronous multi-tape finite automata.
   Automatic structures have decidable first-order theory.
6. **Tree Automata**: Finite automata operating on trees (terms). Bottom-up
   tree automata: process leaves to root. Top-down: root to leaves.
   Closed under Boolean operations. Connection to MSO logic on trees.
7. **Weighted Automata**: Automata with transitions labeled by elements of
   a semiring (e.g., probabilities, costs). The behavior is a formal power
   series. Applications in speech recognition, bioinformatics.

## Key Results

| Definition/Theorem | Description |
|-------------------|-------------|
| `ChomskyLevelData` | Chomsky hierarchy level data |
| `ChomskyHierarchyData` | Full hierarchy comparison |
| `ClosureTableData` | Closure properties across hierarchy |
| `DecisionProblemData` | Decision problem classification |
| `WordProblemData` | Word problem for groups |
| `AutomaticStructureData` | Automatic structure data |
| `TreeAutomatonData` | Tree automaton data |
| `WeightedAutomatonData` | Weighted automaton data |
| `hierarchy_containment_path` | Hierarchy containment coherence |
| `closure_path` | Closure property coherence |
| `decision_path` | Decision problem coherence |
| `word_problem_path` | Word problem coherence |
| `tree_automaton_path` | Tree automaton coherence |
| `weighted_path` | Weighted automaton coherence |

## References

- Chomsky, "Three Models for the Description of Language" (1956)
- Hopcroft, Motwani, Ullman, "Introduction to Automata Theory" (3rd ed., 2006)
- Sipser, "Introduction to the Theory of Computation" (3rd ed., 2012)
- Epstein et al., "Word Processing in Groups" (1992)
- Comon et al., "Tree Automata Techniques and Applications" (2007)
- Droste, Kuich, Vogler, "Handbook of Weighted Automata" (2009)
-/

import ComputationalPaths.Path.Basic

namespace ComputationalPaths
namespace FormalLanguageTheory

open Path

/-! ## Chomsky Hierarchy Levels -/

/-- Data for a single level of the Chomsky hierarchy. -/
structure ChomskyLevelData where
  /-- Level number (0 = RE, 1 = CS, 2 = CF, 3 = Regular). -/
  level : Nat
  /-- level ≤ 3. -/
  level_le : level ≤ 3
  /-- Recognizing automaton type (0=TM, 1=LBA, 2=PDA, 3=FA). -/
  automatonType : Nat
  /-- automatonType = level. -/
  automaton_eq : automatonType = level
  /-- Whether membership is decidable. -/
  membershipDecidable : Bool
  /-- Whether emptiness is decidable. -/
  emptinessDecidable : Bool
  /-- Whether equivalence is decidable. -/
  equivalenceDecidable : Bool
  /-- Number of decidable decision problems (out of 6 standard ones). -/
  numDecidableProblems : Nat
  /-- Regular has all 6 decidable; CF has 2; CS has 1; RE has 0 decidable. -/
  decidable_count_le : numDecidableProblems ≤ 6

namespace ChomskyLevelData

/-- Type 3: Regular languages. -/
def regular : ChomskyLevelData where
  level := 3
  level_le := by omega
  automatonType := 3
  automaton_eq := rfl
  membershipDecidable := true
  emptinessDecidable := true
  equivalenceDecidable := true
  numDecidableProblems := 6
  decidable_count_le := by omega

/-- Type 2: Context-free languages. -/
def contextFree : ChomskyLevelData where
  level := 2
  level_le := by omega
  automatonType := 2
  automaton_eq := rfl
  membershipDecidable := true
  emptinessDecidable := true
  equivalenceDecidable := false
  numDecidableProblems := 3
  decidable_count_le := by omega

/-- Type 1: Context-sensitive languages. -/
def contextSensitive : ChomskyLevelData where
  level := 1
  level_le := by omega
  automatonType := 1
  automaton_eq := rfl
  membershipDecidable := true
  emptinessDecidable := false
  equivalenceDecidable := false
  numDecidableProblems := 1
  decidable_count_le := by omega

/-- Type 0: Recursively enumerable languages. -/
def recursivelyEnumerable : ChomskyLevelData where
  level := 0
  level_le := by omega
  automatonType := 0
  automaton_eq := rfl
  membershipDecidable := false
  emptinessDecidable := false
  equivalenceDecidable := false
  numDecidableProblems := 0
  decidable_count_le := by omega

/-- Path: automaton type matches level. -/
def automaton_path (cl : ChomskyLevelData) :
    Path cl.automatonType cl.level :=
  Path.ofEq cl.automaton_eq

end ChomskyLevelData

/-! ## Chomsky Hierarchy Containment -/

/-- Full Chomsky hierarchy containment data. -/
structure ChomskyHierarchyData where
  /-- Number of levels. -/
  numLevels : Nat
  /-- numLevels = 4. -/
  levels_eq : numLevels = 4
  /-- Whether containments are strict. -/
  isStrict : Bool
  /-- Containments are strict. -/
  strict_eq : isStrict = true
  /-- Regular ⊊ CF. -/
  reg_in_cf : Bool
  /-- reg_in_cf. -/
  reg_cf_eq : reg_in_cf = true
  /-- CF ⊊ CS. -/
  cf_in_cs : Bool
  /-- cf_in_cs. -/
  cf_cs_eq : cf_in_cs = true
  /-- CS ⊊ RE. -/
  cs_in_re : Bool
  /-- cs_in_re. -/
  cs_re_eq : cs_in_re = true
  /-- Containment obstruction (0 if all strict). -/
  containmentObstruction : Nat
  /-- Obstruction is 0. -/
  obstruction_eq : containmentObstruction = 0

namespace ChomskyHierarchyData

/-- Standard Chomsky hierarchy. -/
def standard : ChomskyHierarchyData where
  numLevels := 4
  levels_eq := rfl
  isStrict := true
  strict_eq := rfl
  reg_in_cf := true
  reg_cf_eq := rfl
  cf_in_cs := true
  cf_cs_eq := rfl
  cs_in_re := true
  cs_re_eq := rfl
  containmentObstruction := 0
  obstruction_eq := rfl

/-- Path: number of levels. -/
def levels_path (ch : ChomskyHierarchyData) :
    Path ch.numLevels 4 :=
  Path.ofEq ch.levels_eq

/-- Path: strictness. -/
def strict_path (ch : ChomskyHierarchyData) :
    Path ch.isStrict true :=
  Path.ofEq ch.strict_eq

/-- Path: containment obstruction. -/
def obstruction_path (ch : ChomskyHierarchyData) :
    Path ch.containmentObstruction 0 :=
  Path.ofEq ch.obstruction_eq

end ChomskyHierarchyData

/-! ## Closure Properties Table -/

/-- Closure property data across the Chomsky hierarchy. -/
structure ClosureTableData where
  /-- Hierarchy level (0-3). -/
  level : Nat
  /-- level ≤ 3. -/
  level_le : level ≤ 3
  /-- Closed under union. -/
  unionClosed : Bool
  /-- Closed under intersection. -/
  intersectionClosed : Bool
  /-- Closed under complement. -/
  complementClosed : Bool
  /-- Closed under concatenation. -/
  concatClosed : Bool
  /-- Closed under Kleene star. -/
  starClosed : Bool
  /-- Number of closure properties (out of 5). -/
  numClosureProps : Nat
  /-- numClosureProps consistent. -/
  closure_eq : numClosureProps = (if unionClosed then 1 else 0) +
               (if intersectionClosed then 1 else 0) +
               (if complementClosed then 1 else 0) +
               (if concatClosed then 1 else 0) +
               (if starClosed then 1 else 0)

namespace ClosureTableData

/-- Regular languages: all 5 closure properties. -/
def regular : ClosureTableData where
  level := 3
  level_le := by omega
  unionClosed := true
  intersectionClosed := true
  complementClosed := true
  concatClosed := true
  starClosed := true
  numClosureProps := 5
  closure_eq := by simp

/-- Context-free languages: 3 out of 5. -/
def contextFree : ClosureTableData where
  level := 2
  level_le := by omega
  unionClosed := true
  intersectionClosed := false
  complementClosed := false
  concatClosed := true
  starClosed := true
  numClosureProps := 3
  closure_eq := by simp

/-- Context-sensitive languages: all 5. -/
def contextSensitive : ClosureTableData where
  level := 1
  level_le := by omega
  unionClosed := true
  intersectionClosed := true
  complementClosed := true
  concatClosed := true
  starClosed := true
  numClosureProps := 5
  closure_eq := by simp

/-- RE languages: 4 out of 5 (not complement). -/
def recursivelyEnumerable : ClosureTableData where
  level := 0
  level_le := by omega
  unionClosed := true
  intersectionClosed := true
  complementClosed := false
  concatClosed := true
  starClosed := true
  numClosureProps := 4
  closure_eq := by simp

/-- Path: closure count. -/
def closure_count_path (ct : ClosureTableData) :
    Path ct.numClosureProps
      ((if ct.unionClosed then 1 else 0) +
       (if ct.intersectionClosed then 1 else 0) +
       (if ct.complementClosed then 1 else 0) +
       (if ct.concatClosed then 1 else 0) +
       (if ct.starClosed then 1 else 0)) :=
  Path.ofEq ct.closure_eq

end ClosureTableData

/-! ## Decision Problems -/

/-- Decision problem data. -/
structure DecisionProblemData where
  /-- Problem name identifier. -/
  problemId : Nat
  /-- Hierarchy level (0-3). -/
  level : Nat
  /-- level ≤ 3. -/
  level_le : level ≤ 3
  /-- Whether the problem is decidable at this level. -/
  isDecidable : Bool
  /-- Whether the problem is semi-decidable. -/
  isSemiDecidable : Bool
  /-- decidable → semi-decidable. -/
  decidable_implies : isDecidable = true → isSemiDecidable = true
  /-- Complexity class (0=constant, 1=linear, 2=poly, 3=exp, 4=undecidable). -/
  complexityClass : Nat

namespace DecisionProblemData

/-- Membership for regular languages (decidable, linear). -/
def membershipRegular : DecisionProblemData where
  problemId := 0
  level := 3
  level_le := by omega
  isDecidable := true
  isSemiDecidable := true
  decidable_implies := fun _ => rfl
  complexityClass := 1

/-- Membership for CFLs (decidable, cubic via CYK). -/
def membershipCFL : DecisionProblemData where
  problemId := 0
  level := 2
  level_le := by omega
  isDecidable := true
  isSemiDecidable := true
  decidable_implies := fun _ => rfl
  complexityClass := 2

/-- Membership for RE (semi-decidable only). -/
def membershipRE : DecisionProblemData where
  problemId := 0
  level := 0
  level_le := by omega
  isDecidable := false
  isSemiDecidable := true
  decidable_implies := fun h => by simp at h
  complexityClass := 4

/-- Equivalence for regular languages (decidable). -/
def equivalenceRegular : DecisionProblemData where
  problemId := 4
  level := 3
  level_le := by omega
  isDecidable := true
  isSemiDecidable := true
  decidable_implies := fun _ => rfl
  complexityClass := 2

/-- Equivalence for CFLs (undecidable). -/
def equivalenceCFL : DecisionProblemData where
  problemId := 4
  level := 2
  level_le := by omega
  isDecidable := false
  isSemiDecidable := false
  decidable_implies := fun h => by simp at h
  complexityClass := 4

end DecisionProblemData

/-! ## Word Problem for Groups -/

/-- Word problem data for finitely presented groups. -/
structure WordProblemData where
  /-- Number of generators. -/
  numGenerators : Nat
  /-- numGenerators is positive. -/
  numGenerators_pos : numGenerators > 0
  /-- Number of relations. -/
  numRelations : Nat
  /-- Whether the word problem is decidable for this group. -/
  isDecidable : Bool
  /-- Whether the group is automatic. -/
  isAutomatic : Bool
  /-- Whether the group is hyperbolic. -/
  isHyperbolic : Bool
  /-- Hyperbolic → automatic. -/
  hyperbolic_implies : isHyperbolic = true → isAutomatic = true
  /-- Automatic → decidable. -/
  automatic_implies : isAutomatic = true → isDecidable = true
  /-- Complexity of word problem (if decidable): 0=linear, 1=quadratic, 2=exp. -/
  wordProblemComplexity : Nat
  /-- Consistency: undecidable means no complexity. -/
  complexity_consistency : isDecidable = false → wordProblemComplexity = 0

namespace WordProblemData

/-- Free group (decidable, linear time). -/
def freeGroup (n : Nat) (hn : n > 0) : WordProblemData where
  numGenerators := n
  numGenerators_pos := hn
  numRelations := 0
  isDecidable := true
  isAutomatic := true
  isHyperbolic := true
  hyperbolic_implies := fun _ => rfl
  automatic_implies := fun _ => rfl
  wordProblemComplexity := 0
  complexity_consistency := fun h => by simp at h

/-- A finitely presented group with undecidable word problem. -/
def undecidable : WordProblemData where
  numGenerators := 4
  numGenerators_pos := by omega
  numRelations := 12
  isDecidable := false
  isAutomatic := false
  isHyperbolic := false
  hyperbolic_implies := fun h => by simp at h
  automatic_implies := fun h => by simp at h
  wordProblemComplexity := 0
  complexity_consistency := fun _ => rfl

/-- An automatic group (quadratic word problem). -/
def automaticGroup (n r : Nat) (hn : n > 0) : WordProblemData where
  numGenerators := n
  numGenerators_pos := hn
  numRelations := r
  isDecidable := true
  isAutomatic := true
  isHyperbolic := false
  hyperbolic_implies := fun h => by simp at h
  automatic_implies := fun _ => rfl
  wordProblemComplexity := 1
  complexity_consistency := fun h => by simp at h

end WordProblemData

/-! ## Automatic Structures -/

/-- Automatic structure data. -/
structure AutomaticStructureData where
  /-- Number of relations in the structure. -/
  numRelations : Nat
  /-- Alphabet size. -/
  alphabetSize : Nat
  /-- alphabetSize is positive. -/
  alphabetSize_pos : alphabetSize > 0
  /-- Number of automata (one per relation + domain). -/
  numAutomata : Nat
  /-- numAutomata = numRelations + 1 (domain automaton). -/
  automata_eq : numAutomata = numRelations + 1
  /-- Whether FO theory is decidable. -/
  foDecidable : Bool
  /-- Automatic → FO decidable. -/
  fo_decidable_eq : foDecidable = true
  /-- Whether the structure is FA-presentable. -/
  isFAPresentable : Bool
  /-- FA-presentability. -/
  fa_presentable_eq : isFAPresentable = true

namespace AutomaticStructureData

/-- Presburger arithmetic (ℕ, +) is automatic. -/
def presburger : AutomaticStructureData where
  numRelations := 1
  alphabetSize := 2
  alphabetSize_pos := by omega
  numAutomata := 2
  automata_eq := by omega
  foDecidable := true
  fo_decidable_eq := rfl
  isFAPresentable := true
  fa_presentable_eq := rfl

/-- Automatic structure with n relations over k-symbol alphabet. -/
def ofSize (n k : Nat) (hk : k > 0) : AutomaticStructureData where
  numRelations := n
  alphabetSize := k
  alphabetSize_pos := hk
  numAutomata := n + 1
  automata_eq := rfl
  foDecidable := true
  fo_decidable_eq := rfl
  isFAPresentable := true
  fa_presentable_eq := rfl

/-- Path: number of automata. -/
def automata_path (asd : AutomaticStructureData) :
    Path asd.numAutomata (asd.numRelations + 1) :=
  Path.ofEq asd.automata_eq

/-- Path: FO decidability. -/
def fo_decidable_path (asd : AutomaticStructureData) :
    Path asd.foDecidable true :=
  Path.ofEq asd.fo_decidable_eq

end AutomaticStructureData

/-! ## Tree Automata -/

/-- Tree automaton data. -/
structure TreeAutomatonData where
  /-- Number of states. -/
  numStates : Nat
  /-- numStates is positive. -/
  numStates_pos : numStates > 0
  /-- Ranked alphabet size. -/
  alphabetSize : Nat
  /-- alphabetSize is positive. -/
  alphabetSize_pos : alphabetSize > 0
  /-- Maximum rank (arity of symbols). -/
  maxRank : Nat
  /-- Number of transition rules. -/
  numTransitions : Nat
  /-- numTransitions is positive. -/
  numTransitions_pos : numTransitions > 0
  /-- Whether it's a bottom-up automaton. -/
  isBottomUp : Bool
  /-- Whether it's deterministic. -/
  isDeterministic : Bool
  /-- Closed under complement. -/
  complementClosed : Bool
  /-- complement_eq. -/
  complement_eq : complementClosed = true
  /-- Closed under intersection. -/
  intersectionClosed : Bool
  /-- intersection_eq. -/
  intersection_eq : intersectionClosed = true
  /-- Closed under union. -/
  unionClosed : Bool
  /-- union_eq. -/
  union_eq : unionClosed = true

namespace TreeAutomatonData

/-- A simple bottom-up deterministic tree automaton. -/
def simpleBUTA : TreeAutomatonData where
  numStates := 3
  numStates_pos := by omega
  alphabetSize := 2
  alphabetSize_pos := by omega
  maxRank := 2
  numTransitions := 5
  numTransitions_pos := by omega
  isBottomUp := true
  isDeterministic := true
  complementClosed := true
  complement_eq := rfl
  intersectionClosed := true
  intersection_eq := rfl
  unionClosed := true
  union_eq := rfl

/-- A nondeterministic top-down tree automaton. -/
def ndTopDown : TreeAutomatonData where
  numStates := 4
  numStates_pos := by omega
  alphabetSize := 3
  alphabetSize_pos := by omega
  maxRank := 2
  numTransitions := 8
  numTransitions_pos := by omega
  isBottomUp := false
  isDeterministic := false
  complementClosed := true
  complement_eq := rfl
  intersectionClosed := true
  intersection_eq := rfl
  unionClosed := true
  union_eq := rfl

/-- Path: complement closure. -/
def complement_path (ta : TreeAutomatonData) :
    Path ta.complementClosed true :=
  Path.ofEq ta.complement_eq

/-- Path: intersection closure. -/
def intersection_path (ta : TreeAutomatonData) :
    Path ta.intersectionClosed true :=
  Path.ofEq ta.intersection_eq

/-- Path: union closure. -/
def union_path (ta : TreeAutomatonData) :
    Path ta.unionClosed true :=
  Path.ofEq ta.union_eq

end TreeAutomatonData

/-! ## Weighted Automata -/

/-- Weighted automaton data. -/
structure WeightedAutomatonData where
  /-- Number of states. -/
  numStates : Nat
  /-- numStates is positive. -/
  numStates_pos : numStates > 0
  /-- Alphabet size. -/
  alphabetSize : Nat
  /-- alphabetSize is positive. -/
  alphabetSize_pos : alphabetSize > 0
  /-- Semiring type (0=Boolean, 1=Natural, 2=Tropical, 3=Probabilistic). -/
  semiringType : Nat
  /-- semiringType ≤ 3. -/
  semiring_le : semiringType ≤ 3
  /-- Number of transitions. -/
  numTransitions : Nat
  /-- Maximum transitions = |Q|² × |Σ|. -/
  maxTransitions : Nat
  /-- max = numStates^2 * alphabetSize. -/
  max_eq : maxTransitions = numStates ^ 2 * alphabetSize
  /-- numTransitions ≤ maxTransitions. -/
  transitions_le : numTransitions ≤ maxTransitions
  /-- Whether the automaton is deterministic. -/
  isDeterministic : Bool

namespace WeightedAutomatonData

/-- Boolean semiring (equivalent to NFA). -/
def booleanNFA : WeightedAutomatonData where
  numStates := 3
  numStates_pos := by omega
  alphabetSize := 2
  alphabetSize_pos := by omega
  semiringType := 0
  semiring_le := by omega
  numTransitions := 5
  maxTransitions := 18
  max_eq := by omega
  transitions_le := by omega
  isDeterministic := false

/-- Probabilistic automaton. -/
def probabilistic : WeightedAutomatonData where
  numStates := 4
  numStates_pos := by omega
  alphabetSize := 2
  alphabetSize_pos := by omega
  semiringType := 3
  semiring_le := by omega
  numTransitions := 10
  maxTransitions := 32
  max_eq := by omega
  transitions_le := by omega
  isDeterministic := true

/-- Tropical semiring automaton (min-plus). -/
def tropical : WeightedAutomatonData where
  numStates := 2
  numStates_pos := by omega
  alphabetSize := 3
  alphabetSize_pos := by omega
  semiringType := 2
  semiring_le := by omega
  numTransitions := 8
  maxTransitions := 12
  max_eq := by omega
  transitions_le := by omega
  isDeterministic := true

/-- Path: max transitions. -/
def max_path (wa : WeightedAutomatonData) :
    Path wa.maxTransitions (wa.numStates ^ 2 * wa.alphabetSize) :=
  Path.ofEq wa.max_eq

end WeightedAutomatonData

/-! ## MSO Logic on Trees -/

/-- MSO (monadic second-order) logic on trees data. -/
structure MSOTreeData where
  /-- Number of set quantifiers. -/
  numSetQuantifiers : Nat
  /-- Number of individual quantifiers. -/
  numIndividualQuantifiers : Nat
  /-- Total quantifier complexity. -/
  totalComplexity : Nat
  /-- totalComplexity = numSetQuantifiers + numIndividualQuantifiers. -/
  complexity_eq : totalComplexity = numSetQuantifiers + numIndividualQuantifiers
  /-- Whether the MSO formula is decidable on trees (Rabin's theorem). -/
  isDecidable : Bool
  /-- Rabin's theorem: MSO on infinite trees is decidable. -/
  decidable_eq : isDecidable = true
  /-- Equivalent tree automaton states. -/
  automatonStates : Nat
  /-- automatonStates is positive. -/
  automaton_pos : automatonStates > 0

namespace MSOTreeData

/-- Simple MSO formula with 1 set quantifier. -/
def simple : MSOTreeData where
  numSetQuantifiers := 1
  numIndividualQuantifiers := 2
  totalComplexity := 3
  complexity_eq := by omega
  isDecidable := true
  decidable_eq := rfl
  automatonStates := 4
  automaton_pos := by omega

/-- Path: complexity. -/
def complexity_path (mso : MSOTreeData) :
    Path mso.totalComplexity (mso.numSetQuantifiers + mso.numIndividualQuantifiers) :=
  Path.ofEq mso.complexity_eq

/-- Path: decidability (Rabin). -/
def decidable_path (mso : MSOTreeData) :
    Path mso.isDecidable true :=
  Path.ofEq mso.decidable_eq

end MSOTreeData

/-! ## Star-Free Languages -/

/-- Star-free language data (counter-free automata, FO-definable). -/
structure StarFreeData where
  /-- Whether the language is star-free. -/
  isStarFree : Bool
  /-- Whether the language is FO-definable. -/
  isFODefinable : Bool
  /-- Star-free ↔ FO-definable (McNaughton-Papert theorem). -/
  mcnaughton_papert : isStarFree = isFODefinable
  /-- Whether the syntactic monoid is aperiodic. -/
  isAperiodic : Bool
  /-- Star-free ↔ aperiodic (Schützenberger's theorem). -/
  schutzenberger : isStarFree = isAperiodic
  /-- Obstruction to star-freeness (0 if star-free). -/
  obstruction : Nat
  /-- star-free → obstruction = 0. -/
  sf_obstruction : isStarFree = true → obstruction = 0

namespace StarFreeData

/-- A star-free language. -/
def starFree : StarFreeData where
  isStarFree := true
  isFODefinable := true
  mcnaughton_papert := rfl
  isAperiodic := true
  schutzenberger := rfl
  obstruction := 0
  sf_obstruction := fun _ => rfl

/-- A non-star-free language (e.g., (aa)*). -/
def nonStarFree : StarFreeData where
  isStarFree := false
  isFODefinable := false
  mcnaughton_papert := rfl
  isAperiodic := false
  schutzenberger := rfl
  obstruction := 1
  sf_obstruction := fun h => by simp at h

/-- Path: McNaughton-Papert. -/
def mp_path (sf : StarFreeData) :
    Path sf.isStarFree sf.isFODefinable :=
  Path.ofEq sf.mcnaughton_papert

/-- Path: Schützenberger. -/
def schutz_path (sf : StarFreeData) :
    Path sf.isStarFree sf.isAperiodic :=
  Path.ofEq sf.schutzenberger

end StarFreeData

/-! ## Language Complexity Comparison -/

/-- Comparison data between two language classes. -/
structure LanguageComparisonData where
  /-- Lower class level. -/
  lowerLevel : Nat
  /-- Upper class level. -/
  upperLevel : Nat
  /-- lowerLevel < upperLevel (strict containment, using Chomsky numbering reversed). -/
  levels_ordered : lowerLevel < upperLevel
  /-- Separation example: a language in upper but not lower. -/
  hasSeparation : Bool
  /-- Separation exists. -/
  separation_eq : hasSeparation = true
  /-- Containment holds. -/
  containmentHolds : Bool
  /-- Containment. -/
  containment_eq : containmentHolds = true

namespace LanguageComparisonData

/-- Regular ⊊ Context-Free. -/
def regVsCF : LanguageComparisonData where
  lowerLevel := 0
  upperLevel := 1
  levels_ordered := by omega
  hasSeparation := true
  separation_eq := rfl
  containmentHolds := true
  containment_eq := rfl

/-- Context-Free ⊊ Context-Sensitive. -/
def cfVsCS : LanguageComparisonData where
  lowerLevel := 1
  upperLevel := 2
  levels_ordered := by omega
  hasSeparation := true
  separation_eq := rfl
  containmentHolds := true
  containment_eq := rfl

/-- Context-Sensitive ⊊ Recursive ⊊ RE. -/
def csVsRE : LanguageComparisonData where
  lowerLevel := 2
  upperLevel := 3
  levels_ordered := by omega
  hasSeparation := true
  separation_eq := rfl
  containmentHolds := true
  containment_eq := rfl

/-- Path: separation. -/
def separation_path (lc : LanguageComparisonData) :
    Path lc.hasSeparation true :=
  Path.ofEq lc.separation_eq

/-- Path: containment. -/
def containment_path (lc : LanguageComparisonData) :
    Path lc.containmentHolds true :=
  Path.ofEq lc.containment_eq

end LanguageComparisonData

/-! ## Master Coherence Paths -/

/-- Master: Chomsky hierarchy levels. -/
def master_hierarchy_levels_path :
    Path ChomskyHierarchyData.standard.numLevels 4 :=
  ChomskyHierarchyData.standard.levels_path

/-- Master: hierarchy strictness. -/
def master_hierarchy_strict_path :
    Path ChomskyHierarchyData.standard.isStrict true :=
  ChomskyHierarchyData.standard.strict_path

/-- Master: hierarchy containment obstruction. -/
def master_hierarchy_obstruction_path :
    Path ChomskyHierarchyData.standard.containmentObstruction 0 :=
  ChomskyHierarchyData.standard.obstruction_path

/-- Master: regular closure properties (all 5). -/
def master_regular_closure_path :
    Path ClosureTableData.regular.numClosureProps 5 := by
  have h := ClosureTableData.regular.closure_eq
  exact Path.ofEq h

/-- Master: CFL closure properties (3 of 5). -/
def master_cfl_closure_path :
    Path ClosureTableData.contextFree.numClosureProps 3 := by
  have h := ClosureTableData.contextFree.closure_eq
  exact Path.ofEq h

/-- Master: RE closure properties (4 of 5). -/
def master_re_closure_path :
    Path ClosureTableData.recursivelyEnumerable.numClosureProps 4 := by
  have h := ClosureTableData.recursivelyEnumerable.closure_eq
  exact Path.ofEq h

/-- Master: automatic structure FO decidability. -/
def master_automatic_fo_path :
    Path AutomaticStructureData.presburger.foDecidable true :=
  AutomaticStructureData.presburger.fo_decidable_path

/-- Master: tree automaton complement closure. -/
def master_tree_complement_path :
    Path TreeAutomatonData.simpleBUTA.complementClosed true :=
  TreeAutomatonData.simpleBUTA.complement_path

/-- Master: weighted automaton max transitions. -/
def master_weighted_max_path :
    Path WeightedAutomatonData.booleanNFA.maxTransitions 18 :=
  WeightedAutomatonData.booleanNFA.max_path

/-- Master: MSO decidability on trees. -/
def master_mso_decidable_path :
    Path MSOTreeData.simple.isDecidable true :=
  MSOTreeData.simple.decidable_path

/-- Master: star-free = FO-definable (McNaughton-Papert). -/
def master_mcnaughton_papert_path :
    Path StarFreeData.starFree.isStarFree StarFreeData.starFree.isFODefinable :=
  StarFreeData.starFree.mp_path

/-- Master: Reg ⊊ CF separation. -/
def master_reg_cf_separation_path :
    Path LanguageComparisonData.regVsCF.hasSeparation true :=
  LanguageComparisonData.regVsCF.separation_path

end FormalLanguageTheory
end ComputationalPaths
