import CompPaths.Core
import ComputationalPaths.Path.Rewrite.Quot

namespace CompPaths
namespace Context

open ComputationalPaths
open ComputationalPaths.Path
open scoped Quot

universe u

/-- A set of explicit `RwEq` witnesses available as closure seeds. -/
abbrev RwEqWitnessSet (A : Type u) : Type u :=
  ∀ {a b : A} {p q : Path a b}, RwEq p q → Prop

/-- Seed relation induced by a witness set. -/
def SeedRel {A : Type u} (W : RwEqWitnessSet A)
    {a b : A} (p q : Path a b) : Prop :=
  ∃ h : RwEq p q, W h

/-- Congruence closure generated by seed witnesses and `Path.trans` congruence rules. -/
inductive CongClosure {A : Type u} (W : RwEqWitnessSet A) :
    {a b : A} → Path a b → Path a b → Prop
  | seed {a b : A} {p q : Path a b} :
      SeedRel W p q → CongClosure W p q
  | refl {a b : A} (p : Path a b) :
      CongClosure W p p
  | symm {a b : A} {p q : Path a b} :
      CongClosure W p q → CongClosure W q p
  | trans {a b : A} {p q r : Path a b} :
      CongClosure W p q → CongClosure W q r → CongClosure W p r
  | trans_congr_left {a b c : A} {p p' : Path a b} (r : Path b c) :
      CongClosure W p p' →
      CongClosure W (Path.trans p r) (Path.trans p' r)
  | trans_congr_right {a b c : A} (p : Path a b) {q q' : Path b c} :
      CongClosure W q q' →
      CongClosure W (Path.trans p q) (Path.trans p q')

/-- Closure operator computed from a witness set. -/
abbrev computeClosure {A : Type u} (W : RwEqWitnessSet A) :
    {a b : A} → Path a b → Path a b → Prop :=
  CongClosure W

theorem closure_refl {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} (p : Path a b) :
    computeClosure W p p :=
  CongClosure.refl p

theorem closure_symm {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} {p q : Path a b} :
    computeClosure W p q → computeClosure W q p :=
  CongClosure.symm

theorem closure_trans {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} {p q r : Path a b} :
    computeClosure W p q → computeClosure W q r → computeClosure W p r :=
  CongClosure.trans

/-- Congruence closure is an equivalence relation on each hom-set `Path a b`. -/
theorem closure_is_equivalence {A : Type u} (W : RwEqWitnessSet A) (a b : A) :
    Equivalence (fun p q : Path a b => computeClosure W p q) := by
  refine ⟨?_, ?_, ?_⟩
  · intro p
    exact closure_refl (W := W) p
  · intro p q hpq
    exact closure_symm (W := W) hpq
  · intro p q r hpq hqr
    exact closure_trans (W := W) hpq hqr

def closureSetoid {A : Type u} (W : RwEqWitnessSet A) (a b : A) :
    Setoid (Path a b) where
  r := fun p q => computeClosure W p q
  iseqv := closure_is_equivalence W a b

theorem closure_trans_congr_left {A : Type u} {W : RwEqWitnessSet A}
    {a b c : A} {p p' : Path a b} (r : Path b c)
    (h : computeClosure W p p') :
    computeClosure W (Path.trans p r) (Path.trans p' r) :=
  CongClosure.trans_congr_left r h

theorem closure_trans_congr_right {A : Type u} {W : RwEqWitnessSet A}
    {a b c : A} (p : Path a b) {q q' : Path b c}
    (h : computeClosure W q q') :
    computeClosure W (Path.trans p q) (Path.trans p q') :=
  CongClosure.trans_congr_right p h

theorem closure_trans_congr {A : Type u} {W : RwEqWitnessSet A}
    {a b c : A} {p p' : Path a b} {q q' : Path b c}
    (hp : computeClosure W p p') (hq : computeClosure W q q') :
    computeClosure W (Path.trans p q) (Path.trans p' q') := by
  exact closure_trans (W := W)
    (closure_trans_congr_left (W := W) q hp)
    (closure_trans_congr_right (W := W) p' hq)

/-- Every closure derivation yields a `Prop`-level rewrite witness. -/
theorem closure_sound_prop {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} {p q : Path a b} :
    computeClosure W p q → RwEqProp p q := by
  intro h
  induction h with
  | seed hSeed =>
      rcases hSeed with ⟨hRwEq, _⟩
      exact rweqProp_of_rweq hRwEq
  | refl p =>
      exact rweqProp_of_rweq (RwEq.refl p)
  | symm h ih =>
      exact rweqProp_of_rweq (RwEq.symm (rweq_of_rweqProp ih))
  | trans h₁ h₂ ih₁ ih₂ =>
      exact rweqProp_of_rweq (RwEq.trans (rweq_of_rweqProp ih₁) (rweq_of_rweqProp ih₂))
  | trans_congr_left r h ih =>
      exact rweqProp_of_rweq (rweq_trans_congr_left r (rweq_of_rweqProp ih))
  | trans_congr_right p h ih =>
      exact rweqProp_of_rweq (rweq_trans_congr_right p (rweq_of_rweqProp ih))

/-- Every closure derivation can be reified as an actual `RwEq` witness. -/
noncomputable def closure_sound {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} {p q : Path a b} (h : computeClosure W p q) : RwEq p q :=
  rweq_of_rweqProp (closure_sound_prop (W := W) h)

/-- Canonical map from closure relation to the free groupoid quotient `PathRwQuot`. -/
@[simp] def toPathRwQuot {A : Type u} {a b : A} (p : Path a b) : PathRwQuot A a b :=
  Quot.mk _ p

theorem closure_toPathRwQuot_eq {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} {p q : Path a b} (h : computeClosure W p q) :
    toPathRwQuot p = toPathRwQuot q := by
  exact Quot.sound (closure_sound_prop (W := W) h)

abbrev ClosureQuot {A : Type u} (W : RwEqWitnessSet A) (a b : A) : Type u :=
  Quot (fun p q : Path a b => computeClosure W p q)

/-- Connection to the free groupoid quotient: every closure class has a canonical image. -/
def closureToFreeGroupoidQuot {A : Type u} (W : RwEqWitnessSet A) {a b : A} :
    ClosureQuot W a b → PathRwQuot A a b :=
  Quot.lift (fun p => toPathRwQuot p)
    (fun _ _ hpq => closure_toPathRwQuot_eq (W := W) hpq)

@[simp] theorem closureToFreeGroupoidQuot_mk {A : Type u} {W : RwEqWitnessSet A}
    {a b : A} (p : Path a b) :
    closureToFreeGroupoidQuot (A := A) W (Quot.mk _ p) = toPathRwQuot p := rfl

/-- Maximal witness set: every `RwEq` proof is available as a seed. -/
def allWitnesses (A : Type u) : RwEqWitnessSet A :=
  fun {_ _} {_ _} _ => True

theorem computeClosure_of_rweq {A : Type u}
    {a b : A} {p q : Path a b} (h : RwEq p q) :
    computeClosure (allWitnesses A) p q :=
  CongClosure.seed ⟨h, trivial⟩

end Context
end CompPaths
