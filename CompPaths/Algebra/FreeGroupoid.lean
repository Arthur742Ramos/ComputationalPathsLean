import CompPaths.Core
import ComputationalPaths.Path.Rewrite.Quot

namespace CompPaths
namespace Algebra

open ComputationalPaths
open ComputationalPaths.Path
open scoped Quot

universe u v w

noncomputable section

/-- A directed graph with typed edges. -/
structure Graph where
  Obj : Type u
  Edge : Obj → Obj → Type v

/-- The path graph generated by computational paths on a type. -/
def PathGraph (A : Type u) : Graph where
  Obj := A
  Edge := Path

/-- A Step-graph vertex for fixed endpoints is a raw computational path. -/
abbrev StepGraphVertex (A : Type u) (a b : A) : Type u :=
  Path a b

/-- A Step-graph edge is a primitive rewrite step between raw paths. -/
abbrev StepGraphEdge {A : Type u} {a b : A}
    (p q : StepGraphVertex A a b) : Type u :=
  Step p q

/-- Minimal groupoid interface used for free-groupoid constructions. -/
structure CPGroupoid where
  Obj : Type u
  Hom : Obj → Obj → Type v
  id : (a : Obj) → Hom a a
  comp : {a b c : Obj} → Hom a b → Hom b c → Hom a c
  inv : {a b : Obj} → Hom a b → Hom b a
  comp_assoc :
    ∀ {a b c d : Obj} (f : Hom a b) (g : Hom b c) (h : Hom c d),
      comp (comp f g) h = comp f (comp g h)
  id_comp :
    ∀ {a b : Obj} (f : Hom a b),
      comp (id a) f = f
  comp_id :
    ∀ {a b : Obj} (f : Hom a b),
      comp f (id b) = f
  inv_comp :
    ∀ {a b : Obj} (f : Hom a b),
      comp (inv f) f = id b
  comp_inv :
    ∀ {a b : Obj} (f : Hom a b),
      comp f (inv f) = id a

/-- Minimal functor interface between `CPGroupoid`s. -/
structure CPFunctor (G H : CPGroupoid) where
  obj : G.Obj → H.Obj
  map : {a b : G.Obj} → G.Hom a b → H.Hom (obj a) (obj b)
  map_id : ∀ a, map (G.id a) = H.id (obj a)
  map_comp :
    ∀ {a b c : G.Obj} (f : G.Hom a b) (g : G.Hom b c),
      map (G.comp f g) = H.comp (map f) (map g)
  map_inv :
    ∀ {a b : G.Obj} (f : G.Hom a b),
      map (G.inv f) = H.inv (map f)

section FreeGroupoidLaws

variable {A : Type u}

/-- Left identity in `PathRwQuot`, proved by an explicit `Step.trans_refl_left`. -/
theorem free_id_comp {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans (A := A) (PathRwQuot.refl (A := A) a) x = x := by
  refine Quot.inductionOn x (fun p => ?_)
  change Quot.mk _ (Path.trans (Path.refl a) p) = Quot.mk _ p
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_refl_left p)))

/-- Right identity in `PathRwQuot`, proved by an explicit `Step.trans_refl_right`. -/
theorem free_comp_id {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans (A := A) x (PathRwQuot.refl (A := A) b) = x := by
  refine Quot.inductionOn x (fun p => ?_)
  change Quot.mk _ (Path.trans p (Path.refl b)) = Quot.mk _ p
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_refl_right p)))

/-- Associativity in `PathRwQuot`, proved by explicit `Step.trans_assoc`. -/
theorem free_comp_assoc {a b c d : A}
    (x : PathRwQuot A a b) (y : PathRwQuot A b c) (z : PathRwQuot A c d) :
    PathRwQuot.trans (A := A) (PathRwQuot.trans (A := A) x y) z =
      PathRwQuot.trans (A := A) x (PathRwQuot.trans (A := A) y z) := by
  refine Quot.inductionOn x (fun p => ?_)
  refine Quot.inductionOn y (fun q => ?_)
  refine Quot.inductionOn z (fun r => ?_)
  change Quot.mk _ (Path.trans (Path.trans p q) r) =
    Quot.mk _ (Path.trans p (Path.trans q r))
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_assoc p q r)))

/-- Left inverse in `PathRwQuot`, proved by explicit `Step.symm_trans`. -/
theorem free_inv_comp {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans (A := A) (PathRwQuot.symm (A := A) x) x =
      PathRwQuot.refl (A := A) b := by
  refine Quot.inductionOn x (fun p => ?_)
  change Quot.mk _ (Path.trans (Path.symm p) p) = Quot.mk _ (Path.refl b)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.symm_trans p)))

/-- Right inverse in `PathRwQuot`, proved by explicit `Step.trans_symm`. -/
theorem free_comp_inv {a b : A} (x : PathRwQuot A a b) :
    PathRwQuot.trans (A := A) x (PathRwQuot.symm (A := A) x) =
      PathRwQuot.refl (A := A) a := by
  refine Quot.inductionOn x (fun p => ?_)
  change Quot.mk _ (Path.trans p (Path.symm p)) = Quot.mk _ (Path.refl a)
  exact Quot.sound (rweqProp_of_rweq (RwEq.step (Step.trans_symm p)))

end FreeGroupoidLaws

/-- Free groupoid on the computational-path graph of `A`:
objects are vertices `A`, morphisms are paths modulo `RwEq`. -/
def FreeGroupoid (A : Type u) : CPGroupoid where
  Obj := A
  Hom := fun a b => PathRwQuot A a b
  id := fun a => PathRwQuot.refl (A := A) a
  comp := fun {a b c} x y => PathRwQuot.trans (A := A) x y
  inv := fun {a b} x => PathRwQuot.symm (A := A) x
  comp_assoc := by
    intro a b c d x y z
    exact free_comp_assoc (A := A) x y z
  id_comp := by
    intro a b x
    exact free_id_comp (A := A) x
  comp_id := by
    intro a b x
    exact free_comp_id (A := A) x
  inv_comp := by
    intro a b x
    exact free_inv_comp (A := A) x
  comp_inv := by
    intro a b x
    exact free_comp_inv (A := A) x

/-- Raw computational paths embed as morphisms in the free groupoid. -/
def ofPath {A : Type u} {a b : A} (p : Path a b) :
    (FreeGroupoid A).Hom a b :=
  Quot.mk _ p

/-- Every Step edge yields equality of morphisms in the free-groupoid quotient. -/
theorem ofPath_eq_of_step {A : Type u} {a b : A}
    {p q : Path a b} (h : StepGraphEdge p q) :
    ofPath p = ofPath (A := A) q := by
  exact Quot.sound (rweqProp_of_rweq (RwEq.step h))

/-- Every `RwEq` class is represented by a morphism in `FreeGroupoid`. -/
theorem ofPath_eq_of_rweq {A : Type u} {a b : A}
    {p q : Path a b} (h : RwEq p q) :
    ofPath p = ofPath (A := A) q := by
  exact Quot.sound (rweqProp_of_rweq h)

/-- Graph morphism from the Step graph on `A` into a target groupoid. -/
structure StepGraphMorphism (A : Type u) (G : CPGroupoid.{v, w}) where
  obj : A → G.Obj
  onPath : {a b : A} → Path a b → G.Hom (obj a) (obj b)
  onRefl : ∀ a, onPath (Path.refl a) = G.id (obj a)
  onTrans : ∀ {a b c : A} (p : Path a b) (q : Path b c),
      onPath (Path.trans p q) = G.comp (onPath p) (onPath q)
  onSymm : ∀ {a b : A} (p : Path a b),
      onPath (Path.symm p) = G.inv (onPath p)
  onStep : ∀ {a b : A} {p q : Path a b},
      Step p q → onPath p = onPath q

namespace StepGraphMorphism

variable {A : Type u} {G : CPGroupoid.{v, w}}

/-- A Step-graph morphism respects the full `RwEq` closure by induction
on the `RwEq` constructors. -/
theorem onRwEq (F : StepGraphMorphism A G)
    {a b : A} {p q : Path a b} (h : RwEq p q) :
    F.onPath p = F.onPath q := by
  induction h with
  | refl p =>
      rfl
  | step hStep =>
      exact F.onStep hStep
  | symm h ih =>
      exact ih.symm
  | trans h₁ h₂ ih₁ ih₂ =>
      exact ih₁.trans ih₂

/-- A candidate factor through `PathRwQuot` for a fixed Step-graph morphism. -/
abbrev LiftHom (F : StepGraphMorphism A G) : Type (max u v w) :=
  {a b : A} → PathRwQuot A a b → G.Hom (F.obj a) (F.obj b)

/-- Canonical factorization map `PathRwQuot → G.Hom` induced by `F`. -/
noncomputable def factorHom (F : StepGraphMorphism A G) : LiftHom F :=
  fun {a b} =>
    Quot.lift
      (fun p => F.onPath p)
      (fun p q h => F.onRwEq (rweq_of_rweqProp h))

@[simp] theorem factorHom_mk (F : StepGraphMorphism A G)
    {a b : A} (p : Path a b) :
    factorHom F (Quot.mk _ p) = F.onPath p := rfl

@[simp] theorem factorHom_refl (F : StepGraphMorphism A G) (a : A) :
    factorHom F (PathRwQuot.refl (A := A) a) = G.id (F.obj a) := by
  simpa [factorHom] using F.onRefl a

@[simp] theorem factorHom_trans (F : StepGraphMorphism A G)
    {a b c : A} (x : PathRwQuot A a b) (y : PathRwQuot A b c) :
    factorHom F (PathRwQuot.trans (A := A) x y) =
      G.comp (factorHom F x) (factorHom F y) := by
  refine Quot.inductionOn x (fun p => ?_)
  refine Quot.inductionOn y (fun q => ?_)
  simpa [factorHom] using F.onTrans p q

@[simp] theorem factorHom_symm (F : StepGraphMorphism A G)
    {a b : A} (x : PathRwQuot A a b) :
    factorHom F (PathRwQuot.symm (A := A) x) =
      G.inv (factorHom F x) := by
  refine Quot.inductionOn x (fun p => ?_)
  simpa [factorHom] using F.onSymm p

/-- The canonical factorization as a groupoid functor from `FreeGroupoid A`. -/
noncomputable def factorFunctor (F : StepGraphMorphism A G) :
    CPFunctor (FreeGroupoid A) G where
  obj := F.obj
  map := fun {a b} x => factorHom F x
  map_id := by
    intro a
    simpa [FreeGroupoid] using factorHom_refl (F := F) a
  map_comp := by
    intro a b c x y
    simpa [FreeGroupoid] using factorHom_trans (F := F) x y
  map_inv := by
    intro a b x
    simpa [FreeGroupoid] using factorHom_symm (F := F) x

/-- Universal-property specification for a factor through the free groupoid. -/
def FactorsThrough (F : StepGraphMorphism A G) (φ : LiftHom F) : Prop :=
  (∀ a, φ (PathRwQuot.refl (A := A) a) = G.id (F.obj a)) ∧
  (∀ {a b c : A} (x : PathRwQuot A a b) (y : PathRwQuot A b c),
      φ (PathRwQuot.trans (A := A) x y) = G.comp (φ x) (φ y)) ∧
  (∀ {a b : A} (x : PathRwQuot A a b),
      φ (PathRwQuot.symm (A := A) x) = G.inv (φ x)) ∧
  (∀ {a b : A} (p : Path a b), φ (Quot.mk _ p) = F.onPath p)

/-- Uniqueness of factorization map from values on raw paths. -/
theorem factorHom_unique (F : StepGraphMorphism A G) (φ : LiftHom F)
    (hφ : ∀ {a b : A} (p : Path a b), φ (Quot.mk _ p) = F.onPath p) :
    φ = factorHom F := by
  funext a
  funext b
  funext x
  refine Quot.inductionOn x (fun p => ?_)
  simpa [factorHom] using hφ (a := a) (b := b) p

/-- Universal property of `PathRwQuot` as free groupoid on the Step graph:
every Step-graph morphism factors uniquely. -/
theorem universal_property (F : StepGraphMorphism A G) :
    ∃! φ : LiftHom F, FactorsThrough F φ := by
  refine ⟨factorHom F, ?_, ?_⟩
  · refine ⟨?_, ?_, ?_, ?_⟩
    · intro a
      simpa using factorHom_refl (F := F) a
    · intro a b c x y
      simpa using factorHom_trans (F := F) x y
    · intro a b x
      simpa using factorHom_symm (F := F) x
    · intro a b p
      simpa using factorHom_mk (F := F) (a := a) (b := b) p
  · intro φ hφ
    rcases hφ with ⟨_, _, _, hPath⟩
    exact factorHom_unique (F := F) (φ := φ) hPath

end StepGraphMorphism

/-- Morphism between path graphs, preserving path constructors and Step rewrites. -/
structure PathGraphMorphism (A : Type u) (B : Type v) where
  obj : A → B
  mapPath : {a b : A} → Path a b → Path (obj a) (obj b)
  map_refl : ∀ a, mapPath (Path.refl a) = Path.refl (obj a)
  map_trans : ∀ {a b c : A} (p : Path a b) (q : Path b c),
      mapPath (Path.trans p q) = Path.trans (mapPath p) (mapPath q)
  map_symm : ∀ {a b : A} (p : Path a b),
      mapPath (Path.symm p) = Path.symm (mapPath p)
  map_step : ∀ {a b : A} {p q : Path a b},
      Step p q → RwEq (mapPath p) (mapPath q)

namespace PathGraphMorphism

variable {A : Type u} {B : Type v}

/-- Preservation of primitive Step rewrites extends to all `RwEq` witnesses. -/
def map_rweq (F : PathGraphMorphism A B)
    {a b : A} {p q : Path a b} (h : RwEq p q) :
    RwEq (F.mapPath p) (F.mapPath q) := by
  induction h with
  | refl p =>
      exact RwEq.refl _
  | step hStep =>
      exact F.map_step hStep
  | symm h ih =>
      exact RwEq.symm ih
  | trans h₁ h₂ ih₁ ih₂ =>
      exact RwEq.trans ih₁ ih₂

/-- Action on free-groupoid morphisms induced by a path-graph morphism. -/
noncomputable def mapQuot (F : PathGraphMorphism A B) {a b : A} :
    PathRwQuot A a b → PathRwQuot B (F.obj a) (F.obj b) :=
  Quot.lift
    (fun p => Quot.mk _ (F.mapPath p))
    (fun p q h =>
      Quot.sound (rweqProp_of_rweq (F.map_rweq (rweq_of_rweqProp h))))

@[simp] theorem mapQuot_mk (F : PathGraphMorphism A B)
    {a b : A} (p : Path a b) :
    mapQuot F (Quot.mk _ p) = Quot.mk _ (F.mapPath p) := rfl

@[simp] theorem mapQuot_refl (F : PathGraphMorphism A B) (a : A) :
    mapQuot F (PathRwQuot.refl (A := A) a) =
      PathRwQuot.refl (A := B) (F.obj a) := by
  change Quot.mk _ (F.mapPath (Path.refl a)) = Quot.mk _ (Path.refl (F.obj a))
  exact Quot.sound (rweqProp_of_rweq (rweq_of_eq (F.map_refl a)))

@[simp] theorem mapQuot_trans (F : PathGraphMorphism A B)
    {a b c : A} (x : PathRwQuot A a b) (y : PathRwQuot A b c) :
    mapQuot F (PathRwQuot.trans (A := A) x y) =
      PathRwQuot.trans (A := B) (mapQuot F x) (mapQuot F y) := by
  refine Quot.inductionOn x (fun p => ?_)
  refine Quot.inductionOn y (fun q => ?_)
  change Quot.mk _ (F.mapPath (Path.trans p q)) =
    Quot.mk _ (Path.trans (F.mapPath p) (F.mapPath q))
  exact Quot.sound (rweqProp_of_rweq (rweq_of_eq (F.map_trans p q)))

@[simp] theorem mapQuot_symm (F : PathGraphMorphism A B)
    {a b : A} (x : PathRwQuot A a b) :
    mapQuot F (PathRwQuot.symm (A := A) x) =
      PathRwQuot.symm (A := B) (mapQuot F x) := by
  refine Quot.inductionOn x (fun p => ?_)
  change Quot.mk _ (F.mapPath (Path.symm p)) =
    Quot.mk _ (Path.symm (F.mapPath p))
  exact Quot.sound (rweqProp_of_rweq (rweq_of_eq (F.map_symm p)))

/-- Functoriality: a path-graph morphism induces a free-groupoid functor. -/
noncomputable def inducedFunctor (F : PathGraphMorphism A B) :
    CPFunctor (FreeGroupoid A) (FreeGroupoid B) where
  obj := F.obj
  map := fun {a b} x => mapQuot F x
  map_id := by
    intro a
    simpa [FreeGroupoid] using mapQuot_refl (F := F) a
  map_comp := by
    intro a b c x y
    simpa [FreeGroupoid] using mapQuot_trans (F := F) x y
  map_inv := by
    intro a b x
    simpa [FreeGroupoid] using mapQuot_symm (F := F) x

/-- The canonical path-graph morphism induced by a function on vertices
    (both types in the same universe). -/
def ofFunction {A B : Type u} (f : A → B) : PathGraphMorphism A B where
  obj := f
  mapPath := fun {a b} p => Path.congrArg f p
  map_refl := by
    intro a
    rfl
  map_trans := by
    intro a b c p q
    simpa using (Path.congrArg_trans (f := f) (p := p) (q := q))
  map_symm := by
    intro a b p
    simpa using (Path.congrArg_symm (f := f) (p := p))
  map_step := by
    intro a b p q hStep
    exact rweq_congrArg_of_rweq f (RwEq.step hStep)

end PathGraphMorphism

end Algebra
end CompPaths
