/- 
# Path algebra on computational loops

Formal linear combinations of based loops with multiplication induced by
`Path.trans`, together with the two-sided ideal generated by `RwEq`.
The resulting quotient is interpreted as the group algebra on `π₁(A, a)`.
-/

import CompPaths.Core
import ComputationalPaths.Path.Homotopy.FundamentalGroup

namespace CompPaths.Algebra

open ComputationalPaths
open ComputationalPaths.Path

universe u

abbrev Loop (A : Type u) (a : A) : Type u :=
  Path (A := A) a a

abbrev PathMonomial (A : Type u) (a : A) : Type u :=
  Int × Loop A a

abbrev PathAlgebra (A : Type u) (a : A) : Type u :=
  List (PathMonomial A a)

@[simp] def pathAdd {A : Type u} {a : A} :
    PathAlgebra A a → PathAlgebra A a → PathAlgebra A a :=
  List.append

@[simp] def pathMulMonomial {A : Type u} {a : A}
    (m₁ m₂ : PathMonomial A a) : PathMonomial A a :=
  (m₁.1 * m₂.1, Path.trans m₁.2 m₂.2)

@[simp] def pathMul {A : Type u} {a : A}
    (x y : PathAlgebra A a) : PathAlgebra A a :=
  x.bind (fun m₁ => y.map (fun m₂ => pathMulMonomial m₁ m₂))

@[simp] def pathOne {A : Type u} (a : A) : PathAlgebra A a :=
  [(1, Path.refl a)]

/-! ## RwEq compatibility with multiplication by `Path.trans` -/

theorem rweq_trans_compat {A : Type u} {a : A}
    {p p' q q' : Loop A a}
    (hp : RwEq p p') (hq : RwEq q q') :
    RwEq (Path.trans p q) (Path.trans p' q') :=
  rweq_trans_congr hp hq

/-! ## Two-sided ideal generated by `RwEq` -/

inductive RwEqIdeal (A : Type u) (a : A) :
    PathAlgebra A a → PathAlgebra A a → Prop
  | base (n : Int) {p q : Loop A a} (h : RwEq p q) :
      RwEqIdeal A a [(n, p)] [(n, q)]
  | refl (x : PathAlgebra A a) : RwEqIdeal A a x x
  | symm {x y : PathAlgebra A a} :
      RwEqIdeal A a x y → RwEqIdeal A a y x
  | trans {x y z : PathAlgebra A a} :
      RwEqIdeal A a x y → RwEqIdeal A a y z → RwEqIdeal A a x z
  | add_left {x y z : PathAlgebra A a} :
      RwEqIdeal A a x y →
        RwEqIdeal A a (pathAdd x z) (pathAdd y z)
  | add_right {x y z : PathAlgebra A a} :
      RwEqIdeal A a x y →
        RwEqIdeal A a (pathAdd z x) (pathAdd z y)
  | mul_left {x y z : PathAlgebra A a} :
      RwEqIdeal A a x y →
        RwEqIdeal A a (pathMul z x) (pathMul z y)
  | mul_right {x y z : PathAlgebra A a} :
      RwEqIdeal A a x y →
        RwEqIdeal A a (pathMul x z) (pathMul y z)

theorem rwEqIdeal_contains_step {A : Type u} {a : A}
    (n : Int) {p q : Loop A a} (h : Step p q) :
    RwEqIdeal A a [(n, p)] [(n, q)] :=
  RwEqIdeal.base (A := A) (a := a) n (RwEq.step h)

theorem singleton_mul_respects_rweq {A : Type u} {a : A}
    {n m : Int} {p p' q q' : Loop A a}
    (hp : RwEq p p') (hq : RwEq q q') :
    RwEqIdeal A a
      (pathMul [(n, p)] [(m, q)])
      (pathMul [(n, p')] [(m, q')]) := by
  have htrans : RwEq (Path.trans p q) (Path.trans p' q') :=
    rweq_trans_compat (A := A) (a := a) hp hq
  simpa [pathMul, pathMulMonomial] using
    (RwEqIdeal.base (A := A) (a := a) (n := n * m) htrans)

theorem pathMul_wellDefined {A : Type u} {a : A}
    {x x' y y' : PathAlgebra A a}
    (hx : RwEqIdeal A a x x') (hy : RwEqIdeal A a y y') :
    RwEqIdeal A a (pathMul x y) (pathMul x' y') :=
  RwEqIdeal.trans
    (RwEqIdeal.mul_right (A := A) (a := a) (z := y) hx)
    (RwEqIdeal.mul_left (A := A) (a := a) (z := x') hy)

def rweqIdealSetoid (A : Type u) (a : A) :
    Setoid (PathAlgebra A a) where
  r := RwEqIdeal A a
  iseqv := ⟨RwEqIdeal.refl, RwEqIdeal.symm, RwEqIdeal.trans⟩

abbrev QuotientPathAlgebra (A : Type u) (a : A) : Type u :=
  Quot (rweqIdealSetoid A a).r

/-! ## Group algebra of `π₁(A, a)` -/

abbrev PiOneMonomial (A : Type u) (a : A) : Type u :=
  Int × π₁(A, a)

abbrev PiOneGroupAlgebra (A : Type u) (a : A) : Type u :=
  List (PiOneMonomial A a)

@[simp] def piOneMulMonomial {A : Type u} {a : A}
    (m₁ m₂ : PiOneMonomial A a) : PiOneMonomial A a :=
  (m₁.1 * m₂.1, PiOne.mul m₁.2 m₂.2)

@[simp] def piOneMul {A : Type u} {a : A}
    (x y : PiOneGroupAlgebra A a) : PiOneGroupAlgebra A a :=
  x.bind (fun m₁ => y.map (fun m₂ => piOneMulMonomial m₁ m₂))

@[simp] def toPiOneMonomial {A : Type u} {a : A}
    (m : PathMonomial A a) : PiOneMonomial A a :=
  (m.1, PiOne.ofLoop m.2)

@[simp] def toPiOneGroupAlgebra {A : Type u} {a : A}
    (x : PathAlgebra A a) : PiOneGroupAlgebra A a :=
  x.map toPiOneMonomial

@[simp] theorem toPiOneMonomial_mul {A : Type u} {a : A}
    (m₁ m₂ : PathMonomial A a) :
    toPiOneMonomial (pathMulMonomial m₁ m₂) =
      piOneMulMonomial (toPiOneMonomial m₁) (toPiOneMonomial m₂) := by
  cases m₁ with
  | mk n p =>
      cases m₂ with
      | mk m q =>
          simp [pathMulMonomial, toPiOneMonomial, piOneMulMonomial]

@[simp] theorem toPiOneGroupAlgebra_mul {A : Type u} {a : A}
    (x y : PathAlgebra A a) :
    toPiOneGroupAlgebra (pathMul x y) =
      piOneMul (toPiOneGroupAlgebra x) (toPiOneGroupAlgebra y) := by
  induction x with
  | nil =>
      simp [pathMul, piOneMul, toPiOneGroupAlgebra]
  | cons m xs ih =>
      simp [pathMul, piOneMul, toPiOneGroupAlgebra]

theorem toPiOneGroupAlgebra_base {A : Type u} {a : A}
    (n : Int) {p q : Loop A a} (h : RwEq p q) :
    toPiOneGroupAlgebra (A := A) (a := a) [(n, p)] =
      toPiOneGroupAlgebra (A := A) (a := a) [(n, q)] := by
  have hloop : PiOne.ofLoop (A := A) (a := a) p =
      PiOne.ofLoop (A := A) (a := a) q :=
    Quot.sound (rweqProp_of_rweq h)
  simpa [toPiOneGroupAlgebra, toPiOneMonomial] using
    congrArg (fun g => [(n, g)]) hloop

theorem toPiOneGroupAlgebra_respects_rweqIdeal {A : Type u} {a : A}
    {x y : PathAlgebra A a} (h : RwEqIdeal A a x y) :
    toPiOneGroupAlgebra x = toPiOneGroupAlgebra y := by
  induction h with
  | base n h =>
      exact toPiOneGroupAlgebra_base (A := A) (a := a) n h
  | refl _ =>
      rfl
  | symm _ ih =>
      exact ih.symm
  | trans _ _ ih₁ ih₂ =>
      exact ih₁.trans ih₂
  | add_left (z := z) _ ih =>
      simpa [pathAdd, toPiOneGroupAlgebra] using
        congrArg (fun t => t ++ toPiOneGroupAlgebra z) ih
  | add_right (z := z) _ ih =>
      simpa [pathAdd, toPiOneGroupAlgebra] using
        congrArg (fun t => toPiOneGroupAlgebra z ++ t) ih
  | mul_left _ ih =>
      simp [toPiOneGroupAlgebra_mul, ih]
  | mul_right _ ih =>
      simp [toPiOneGroupAlgebra_mul, ih]

noncomputable def quotientToPiOneGroupAlgebra {A : Type u} {a : A} :
    QuotientPathAlgebra A a → PiOneGroupAlgebra A a :=
  Quot.lift (toPiOneGroupAlgebra (A := A) (a := a))
    (fun _ _ h =>
      toPiOneGroupAlgebra_respects_rweqIdeal (A := A) (a := a) h)

@[simp] theorem quotientToPiOneGroupAlgebra_mk {A : Type u} {a : A}
    (x : PathAlgebra A a) :
    quotientToPiOneGroupAlgebra (A := A) (a := a) (Quot.mk _ x) =
      toPiOneGroupAlgebra x :=
  rfl

abbrev FundamentalGroupAlgebra (A : Type u) (a : A) : Type u :=
  PiOneGroupAlgebra A a

noncomputable def quotientAlgebraAsGroupAlgebra {A : Type u} {a : A} :
    QuotientPathAlgebra A a → FundamentalGroupAlgebra A a :=
  quotientToPiOneGroupAlgebra

end CompPaths.Algebra
