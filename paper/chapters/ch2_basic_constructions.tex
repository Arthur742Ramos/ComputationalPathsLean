% ============================================================================
% Chapter 2: Computational Paths â€” Basic Constructions
% ============================================================================
\chapter{Computational Paths: Basic Constructions}
\label{ch:basic-constructions}

Throughout this chapter, $A$, $B$, $C$ denote types in a fixed universe,
and $a, b, c, d$ denote elements of~$A$ unless otherwise stated.

\section{Fundamental Operations}
\label{sec:fundamental-ops}

We equip the space $\Path_A(a,b)$ with three primitive operations.

\begin{definition}[Reflexivity]\label{def:refl}
  The \emph{reflexive path} at $a : A$ is
  \[
    \refl(a) \;=\; ([\,],\; \refl_a) \;:\; \Path_A(a,a),
  \]
  where the step list is empty and the proof field is the reflexivity
  of~$\Eq$.
\end{definition}

\begin{definition}[Symmetry]\label{def:symm}
  For $p = (s, \pi) : \Path_A(a,b)$, the \emph{symmetric path} is
  \[
    \inv{p} \;=\; \symop(p) \;=\; \bigl(\mathrm{reverse}(\mathrm{map}(\mathrm{symm}_{\Step}, s)),\;
    \pi^{-1}\bigr) \;:\; \Path_A(b,a),
  \]
  where $\mathrm{symm}_{\Step}$ inverts each elementary step and
  $\mathrm{reverse}$ reverses the list.
\end{definition}

\begin{definition}[Transitivity / Composition]\label{def:trans}
  For $p = (s_1, \pi_1) : \Path_A(a,b)$ and $q = (s_2, \pi_2) : \Path_A(b,c)$,
  the \emph{composite path} is
  \[
    p \comp q \;=\; \mathrm{trans}(p, q) \;=\;
    (s_1 \mathbin{+\!\!+} s_2,\; \pi_1 \cdot \pi_2) \;:\; \Path_A(a,c),
  \]
  where $\mathbin{+\!\!+}$ denotes list concatenation and $\cdot$ is
  transitivity of~$\Eq$.
\end{definition}

\begin{remark}
  We use $p \comp q$ and $\mathrm{trans}(p, q)$ interchangeably,
  adopting the diagrammatic order: $p$ is followed by~$q$.
\end{remark}

\section{Strict Algebraic Laws}
\label{sec:strict-laws}

A remarkable feature of computational paths is that many algebraic identities
hold as \emph{strict} equalities---i.e., as definitional equalities of the
$\Path$ record structure---not merely up to rewriting. This is a consequence of
the list-based representation: the laws reduce to standard identities on list
concatenation and reversal.

\begin{theorem}[Strict Monoid Laws]\label{thm:strict-monoid}
  For all $p : \Path_A(a,b)$, $q : \Path_A(b,c)$, $r : \Path_A(c,d)$:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left identity.}\; $\refl(a) \comp p = p$.
    \item \textbf{Right identity.}\; $p \comp \refl(b) = p$.
    \item \textbf{Associativity.}\; $(p \comp q) \comp r = p \comp (q \comp r)$.
  \end{enumerate}
  All three equalities hold as structural equalities of $\Path$ records
  (not merely up to rewriting).
\end{theorem}

\begin{proof}
  \begin{enumerate}[label=(\roman*)]
    \item By definition, $\refl(a) \comp p = ([\,] \mathbin{+\!\!+} s,\;
      \refl \cdot \pi) = (s, \pi) = p$, since prepending the empty list
      is the identity on lists, and $\refl \cdot \pi = \pi$.
    \item Similarly, $p \comp \refl(b) = (s \mathbin{+\!\!+} [\,],\;
      \pi \cdot \refl) = (s, \pi) = p$.
    \item Follows from $\mathrm{List.append\_assoc}$: $(s_1 \mathbin{+\!\!+} s_2)
      \mathbin{+\!\!+} s_3 = s_1 \mathbin{+\!\!+} (s_2 \mathbin{+\!\!+} s_3)$
      and associativity of $\Eq.\mathrm{trans}$. \qedhere
  \end{enumerate}
\end{proof}

\begin{theorem}[Strict Involution]\label{thm:strict-involution}
  For all $p : \Path_A(a,b)$:
  \[
    \inv{(\inv{p})} = p.
  \]
\end{theorem}

\begin{proof}
  We compute $\inv{(\inv{p})}$: reversing the reversed list recovers the
  original list, and applying $\mathrm{symm}_{\Step}$ twice to each step
  is the identity (since swapping source and target twice returns to the
  original step). On the proof field, $(\pi^{-1})^{-1} = \pi$.
\end{proof}

\begin{theorem}[Strict Anti-Homomorphism]\label{thm:strict-antihom}
  For all $p : \Path_A(a,b)$ and $q : \Path_A(b,c)$:
  \[
    \inv{(p \comp q)} \;=\; \inv{q} \comp \inv{p}.
  \]
\end{theorem}

\begin{proof}
  By the list identity $\mathrm{reverse}(s_1 \mathbin{+\!\!+} s_2) =
  \mathrm{reverse}(s_2) \mathbin{+\!\!+} \mathrm{reverse}(s_1)$ and
  the fact that mapping commutes with reversal and append.
\end{proof}

\begin{remark}[Cancellation is not strict]\label{rem:cancel-not-strict}
  The cancellation law $p \comp \inv{p} = \refl(a)$ does \emph{not} hold
  strictly: the left-hand side has step list $s \mathbin{+\!\!+}
  \mathrm{reverse}(\mathrm{map}(\mathrm{symm}_{\Step}, s))$, which is
  non-empty whenever $s \neq [\,]$, while $\refl(a)$ has an empty step
  list. Cancellation holds only up to the rewrite relation~$\Step$
  (\cref{ch:rewrite-system}).
\end{remark}

\section{Congruence (Functorial Action)}
\label{sec:congruence}

\begin{definition}[Unary Congruence]\label{def:congrArg}
  For $f : A \to B$ and $p = (s, \pi) : \Path_A(a,b)$, the \emph{congruence}
  (or \emph{functorial action}) of~$f$ on~$p$ is
  \[
    f_*(p) \;=\; \congrArgOp(f, p) \;=\;
    \bigl(\mathrm{map}(\mathrm{map}_f, s),\; \congrArgOp(f, \pi)\bigr)
    \;:\; \Path_B(f(a), f(b)),
  \]
  where $\mathrm{map}_f$ sends a step $\langle x, y, h \rangle$ to $\langle
  f(x), f(y), \congrArgOp(f, h) \rangle$.
\end{definition}

The functorial action satisfies strict algebraic laws:

\begin{theorem}[Functoriality of Congruence]\label{thm:congrArg-functor}
  For $f : A \to B$, $g : B \to C$, and paths $p : \Path_A(a,b)$,
  $q : \Path_A(b,c)$:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Composition.}\; $f_*(p \comp q) = f_*(p) \comp f_*(q)$.
    \item \textbf{Symmetry.}\; $f_*(\inv{p}) = \inv{f_*(p)}$.
    \item \textbf{Identity.}\; $\id_*(p) = p$ \;(where $\id = \lambda x.\, x$).
    \item \textbf{Composition of functions.}\;
      $(g \circ f)_*(p) = g_*(f_*(p))$.
  \end{enumerate}
  All equalities are strict.
\end{theorem}

\begin{proof}
  Each part reduces to a standard identity on list operations:
  \begin{enumerate}[label=(\roman*)]
    \item $\mathrm{map}(F, s_1 \mathbin{+\!\!+} s_2) = \mathrm{map}(F, s_1)
      \mathbin{+\!\!+} \mathrm{map}(F, s_2)$.
    \item $\mathrm{map}(F, \mathrm{reverse}(\mathrm{map}(G, s))) =
      \mathrm{reverse}(\mathrm{map}(F \circ G, s))$, combined with the fact
      that $\mathrm{map}_f \circ \mathrm{symm}_{\Step} = \mathrm{symm}_{\Step}
      \circ \mathrm{map}_f$.
    \item $\mathrm{map}_{\id} = \id$ on steps.
    \item $\mathrm{map}_{g \circ f} = \mathrm{map}_g \circ \mathrm{map}_f$
      on steps. \qedhere
  \end{enumerate}
\end{proof}

\begin{corollary}\label{cor:path-functor}
  The assignment $A \mapsto \Path_A$ and $f \mapsto f_*$ is a functor from
  the category of types and functions to the category of types and
  path-preserving maps (strictly preserving composition and identities).
\end{corollary}

\section{Binary Congruence}
\label{sec:binary-congruence}

For binary functions, congruence decomposes into left and right components.

\begin{definition}[Left, Right, and Binary Maps]\label{def:binary-maps}
  Let $f : A \to B \to C$.
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left map.}\; $\mapLeft(f, p, b) = (\lambda x.\, f(x,b))_*(p)
      : \Path_C(f(a_1, b), f(a_2, b))$ \\ for $p : \Path_A(a_1, a_2)$
      and $b : B$.
    \item \textbf{Right map.}\; $\mapRight(f, a, q) = f(a)_*(q)
      : \Path_C(f(a, b_1), f(a, b_2))$ \\ for $a : A$ and $q : \Path_B(b_1, b_2)$.
    \item \textbf{Binary map.}\; $\mapTwo(f, p, q) = \mapLeft(f, p, b_1)
      \comp \mapRight(f, a_2, q)$ \\ for $p : \Path_A(a_1, a_2)$ and
      $q : \Path_B(b_1, b_2)$.
  \end{enumerate}
\end{definition}

The binary map first varies the left argument (holding the right argument
at its \emph{source} $b_1$), then varies the right argument (holding the left
argument at its \emph{target} $a_2$). This is the canonical choice that makes
the binary map compose correctly with projections.

The binary map satisfies its own functoriality laws, inherited from those of
the unary congruence. In particular, $\mapTwo(f, -, -)$ preserves composition
in each variable separately:
\[
  \mapTwo(f, p_1 \comp p_2, q_1 \comp q_2) =
  \mapLeft(f, p_1, b_1) \comp \mapLeft(f, p_2, b_1) \comp
  \mapRight(f, a_3, q_1) \comp \mapRight(f, a_3, q_2).
\]
Symmetry of $\mapTwo$ reverses the order of the components:
\[
  \inv{\mapTwo(f, p, q)} = \mapRight(f, a_2, \inv{q}) \comp
  \mapLeft(f, \inv{p}, b_1).
\]

\section{Product Paths}
\label{sec:product-paths}

\begin{definition}[Product Path Operations]\label{def:prod-paths}
  For $p : \Path_A(a_1, a_2)$ and $q : \Path_B(b_1, b_2)$:
  \begin{enumerate}[label=(\roman*)]
    \item $\prodMk(p, q) = \mapTwo(\mathrm{Prod.mk}, p, q)
      : \Path_{A \times B}((a_1, b_1), (a_2, b_2))$.
    \item $\fst(r) = (\mathrm{Prod.fst})_*(r)$ for
      $r : \Path_{A \times B}((a_1, b_1), (a_2, b_2))$.
    \item $\snd(r) = (\mathrm{Prod.snd})_*(r)$ for
      $r : \Path_{A \times B}((a_1, b_1), (a_2, b_2))$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Product $\beta$/$\eta$-Rules]\label{thm:prod-beta-eta}
  The product path operations satisfy:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{$\beta$-rules.}\;
      $\fst(\prodMk(p, q)) = p$ \;(strictly, by functoriality);\;
      $\snd(\prodMk(p, q))$ reduces to~$q$ via a single rewrite step.
    \item \textbf{$\eta$-rule.}\; $\prodMk(\fst(r), \snd(r)) \rew r$
      \;(as a rewrite step, see \cref{ch:rewrite-system}).
  \end{enumerate}
\end{theorem}

The $\eta$-rule is not a strict equality because $\prodMk(\fst(r), \snd(r))$
applies the binary map construction, producing a different step list than the
original path~$r$.

\section{Sigma Paths}
\label{sec:sigma-paths}

For a dependent type $B : A \to \Type$, paths between dependent pairs
$\langle a_1, b_1 \rangle$ and $\langle a_2, b_2 \rangle$ in $\Sigma_{x:A} B(x)$
decompose into a base path and a fiber path.

\begin{definition}[Sigma Path Operations]\label{def:sigma-paths}
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Construction.}\; $\sigmaMk(p, q) : \Path_{\Sigma B}(\langle a_1,
      b_1\rangle, \langle a_2, b_2\rangle)$ where $p : \Path_A(a_1, a_2)$
      and $q : \Path_{B(a_2)}(\tr(p, b_1), b_2)$.
    \item \textbf{First projection.}\; $\sigmaFst(r) = (\Sigma.\mathrm{fst})_*(r) :
      \Path_A(a_1, a_2)$.
    \item \textbf{Second projection.}\; $\sigmaSnd(r) : \Path_{B(a_2)}(\tr(\sigmaFst(r),
      b_1), b_2)$.
  \end{enumerate}
\end{definition}

The sigma path operations satisfy analogous $\beta/\eta$-rules to the product
case. These hold as rewrite steps (not strict equalities), since the
$\sigmaMk$ constructor creates a single-step path via $\ofEq$:
\begin{align*}
  \sigmaFst(\sigmaMk(p, q)) &\rew \ofEq(\toEq(p)), \\
  \sigmaSnd(\sigmaMk(p, q)) &\rew \ofEq(\toEq(q)), \\
  \sigmaMk(\sigmaFst(r), \sigmaSnd(r)) &\rew r.
\end{align*}

\section{Sum Paths}
\label{sec:sum-paths}

\begin{definition}[Sum Path Constructors]\label{def:sum-paths}
  For $p : \Path_A(a_1, a_2)$ and $q : \Path_B(b_1, b_2)$:
  \begin{enumerate}[label=(\roman*)]
    \item $\inlOp_*(p) = (\mathrm{Sum.inl})_*(p) :
      \Path_{A + B}(\mathrm{inl}(a_1), \mathrm{inl}(a_2))$.
    \item $\inrOp_*(q) = (\mathrm{Sum.inr})_*(q) :
      \Path_{A + B}(\mathrm{inr}(b_1), \mathrm{inr}(b_2))$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Sum $\beta$-Rules]\label{thm:sum-beta}
  For $f : A \to C$, $g : B \to C$, and the eliminator
  $\mathrm{rec}(f, g) : A + B \to C$:
  \begin{align*}
    (\mathrm{rec}(f,g))_*(\inlOp_*(p)) &\rew f_*(p), \\
    (\mathrm{rec}(f,g))_*(\inrOp_*(q)) &\rew g_*(q).
  \end{align*}
\end{theorem}

\section{Function Paths}
\label{sec:function-paths}

\begin{definition}[Function Path Operations]\label{def:fun-paths}
  Let $f, g : A \to B$.
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Lambda congruence.}\;
      $\lamCongr(p) : \Path_{A \to B}(f, g)$ where $p : \prod_{x:A}
      \Path_B(f(x), g(x))$ is a family of pointwise paths. The step list
      is empty and the proof field is $\mathrm{funext}(\lambda x.\,
      \toEq(p(x)))$.
    \item \textbf{Application.}\;
      $\app(r, a) = (\lambda h.\, h(a))_*(r) : \Path_B(f(a), g(a))$
      for $r : \Path_{A \to B}(f, g)$ and $a : A$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Function $\beta$/$\eta$-Rules]\label{thm:fun-beta-eta}
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{$\beta$.}\;
      $\app(\lamCongr(p), a) \rew p(a)$.
    \item \textbf{$\eta$.}\;
      $\lamCongr(\lambda x.\, \app(q, x)) \rew q$.
  \end{enumerate}
\end{theorem}

Additional strict identities hold for $\lamCongr$: it preserves composition
and symmetry strictly:
\begin{align*}
  \lamCongr(p) \comp \lamCongr(q) &= \lamCongr(\lambda x.\, p(x) \comp q(x)),\\
  \inv{\lamCongr(p)} &= \lamCongr(\lambda x.\, \inv{p(x)}).
\end{align*}

\section{Transport and Dependent Application}
\label{sec:transport}

\begin{definition}[Transport]\label{def:transport}
  For a type family $D : A \to \Sort$, a path $p : \Path_A(a,b)$, and
  an element $x : D(a)$, the \emph{transport} of $x$ along $p$ is
  \[
    \tr_D(p, x) \;=\; \Eq.\mathrm{rec}(\pi, x) \;:\; D(b),
  \]
  where $\pi = \toEq(p) : a =_A b$. Transport uses only the semantic
  content of~$p$, not its trace.
\end{definition}

\begin{theorem}[Transport Laws]\label{thm:transport-laws}
  The following hold strictly:
  \begin{enumerate}[label=(\roman*)]
    \item $\tr_D(\refl(a), x) = x$.
    \item $\tr_D(p \comp q, x) = \tr_D(q, \tr_D(p, x))$.
    \item $\tr_D(\inv{p}, \tr_D(p, x)) = x$.
    \item $\tr_D(p, \tr_D(\inv{p}, y)) = y$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  All follow from case analysis on the path's proof field.
  Since $\Eq.\mathrm{rec}$ is definitionally the identity when the
  proof is $\refl$, (i) is immediate. Parts (ii)--(iv) follow from
  the corresponding properties of $\Eq.\mathrm{rec}$.
\end{proof}

\begin{definition}[Dependent Application]\label{def:apd}
  For a dependent function $f : \prod_{x:A} D(x)$ and a path
  $p : \Path_A(a,b)$, the \emph{dependent application} is
  \[
    \apd(f, p) \;:\; \Path_{D(b)}(\tr_D(p, f(a)),\; f(b)).
  \]
  When $p = \refl(a)$, this reduces to $\refl(f(a))$.
\end{definition}

\section{Contexts}
\label{sec:contexts}

Contexts formalize substitution of paths into sub-expressions. They are the
categorical analogue of ``evaluation in context'' from term rewriting.

\begin{definition}[Unary Context]\label{def:context}
  A \emph{context} $C : \Context(A, B)$ is a function $\mathrm{fill} : A \to B$.
  It acts on paths by
  \[
    C[p] \;=\; \congrArgOp(\mathrm{fill}, p) \;:\;
    \Path_B(C[a_1], C[a_2])
  \]
  for $p : \Path_A(a_1, a_2)$, where we write $C[a]$ for
  $\mathrm{fill}(a)$.
\end{definition}

\begin{definition}[Context Substitution]\label{def:context-subst}
  Let $C : \Context(A, B)$.
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left substitution.}\;
      $\substL(C, r, p) = r \comp C[p] : \Path_B(x, C[a_2])$ \\
      for $r : \Path_B(x, C[a_1])$ and $p : \Path_A(a_1, a_2)$.
    \item \textbf{Right substitution.}\;
      $\substR(C, p, t) = C[p] \comp t : \Path_B(C[a_1], y)$ \\
      for $p : \Path_A(a_1, a_2)$ and $t : \Path_B(C[a_2], y)$.
  \end{enumerate}
\end{definition}

Context substitution supports an extensive algebra of identities
(cf.\ \cref{sec:context-rules} in \cref{ch:rewrite-system}), including:
\begin{itemize}
  \item Unit laws: $\substL(C, \refl, p) \rew C[p]$ and
    $\substR(C, p, \refl) \rew C[p]$.
  \item Associativity: $\substR(C, p, t) \comp u \rew \substR(C, p, t \comp u)$.
  \item Idempotence: $\substL(C, \substL(C, r, \refl), p) \rew
    \substL(C, r, p)$.
  \item $\beta$-rules: $r \comp C[p] \rew \substL(C, r, p)$ and
    $C[p] \comp t \rew \substR(C, p, t)$.
\end{itemize}

\begin{definition}[Binary Context]\label{def:bicontext}
  A \emph{binary context} $K : \BiContext(A, B, C)$ is a function
  $\mathrm{fill} : A \to B \to C$. It supports $\mapLeft$, $\mapRight$,
  and $\mapTwo$ operations obtained by freezing one argument:
  \begin{align*}
    K.\mapLeft(p, b) &= (\lambda x.\, K[x, b])_*(p), \\
    K.\mapRight(a, q) &= K[a, -]_*(q), \\
    K.\mapTwo(p, q) &= K.\mapLeft(p, b_1) \comp K.\mapRight(a_2, q).
  \end{align*}
\end{definition}

\begin{definition}[Dependent Context]\label{def:depcontext}
  A \emph{dependent context} $C : \DepContext(A, B)$ consists of
  $\mathrm{fill} : \prod_{a:A} B(a)$ for a type family $B : A \to \Type$.
  Its action on a path $p : \Path_A(a_1, a_2)$ produces
  \[
    C.\mathrm{map}(p) \;:\; \Path_{B(a_2)}(\tr_B(p, C[a_1]),\; C[a_2]),
  \]
  which is the dependent application $\apd(\mathrm{fill}, p)$.
\end{definition}

Dependent contexts admit analogues of left and right substitution
($\substL$ and $\substR$), with additional transport factors to account
for the dependence of the codomain on the base.

\begin{definition}[Dependent Binary Context]\label{def:depbicontext}
  A \emph{dependent binary context} $K : \DepContext(A, B, C)$, where
  $C : A \to B \to \Type$, consists of $\mathrm{fill} : \prod_{a:A}
  \prod_{b:B} C(a, b)$. It supports $\mapLeft$, $\mapRight$, and
  $\mapTwo$ operations that combine transport in the base with fiber
  paths, generalizing the binary context operations.
\end{definition}
