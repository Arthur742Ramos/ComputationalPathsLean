% ============================================================================
% Chapter 1: Introduction and Motivation
% ============================================================================
\chapter{Introduction and Motivation}
\label{ch:introduction}

\section{The Curry--Howard--de~Bruijn Correspondence and Propositional Equality}
\label{sec:curry-howard}

In Martin-L\"of type theory, the \emph{identity type} $\IdA_A(a,b)$ captures
propositional equality between elements $a,b : A$. Its sole introduction rule
is reflexivity: the term $\refl(a) : \IdA_A(a,a)$ witnesses that every element
is equal to itself. The elimination rule---\emph{path induction}, also known as
the~$J$-rule---states that to prove a property of an arbitrary inhabitant of
$\IdA_A(a,b)$, it suffices to verify the property for $\refl(a)$.

In proof assistants based on the Calculus of Inductive Constructions, such as
Lean~4 and Coq, the identity type \texttt{Eq} lives in $\Prop$, a universe
governed by \emph{proof irrelevance}: all inhabitants of a proposition are
definitionally identified. As a consequence, the \emph{Uniqueness of Identity
Proofs} (UIP) principle holds:

\begin{equation}\label{eq:uip}
  \forall\, p, q : \IdA_A(a,b),\quad p =_{\IdA_A(a,b)} q.
\end{equation}

This axiom collapses the entire space of identity proofs to at most one element
per pair of endpoints. From the perspective of homotopy type theory~\cite{HoTTBook},
UIP asserts that every type is a \emph{set} (a $0$-truncated type), precluding
the rich higher-dimensional structure that identity types can carry in
intensional type theory.

\section{The Computational Paths Program}
\label{sec:comp-paths-program}

Following de~Queiroz, de~Oliveira, and Ramos~\cite{DQOR16, RDQO18}, we propose
that equality proofs carry \emph{computational content}: the sequence of
rewriting steps that produced them. Even when the underlying logic satisfies
UIP---so that the propositional equality $a =_A b$ is proof-irrelevant---the
rewrite \emph{traces} are distinct combinatorial objects that can be compared,
composed, and quotiented.

The key insight is a separation of concerns:
\begin{itemize}[leftmargin=2em]
  \item The \textbf{semantic content} of an equality proof is the proposition
    $a =_A b$, which by UIP carries no information beyond its truth value.
  \item The \textbf{computational trace} is a finite sequence of elementary
    rewrite steps recording \emph{how} the equality was derived---which
    congruence rules, symmetries, transitivities, and $\beta/\eta$-reductions
    were applied, and in what order.
\end{itemize}

This separation creates a rich algebraic structure \emph{atop} the
proof-irrelevant equality, without modifying the underlying type theory.

\section{Design Principle: Path = Proof + Trace}
\label{sec:design-principle}

We now state the central definitions that constitute the formal framework.

\begin{definition}[Elementary Rewrite Step]\label{def:step}
  An \emph{elementary rewrite step} in a type~$A$ is a triple
  \[
    s = (\mathrm{src}, \mathrm{tgt}, \pi) \quad\text{where}\quad
    \mathrm{src}, \mathrm{tgt} : A \quad\text{and}\quad
    \pi : \mathrm{src} =_A \mathrm{tgt}.
  \]
  We write $\Step(A)$ for the type of all elementary rewrite steps in~$A$.
\end{definition}

Each step records a single atomic equation between two elements together with
its justification. Steps can be inverted (swapping source and target) and
mapped through functions.

\begin{definition}[Computational Path]\label{def:path}
  A \emph{computational path} from $a$ to $b$ in a type~$A$ is a pair
  \[
    p = (s, \pi) \quad\text{where}\quad
    s : \List(\Step(A)) \quad\text{and}\quad
    \pi : a =_A b.
  \]
  We write $\Path_A(a,b)$ for the type of computational paths from~$a$ to~$b$.
\end{definition}

The list $s$ is the \emph{computational trace}---it records which elementary
steps were applied. The proof $\pi$ is the \emph{semantic witness}---it
certifies that the composite rewrite is valid. Two paths with the same
endpoints but different traces are \emph{distinct} as elements of $\Path_A(a,b)$,
even though their proof fields are identified by UIP.

\begin{definition}[Semantic Projection]\label{def:toEq}
  The \emph{semantic projection} $\toEq : \Path_A(a,b) \to (a =_A b)$ extracts
  the underlying propositional equality from a computational path, discarding
  the trace:
  \[
    \toEq(s, \pi) \;=\; \pi.
  \]
\end{definition}

\begin{definition}[Canonical Witness]\label{def:ofEq}
  For any propositional equality $\pi : a =_A b$, the \emph{canonical witness}
  is the single-step path
  \[
    \ofEq(\pi) \;=\; \bigl([\langle a, b, \pi\rangle],\; \pi\bigr) \;:\; \Path_A(a,b).
  \]
\end{definition}

The function $\ofEq$ embeds the standard identity type into the computational
path space. Its image consists precisely of the one-step paths.

\section{Non-UIP for Computational Paths}
\label{sec:non-uip}

The raison d'\^etre of the computational paths framework is that it recovers
higher-dimensional structure even in a proof-irrelevant setting:

\begin{theorem}[Non-UIP for Paths]\label{thm:non-uip}
  For any nonempty type~$A$, the space of computational paths does not satisfy
  the Uniqueness of Identity Proofs:
  \[
    \neg\,\bigl(\forall\, a, b : A,\;\forall\, p, q : \Path_A(a,b),\;
    p = q\bigr).
  \]
\end{theorem}

\begin{proof}
  Let $a : A$ be any element. Consider two paths from $a$ to itself:
  \begin{align*}
    p &\;=\; \refl(a) \;=\; ([\,],\; \refl) \;:\; \Path_A(a,a), \\
    q &\;=\; \ofEq(\refl) \;=\; \bigl([\langle a, a, \refl\rangle],\;
    \refl\bigr) \;:\; \Path_A(a,a).
  \end{align*}
  These have the same proof field ($\refl$) but differ in their step lists:
  $p.\mathrm{steps} = [\,]$ while $q.\mathrm{steps} = [\langle a, a,
  \refl\rangle]$. Since the step lists are structurally distinct,
  $p \neq q$ as elements of $\Path_A(a,a)$.
\end{proof}

\begin{remark}\label{rem:key-distinction}
  \Cref{thm:non-uip} is the foundational result that enables the entire
  subsequent development. It shows that even in a type theory where all
  identity proofs are identified (UIP holds for $\Eq$), the space
  $\Path_A(a,b)$ supports a non-trivial ``higher'' structure. The extra
  information resides in the trace, not in the equality proof.
\end{remark}

\section{Related Work}
\label{sec:related-work}

Our work connects to several strands of research in type theory and
higher-dimensional algebra.

\paragraph{Homotopy Type Theory.}
The Univalent Foundations program~\cite{HoTTBook} interprets types as spaces,
identity types as path spaces, and higher identity types as higher homotopy
groups. In HoTT, the identity type \emph{itself} carries higher structure, and
UIP is rejected. Our approach is complementary: we work \emph{within} a
UIP-satisfying type theory and build the higher structure externally via
rewrite traces.

\paragraph{Types as weak $\omega$-groupoids.}
Lumsdaine~\cite{Lumsdaine10} and van~den~Berg--Garner~\cite{vdBG11}
independently showed that the tower of iterated identity types in intensional
type theory carries the structure of a weak $\omega$-groupoid. Our
\cref{thm:omega-groupoid} (\cref{ch:higher-dimensional}) establishes an
analogous result for computational paths, with the crucial difference that
contractibility begins at dimension~3 rather than dimension~1.

\paragraph{Cubical Type Theory.}
Bezem, Coquand, and Huber~\cite{BeCH14} introduced cubical sets as a
constructive model of HoTT. Computational paths offer an alternative
computational semantics: where cubical paths are built from interval
variables, computational paths are built from explicit rewrite steps.

\paragraph{Higher-Dimensional Rewriting.}
The rewriting-theoretic perspective on higher algebra, developed by Burroni,
M\'etayer, Lafont, and others, treats rewrite rules as generators of higher
cells. Our 75-rule rewrite system on paths (\cref{ch:rewrite-system}) can be
seen as an instance of this paradigm, with the strip lemma and confluence
results providing the coherence data.

\section{Outline of the Paper}
\label{sec:outline}

This paper (Part~I) develops the foundations of the theory of computational
paths in five chapters.

\begin{description}[leftmargin=2em,style=nextline]
  \item[\Cref{ch:basic-constructions}: Basic Constructions.]
    We introduce the fundamental operations on paths---reflexivity, symmetry,
    transitivity, congruence---and establish their strict algebraic laws. We
    develop the path algebra for products, sums, dependent pairs, and function
    types, and define transport and dependent application. We introduce unary,
    binary, and dependent contexts.

  \item[\Cref{ch:rewrite-system}: The Rewrite System.]
    We define the single-step rewrite relation $\Step$ with its 75 rules in
    eight groups, its reflexive--transitive closure $\Rw$, and the rewrite
    equality $\RwEq$. We prove soundness, develop normalization, establish
    termination via a recursive path ordering, prove local confluence
    (the strip lemma) and global confluence via a groupoid-algebraic
    argument, and construct the quotient $\PathQuot$.

  \item[\Cref{ch:groupoid}: The Groupoid of Computational Paths.]
    We show that every type carries a canonical weak groupoid structure
    under computational paths, that the quotient $\PathQuot$ is a strict
    groupoid, and that rewrite lifts provide functorial transport of the
    rewrite structure.

  \item[\Cref{ch:higher-dimensional}: Higher-Dimensional Structure.]
    We define two-cells (rewrite equalities between paths) and establish
    the weak bicategory structure. We construct the globular tower, define
    derivation cells at each dimension, prove contractibility at
    dimension~$\geq 3$, and establish the main structure theorem: computational
    paths form a weak $\omega$-groupoid.
\end{description}
