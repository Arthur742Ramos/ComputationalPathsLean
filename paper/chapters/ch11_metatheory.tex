% ============================================================================
% Chapter 11: The Rewrite System â€” Metatheory
% Part III of "The Algebra of Computational Paths"
% ============================================================================
\chapter{The Rewrite System: Metatheory}
\label{ch:metatheory}

In Part~I (Chapter~\ref{ch:rewrite-system}), we introduced the 75-rule
rewrite system on computational paths, established its soundness,
normalization properties, termination, and confluence, and constructed
the quotient $\PathQuot$. In this chapter, we examine the rewrite system
from a \emph{metatheoretic} perspective: we situate it within the
framework of typed term rewriting, develop the syntactic path expression
language \texttt{PathExpr}, analyze the strip lemma in detail, establish
the decidability of rewrite equality, describe the \texttt{path\_simp}
tactic for proof automation, and clarify the connection between
computational paths and the identity types of Homotopy Type Theory.

\section{The Typed Rewriting Perspective}
\label{sec:typed-rewriting}

\begin{definition}[Typed Rewriting System]\label{def:typed-trs}
  A \emph{typed term rewriting system} (typed TRS) consists of:
  \begin{enumerate}[label=(\roman*)]
    \item A set of \emph{sorts} (types), here the endpoint pairs $(a, b)$
      for $a, b : A$.
    \item A set of \emph{typed terms} (path expressions), well-typed by
      their source and target.
    \item A \emph{reduction relation} $\rew$ on terms of the same sort,
      given by the 75 rules of Chapter~\ref{ch:rewrite-system}.
  \end{enumerate}
  The rewrite system on $\Path_A(a, b)$ is thus a many-sorted first-order
  TRS in the sense of Klop~\cite{Klop92} and Terese~\cite{Terese03}, with
  sorts indexed by pairs of elements.
\end{definition}

\begin{remark}\label{rem:trs-features}
  Our TRS has several distinctive features compared to classical term
  rewriting:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Dependent sorts.} The sort of a path depends on its
      endpoints, which are themselves elements of the ambient type~$A$.
      Rules like associativity (Rule~\ref{rule:tt}) change the
      intermediate typing---$(p \comp q) \comp r$ has the same endpoints
      as $p \comp (q \comp r)$, but the subterms have different types.
    \item \textbf{Higher-order constructors.} The $\lamCongr$ and
      $\congrArgOp$ constructors take functions as arguments, making the
      system a \emph{higher-order} TRS in the sense of
      Nipkow~\cite{Nipkow91}.
    \item \textbf{Proof-irrelevant semantics.} While the syntactic terms
      (path expressions) are first-order or higher-order, the semantic
      interpretation collapses via $\toEq$ to the proof-irrelevant
      identity type. This separation between syntax and semantics is
      fundamental to the theory.
  \end{enumerate}
\end{remark}

\begin{definition}[The $\mathrm{LND}_{\mathrm{EQ}}$-TRS]\label{def:lndeq}
  The complete rewrite system is called the $\mathrm{LND}_{\mathrm{EQ}}$-TRS
  (following the terminology of~\cite{RDQO18}). The rules are enumerated
  using the mnemonic names of \cref{tab:lndeq-rules}.
\end{definition}

\begin{table}[ht]
\centering
\caption{The $\mathrm{LND}_{\mathrm{EQ}}$-TRS rule mnemonics and their
  correspondence to the constructors of the \texttt{Step} inductive type.}
\label{tab:lndeq-rules}
\small
\begin{tabular}{lllp{5.4cm}}
\toprule
\textbf{Mnemonic} & \textbf{Lean name} & \textbf{Group} & \textbf{Description} \\
\midrule
sr   & \texttt{symm\_refl}  & I   & $\inv{\refl} \rew \refl$ \\
ss   & \texttt{symm\_symm}  & I   & $\inv{(\inv{p})} \rew p$ \\
lrr  & \texttt{trans\_refl\_left}  & I & $\refl \comp p \rew p$ \\
rrr  & \texttt{trans\_refl\_right} & I & $p \comp \refl \rew p$ \\
tr   & \texttt{trans\_symm} & I   & $p \comp \inv{p} \rew \refl$ \\
tsr  & \texttt{symm\_trans} & I   & $\inv{p} \comp p \rew \refl$ \\
stss & \texttt{symm\_trans\_congr} & I & $\inv{(p \comp q)} \rew \inv{q} \comp \inv{p}$ \\
tt   & \texttt{trans\_assoc} & I  & $(p \comp q) \comp r \rew p \comp (q \comp r)$ \\
\midrule
mx2l1 & \texttt{map2\_subst} & II & $\mapTwo$ factorization \\
mx2l2--mx2r2 & \texttt{prod\_*\_beta} & II & Product $\beta$-rules \\
mxetaProd & \texttt{prod\_eta} & II & Product $\eta$-rule \\
mxsigmaFst/Snd & \texttt{sigma\_*\_beta} & II & $\Sigma$-type $\beta$-rules \\
mxetaSigma & \texttt{sigma\_eta} & II & $\Sigma$-type $\eta$-rule \\
mxcase & \texttt{sum\_rec\_*\_beta} & II & Sum $\beta$-rules \\
mxetaFun & \texttt{fun\_eta} & II & Function $\eta$-rule \\
mxlam & \texttt{fun\_app\_beta} & II & Function $\beta$-rule \\
\midrule
slr/srr & \texttt{context\_subst\_*\_refl\_*} & IV & Context unit rules \\
slss/srsr & \texttt{context\_subst\_*\_idempotent} & IV & Context idempotence \\
tsbll/tsbrl & \texttt{context\_subst\_*\_beta} & IV & Context $\beta$-rules \\
tsblr/tsbrr & \texttt{context\_subst\_*\_assoc} & IV & Context associativity \\
ttsv/tstu & \texttt{context\_tt\_cancel\_*} & IV & Context cancellation \\
\bottomrule
\end{tabular}
\end{table}

The precedence ranking assigns each rule a natural number via the function
$\mathrm{rank} : \mathrm{Rule} \to \Nat$ (see
\texttt{Rewrite.Termination.Rule.rank} in the formalization). The ranking
is compatible with the termination ordering: rules producing simpler
expressions receive lower ranks.

\section{PathExpr: A First-Order Term Language}
\label{sec:pathexpr}

While the type $\Path_A(a, b)$ is a \emph{record} (a list of steps paired
with a proof), reasoning about rewrites requires a \emph{syntactic}
representation of path expressions. The \texttt{PathExpr} type provides
this.

\begin{definition}[Path Expression]\label{def:pathexpr}
  The type $\mathrm{PathExpr}_{A}(a, b)$ is an inductive type with
  constructors:
  \begin{align*}
    \mathrm{atom} &: \Path_A(a, b) \to \mathrm{PathExpr}_A(a, b), \\
    \refl &: (a : A) \to \mathrm{PathExpr}_A(a, a), \\
    \mathrm{symm} &: \mathrm{PathExpr}_A(a, b) \to \mathrm{PathExpr}_A(b, a), \\
    \mathrm{trans} &: \mathrm{PathExpr}_A(a, b) \to \mathrm{PathExpr}_A(b, c)
      \to \mathrm{PathExpr}_A(a, c), \\
    \congrArgOp &: (f : A \to B) \to \mathrm{PathExpr}_A(a, b)
      \to \mathrm{PathExpr}_B(f(a), f(b)), \\
    \mapTwo &: (f : A \to B \to C) \to \mathrm{PathExpr}_A(a_1, a_2)
      \to \mathrm{PathExpr}_B(b_1, b_2) \\
      &\qquad\qquad\qquad\qquad\quad
      \to \mathrm{PathExpr}_C(f\,a_1\,b_1,\; f\,a_2\,b_2), \\
    \mathrm{context\_map} &: \Context(A, B) \to \mathrm{PathExpr}_A(a, b)
      \to \mathrm{PathExpr}_B(C(a), C(b)), \\
    \mathrm{context\_subst\_left} &: \Context(A, B)
      \to \mathrm{PathExpr}_B(x, C(a_1))
      \to \mathrm{PathExpr}_A(a_1, a_2) \\
      &\qquad\qquad\qquad\qquad\quad
      \to \mathrm{PathExpr}_B(x, C(a_2)), \\
    \mathrm{context\_subst\_right} &: \Context(A, B)
      \to \mathrm{PathExpr}_A(a_1, a_2)
      \to \mathrm{PathExpr}_B(C(a_2), y) \\
      &\qquad\qquad\qquad\qquad\quad
      \to \mathrm{PathExpr}_B(C(a_1), y).
  \end{align*}
\end{definition}

The key property of $\mathrm{PathExpr}$ is that it separates the
\emph{syntactic structure} of a path from its \emph{semantic content}.

\begin{definition}[Evaluation]\label{def:pathexpr-eval}
  The \emph{evaluation function}
  $\mathrm{eval} : \mathrm{PathExpr}_A(a, b) \to \Path_A(a, b)$
  interprets each constructor by the corresponding path operation:
  \begin{align*}
    \mathrm{eval}(\mathrm{atom}(p)) &= p, \\
    \mathrm{eval}(\refl(a)) &= \Path.\refl(a), \\
    \mathrm{eval}(\mathrm{symm}(e)) &= \Path.\mathrm{symm}(\mathrm{eval}(e)), \\
    \mathrm{eval}(\mathrm{trans}(e_1, e_2)) &= \Path.\mathrm{trans}(\mathrm{eval}(e_1),
      \mathrm{eval}(e_2)),
  \end{align*}
  and similarly for the remaining constructors.
\end{definition}

\begin{definition}[Size Measure]\label{def:pathexpr-size}
  The \emph{size} of a path expression is defined recursively:
  \begin{align*}
    \mathrm{size}(\mathrm{atom}(p)) &= 1, \qquad
    \mathrm{size}(\refl(a)) = 1, \\
    \mathrm{size}(\mathrm{symm}(e)) &= \mathrm{size}(e) + 1, \\
    \mathrm{size}(\mathrm{trans}(e_1, e_2)) &= \mathrm{size}(e_1)
      + \mathrm{size}(e_2) + 1,
  \end{align*}
  and analogously for the remaining constructors. The size provides a
  termination measure for recursive functions on path expressions.
\end{definition}

\subsection{Rewriting on PathExpr}

The single-step and multi-step rewrite relations lift from $\Path$ to
$\mathrm{PathExpr}$, with the same 75 rules applied syntactically. The
critical property is that evaluation commutes with rewriting:

\begin{theorem}[Evaluation Preserves Rewriting]\label{thm:eval-rw}
  If $e_1 \rew e_2$ as path expressions, then
  $\mathrm{eval}(e_1) \rew \mathrm{eval}(e_2)$ as paths (or
  $\mathrm{eval}(e_1) \rweq \mathrm{eval}(e_2)$).
\end{theorem}

\begin{proof}
  By induction on the derivation of $e_1 \rew e_2$. Each syntactic rule
  application maps to the corresponding semantic rule via $\mathrm{eval}$.
\end{proof}

\subsection{Confluence of PathExpr}

The main payoff of the $\mathrm{PathExpr}$ language is that confluence can
be stated and proved at the syntactic level, then transferred to $\Path$.

\begin{definition}[Join for PathExpr]\label{def:pathexpr-join}
  A \emph{join} of path expressions $e_1$ and $e_2$ is a triple
  $(m, h_1, h_2)$ where $m$ is a path expression, $h_1 : e_1 \rews m$,
  and $h_2 : e_2 \rews m$.
\end{definition}

\begin{theorem}[PathExpr Confluence]\label{thm:pathexpr-confluence}
  The rewrite system on $\mathrm{PathExpr}$ is confluent: for any
  $e_1 \rews e$ and $e_2 \rews e$ (or, equivalently, any two rewrites
  from a common source), explicit join witnesses can be computed by the
  reduction strategy.
\end{theorem}

The formalization packages this result as the typeclass
\texttt{HasJoinOfRwExpr}, which provides:
\[
  \mathsf{join\_of\_rw} : \Rw(p, q) \to \Rw(p, r) \to
  \mathrm{Join}(q, r),
\]
where the join includes an explicit meet term and the two reduction
certificates.

\begin{corollary}[Confluence Transfer]\label{cor:confluence-transfer}
  The confluence of $\mathrm{PathExpr}$ rewrites transfers to
  $\Path$-level joins: if $\Rw(\mathrm{eval}(e), p)$ and
  $\Rw(\mathrm{eval}(e), q)$, then $p$ and $q$ have a common reduct.
\end{corollary}

\begin{proof}
  Apply $\mathrm{eval}$ to the $\mathrm{PathExpr}$-level join and use
  \cref{thm:eval-rw}.
\end{proof}

\section{The Strip Lemma and Local Confluence in Detail}
\label{sec:strip-detail}

The strip lemma (\cref{thm:strip-lemma}) is the technical heart of the
confluence proof. We now describe its structure in more detail.

\begin{theorem}[Strip Lemma, Detailed]\label{thm:strip-detailed}
  Let $p \rew q$ (a single step) and $p \rews r$ (a multi-step
  reduction). Then there exists a path $m$ with $q \rews m$ and
  $r \rews m$. The proof proceeds by induction on the length of
  $p \rews r$:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Base case} ($r = p$): take $m = q$.
    \item \textbf{Inductive case} ($p \rews r'$ and $r' \rew r$):
      by the induction hypothesis applied to $p \rew q$ and $p \rews r'$,
      obtain a join $m'$ of $q$ and $r'$. Then analyze the critical pair
      $(m' \leftarrow r' \rew r)$ to produce the final join~$m$.
  \end{enumerate}
\end{theorem}

\subsection{Critical Pair Analysis}

The critical pairs of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS arise when
two rules overlap---i.e., the left-hand side of one rule is a subterm of
the left-hand side of another, or the same term matches two distinct rules.

\begin{definition}[Critical Pair]\label{def:critical-pair}
  A \emph{critical pair} is a pair $(q_1, q_2)$ of paths obtained by
  applying two different rules (or the same rule at two different
  positions) to a common redex $p$, yielding $p \rew q_1$ and
  $p \rew q_2$.
\end{definition}

The 75 rules generate a finite (though large) set of critical pairs.
The principal families of critical pairs are:

\begin{enumerate}[label=(\arabic*)]
  \item \textbf{Associativity--unit overlap.}\;
    The term $(p \comp \refl) \comp r$ matches both Rule~\ref{rule:rrr}
    (reducing to $p \comp r$) and Rule~\ref{rule:tt} (reducing to
    $p \comp (\refl \comp r)$). The latter then reduces by
    Rule~\ref{rule:lrr} to $p \comp r$. The join is $p \comp r$.

  \item \textbf{Associativity--inverse overlap.}\;
    The term $(p \comp \inv{p}) \comp r$ matches both Rule~\ref{rule:tr}
    composed with Rule~\ref{rule:lrr} (reducing to $r$) and
    Rule~\ref{rule:tt} (reducing to $p \comp (\inv{p} \comp r)$). The
    latter further reduces by the inverse law and left unit.

  \item \textbf{Product $\beta$--$\eta$ overlap.}\;
    The term $\prodMk(\fst(r), \snd(r))$ where $r = \prodMk(p, q)$:
    applying $\eta$ first gives $r = \prodMk(p, q)$; applying $\beta$ to
    each component gives $\prodMk(p, q)$.

  \item \textbf{Context--structural overlap.}\;
    A context substitution $\substL(C, r, p)$ where $p \rew p'$: the
    structural rule and the context-specific rule may both apply. The
    joins are produced via the context congruence property.

  \item \textbf{Symmetry--composition overlap.}\;
    The term $\inv{(p \comp \refl)}$ matches both Rule~\ref{rule:rrr}
    (under symmetry congruence, giving $\inv{p}$) and
    Rule~\ref{rule:stss} (giving $\inv{\refl} \comp \inv{p}$, which
    reduces to $\refl \comp \inv{p}$ and then to $\inv{p}$).
\end{enumerate}

\begin{proposition}[All Critical Pairs are Joinable]\label{prop:critical-pairs}
  Every critical pair $(q_1, q_2)$ of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS
  is joinable: there exists $m$ with $q_1 \rews m$ and $q_2 \rews m$.
  The join witnesses are explicitly constructed in the formalization.
\end{proposition}

\begin{proof}
  By exhaustive case analysis. The formalization in
  \texttt{Rewrite.ConfluenceProof} and
  \texttt{Rewrite.ConfluenceProofPathExpr} covers all cases, with each
  critical pair resolved by exhibiting a concrete join term and the
  reduction sequences reaching it.
\end{proof}

\begin{theorem}[Constructive Confluence]\label{thm:constructive-confluence}
  The confluence proof is \emph{constructive}: given two multi-step
  reductions from a common source, the join witness (the common reduct
  together with both reduction sequences) is computable. This is
  formalized in \texttt{Rewrite.ConfluenceConstructive} and packaged via
  the \texttt{HasJoinOfRw} typeclass.
\end{theorem}

\section{Decidability and the Path Tactic}
\label{sec:decidability}

\begin{theorem}[Decidability of $\RwEq$]\label{thm:rweq-decidable}
  Rewrite equality of computational paths is decidable: there is an
  algorithm that, given paths $p, q : \Path_A(a, b)$, determines whether
  $p \rweq q$.
\end{theorem}

\begin{proof}
  By \cref{thm:normalization}(iii), $p \rweq q$ if and only if
  $\normalize(p) = \normalize(q)$. Since $\normalize(p) = \ofEq(\toEq(p))$
  and $\normalize(q) = \ofEq(\toEq(q))$, equality of the normal forms
  reduces to equality of the underlying propositional equalities
  $\toEq(p)$ and $\toEq(q)$, which are equal by proof irrelevance.
  Thus $p \rweq q$ holds for \emph{all} paths with the same endpoints,
  and the decision procedure is trivial: always return ``yes.''
\end{proof}

\begin{remark}\label{rem:trivial-decidability}
  The triviality of the decision procedure is a consequence of proof
  irrelevance in the ambient type theory. In an intensional type theory
  without UIP (such as the core of HoTT), $\RwEq$-equivalence would be a
  genuinely non-trivial decision problem. In our setting, the interest
  lies not in the \emph{decision} but in the \emph{witnesses}: the
  explicit rewrite sequences connecting $p$ to its normal form.
\end{remark}

\subsection{The \texttt{path\_simp} Tactic}

The formalization provides a suite of Lean~4 tactics for automating
proofs involving rewrite equality:

\begin{definition}[Path Tactics]\label{def:path-tactics}
  The following tactics are defined in \texttt{Rewrite.PathTactic}:
  \begin{itemize}
    \item \texttt{path\_rfl}: closes $\RwEq$ goals that are reflexive
      ($p \rweq p$), via $\RwEq.\refl$.
    \item \texttt{path\_symm}: transforms a goal $p \rweq q$ into
      $q \rweq p$, via $\RwEq.\mathrm{symm}$.
    \item \texttt{path\_simp}: applies the $\mathtt{simp}$ tactic with the
      library of $\RwEq$ lemmas (registered as \texttt{@[simp]}
      attributes on all 75 rules and their derived consequences).
    \item \texttt{path\_trans h}: applies transitivity with an
      intermediate path from hypothesis~$h$.
    \item \texttt{path\_congr\_left h} / \texttt{path\_congr\_right h}:
      applies the congruence property of $\mathrm{trans}$ in the left or
      right argument.
    \item \texttt{path\_assoc}: reassociates $\mathrm{trans}$ chains to
      the right.
    \item \texttt{path\_canon}: uses the canonicalization rule to close
      goals by reducing both sides to $\ofEq$.
  \end{itemize}
\end{definition}

\begin{example}
  The following Lean proof demonstrates the tactic suite:
  \begin{center}
  \begin{minipage}{0.8\textwidth}
  \begin{verbatim}
  example (p : Path a a) :
      RwEq (trans (refl a) p) p := by
    path_simp

  example (h : RwEq p q) :
      RwEq (trans p r) (trans q r) := by
    path_congr_left h
  \end{verbatim}
  \end{minipage}
  \end{center}
\end{example}

\section{Connection to HoTT Identity Types}
\label{sec:hott-connection}

The computational paths framework has a precise relationship with
the identity types of Homotopy Type Theory.

\begin{theorem}[J-Elimination]\label{thm:j-elim}
  The computational path structure satisfies the $J$-elimination rule
  (path induction): for any type family
  $D : \Pi_{a,b : A}.\, \Path_A(a, b) \to \Type$ and any
  $d : \Pi_{a : A}.\, D(a, a, \refl(a))$, there exists
  \[
    J(D, d) : \Pi_{a, b : A}.\, \Pi_{p : \Path_A(a,b)}.\, D(a, b, p).
  \]
\end{theorem}

\begin{proof}
  Define $J(D, d, a, b, p) = \mathrm{transport}_D(p, d(a))$, where the
  transport is along the path from $(a, a, \refl(a))$ to $(a, b, p)$
  induced by the underlying equality $\toEq(p) : a =_A b$.
\end{proof}

\begin{theorem}[Function Extensionality]\label{thm:funext}
  For functions $f, g : A \to B$, if $h : \Pi_{x : A}.\, \Path_B(f(x), g(x))$
  (a pointwise path), then there exists a path
  $\mathrm{funext}(h) : \Path_{A \to B}(f, g)$.
\end{theorem}

\begin{proof}
  Construct $\mathrm{funext}(h) = \lamCongr(h)$, the function congruence
  path. Its trace records the pointwise rewrite sequence; its proof field
  is the propositional function extensionality of the ambient theory.
\end{proof}

\begin{theorem}[HoTT Compatibility]\label{thm:hott-compat}
  The path quotient $\PathQuot_A(a, b)$ is equivalent (as a type) to the
  propositional identity type $a =_A b$
  (Theorem~\ref{thm:quot-equiv}). Under this equivalence:
  \begin{enumerate}[label=(\roman*)]
    \item Path composition corresponds to transitivity of equality.
    \item Path inversion corresponds to symmetry.
    \item Congruence corresponds to $\mathrm{ap}$ (the action on paths).
    \item Transport corresponds to $\mathrm{transport}$.
    \item The $J$-rule (\cref{thm:j-elim}) corresponds to the standard
      $J$-eliminator.
  \end{enumerate}
\end{theorem}

\begin{remark}[The Univalence Question]\label{rem:univalence}
  The computational paths framework does \emph{not} require the
  univalence axiom or higher inductive types (HITs) as primitive axioms.
  Instead:
  \begin{itemize}
    \item The higher-dimensional structure (weak $\omega$-groupoid) is
      \emph{derived} from the rewrite system on traces, not postulated.
    \item Non-trivial fundamental groups arise from the path expression
      calculus (formal generators and relations), not from HITs.
    \item The contractibility at dimension~$\geq 3$
      (\cref{thm:contract3}) is a \emph{consequence} of proof irrelevance,
      not an axiom.
  \end{itemize}
  This provides a complementary approach to HoTT: where HoTT enriches
  the identity type by rejecting UIP, computational paths enrich the
  \emph{computational content} of equality proofs while retaining UIP at
  the propositional level.
\end{remark}

\section{Module Organization and Dependency Structure}
\label{sec:module-organization}

The metatheoretic results are organized across the following modules in
the \texttt{Rewrite} directory:

\begin{center}
\small
\begin{tabular}{lp{7.5cm}}
\toprule
\textbf{Module} & \textbf{Contents} \\
\midrule
\texttt{Step.lean} & The 75-rule \texttt{Step} inductive type and soundness proof \\
\texttt{Rw.lean} & Reflexive--transitive closure $\Rw$ \\
\texttt{RwEq.lean} & Rewrite equality $\RwEq$ and all congruence lemmas \\
\texttt{Normalization.lean} & Normal forms and the $\normalize$ function \\
\texttt{LNDEQ.lean} & Rule enumeration and mnemonic names \\
\texttt{Termination.lean} & Rule precedence and RPO measure \\
\texttt{StripLemma.lean} & The strip lemma (local confluence) \\
\texttt{Confluence.lean} & Join structure and \texttt{HasJoinOfRw} interface \\
\texttt{ConfluenceProof.lean} & Concrete join witnesses \\
\texttt{ConfluenceFull.lean} & Full confluence theorem \\
\texttt{ConfluenceConstructive.lean} & Constructive confluence certificates \\
\texttt{PathExpr.lean} & Syntactic path expressions (1,228 lines) \\
\texttt{ExprConfluence.lean} & \texttt{HasJoinOfRwExpr} typeclass \\
\texttt{PathExprConfluence.lean} & Confluence transfer to $\Path$ \\
\texttt{PathTactic.lean} & The \texttt{path\_simp} tactic suite \\
\texttt{Quot.lean} & The quotient $\PathQuot$ and its operations \\
\texttt{SimpleEquiv.lean} & Equivalence $\PathQuot \simeq \mathrm{Eq}$ \\
\texttt{MinimalAxioms.lean} & Minimal axiom sets for the TRS \\
\bottomrule
\end{tabular}
\end{center}

The dependency chain for the full metatheory is:
\[
  \texttt{Step} \to \texttt{Rw} \to \texttt{RwEq} \to
  \texttt{Normalization} \to \texttt{Termination} \to
  \texttt{StripLemma} \to \texttt{Confluence} \to \texttt{Quot}.
\]
The $\mathrm{PathExpr}$ branch runs in parallel:
\[
  \texttt{PathExpr} \to \texttt{ExprConfluence} \to
  \texttt{PathExprConfluence},
\]
joining the main branch at the confluence level.
