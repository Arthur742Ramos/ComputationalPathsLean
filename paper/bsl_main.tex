% ============================================================================
% The Algebra of Computational Paths — BSL Format
% ============================================================================
% Compile: pdflatex bsl_main && bibtex bsl_main && pdflatex bsl_main && pdflatex bsl_main
% ============================================================================
\documentclass[manuscript]{BSLstyle}

% --- Encoding & Fonts ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}

% --- Tables ---
\usepackage{booktabs}

% Tell cleveref about theorem-like environments (provided by BSLstyle)
\crefname{definition}{Definition}{Definitions}
\Crefname{definition}{Definition}{Definitions}
\crefname{theorem}{Theorem}{Theorems}
\Crefname{theorem}{Theorem}{Theorems}
\crefname{lemma}{Lemma}{Lemmas}
\Crefname{lemma}{Lemma}{Lemmas}
\crefname{proposition}{Proposition}{Propositions}
\Crefname{proposition}{Proposition}{Propositions}
\crefname{corollary}{Corollary}{Corollaries}
\Crefname{corollary}{Corollary}{Corollaries}
\crefname{remark}{Remark}{Remarks}
\Crefname{remark}{Remark}{Remarks}
\crefname{example}{Example}{Examples}
\Crefname{example}{Example}{Examples}

% ============================================================================
% Custom operators and notation
% ============================================================================
\DeclareMathOperator{\refl}{refl}
\DeclareMathOperator{\symop}{symm}
\DeclareMathOperator{\ofEq}{ofEq}
\DeclareMathOperator{\toEq}{toEq}
\DeclareMathOperator{\tr}{transport}
\DeclareMathOperator{\apd}{apd}
\DeclareMathOperator{\id}{id}

\DeclareMathOperator{\congrArgOp}{congrArg}
\DeclareMathOperator{\mapLeft}{mapLeft}
\DeclareMathOperator{\mapRight}{mapRight}
\DeclareMathOperator{\mapTwo}{map_2}
\DeclareMathOperator{\prodMk}{prodMk}
\DeclareMathOperator{\fst}{fst}
\DeclareMathOperator{\snd}{snd}
\DeclareMathOperator{\inlOp}{inl}
\DeclareMathOperator{\inrOp}{inr}
\DeclareMathOperator{\sigmaMk}{sigmaMk}
\DeclareMathOperator{\sigmaFst}{sigmaFst}
\DeclareMathOperator{\sigmaSnd}{sigmaSnd}
\DeclareMathOperator{\lamCongr}{lamCongr}
\DeclareMathOperator{\app}{app}

\DeclareMathOperator{\substL}{substL}
\DeclareMathOperator{\substR}{substR}
\DeclareMathOperator{\normalize}{normalize}

% Aliases
\newcommand{\congrArg}{\congrArgOp}
\newcommand{\transport}{\tr}
\newcommand{\symm}{\symop}
\newcommand{\inl}{\inlOp}
\newcommand{\inr}{\inrOp}

% Short-hand
\newcommand{\Path}{\operatorname{Path}}
\newcommand{\Step}{\operatorname{Step}}
\newcommand{\Rw}{\operatorname{Rw}}
\newcommand{\RwEq}{\operatorname{RwEq}}
\newcommand{\PathQuot}{\operatorname{PathQuot}}
\newcommand{\LoopQuot}{\operatorname{LoopQuot}}
\newcommand{\StrictGroupoid}{\operatorname{StrictGroupoid}}
\newcommand{\Context}{\operatorname{Context}}
\newcommand{\BiContext}{\operatorname{BiContext}}
\newcommand{\DepContext}{\operatorname{DepContext}}
\newcommand{\Derivation}{\operatorname{D}}
\newcommand{\Deriv}{\operatorname{D}}
\newcommand{\MetaStep}{\operatorname{MetaStep}}
\newcommand{\PathRwQuot}{\operatorname{PathRwQuot}}

% Rewrite arrows
\newcommand{\rew}{\mathbin{\triangleright}}         % single step
\newcommand{\rews}{\mathbin{\triangleright^{*}}}    % multi-step
\newcommand{\rweq}{\mathbin{\approx}}               % rewrite equality

% Misc
\newcommand{\comp}{\mathbin{\cdot}}
\newcommand{\inv}[1]{{#1}^{-1}}
\newcommand{\ofEqfn}[1]{\ofEq(#1)}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\Sort}{\mathsf{Sort}}
\newcommand{\Type}{\mathsf{Type}}
\newcommand{\Prop}{\mathsf{Prop}}
\newcommand{\List}{\operatorname{List}}
\newcommand{\Eq}{\operatorname{Eq}}
\newcommand{\IdA}{\operatorname{Id}}
\newcommand{\ab}{\mathrm{ab}}
\providecommand{\trans}{}% ensure defined before renew
\renewcommand{\trans}{\operatorname{trans}}

% ============================================================================
% BSL metadata
% ============================================================================
\AuthorEmail{Arthur Freitas Ramos}{arfreita@microsoft.com}{25}
\AuthorEmail{Ruy J.\,G.\,B.\ de Queiroz}{ruy@cin.ufpe.br}{25}
\AuthorEmail{Anjolina G.\ de Oliveira}{ago@cin.ufpe.br}{25}
\AuthorEmail{Tiago Mendonca Lucena de Veras}{tiago.veras@ufrpe.br}{25}

\Affiliation{Microsoft}{}{One Microsoft Way}{Redmond WA 98052}{1}
\Affiliation{UFPE}{Centro de Informatica}{}{}{2,3}
\Affiliation{UFRPE}{Dept of Mathematics}{}{}{4}

\Funding{Not applicable.}
\Conflict{None.}
\Ethics{The authors assure no violations of publication ethics and take full responsibility for the content of the publication.}
\UseOfGAI{Not used.}

\AuthAbbrv{b}

\Title[The Algebra of Computational Paths]{The Algebra of Computational Paths: \\
Rewrite-Trace Equality, Weak $\omega$-Groupoids, \\
and Higher-Dimensional Structure}

% ============================================================================
\begin{document}

\begin{abstract}
We develop a mathematical theory of \emph{computational paths}---equality proofs
equipped with explicit rewrite traces---and the associated rewrite system. The
system is confluent and terminating (75 rules in eight groups), supports path
algebra and type-former $\beta/\eta$ laws, and yields a weak $\omega$-groupoid
structure in the sense of Batanin--Leinster~\cite{Batanin98}. Contractibility
begins at dimension~3, preserving non-trivial fundamental groups. The full
development and its homotopy-theoretic applications are mechanically verified
in Lean~4.
\end{abstract}

\begin{keywords}
computational paths, identity types, rewrite systems, weak $\omega$-groupoids,
homotopy type theory, Lean~4
\end{keywords}

% ============================================================================
%  SECTION 1: INTRODUCTION AND MOTIVATION
% ============================================================================
\section{Introduction and Motivation}
\label{sec:introduction}

% ----------------------------------------------------------------------------
\subsection{The Curry--Howard--de~Bruijn Correspondence and Propositional
  Equality}
\label{subsec:curry-howard}

In Martin-L\"of type theory~\cite{MartinLof84}, the \emph{identity type} $\IdA_A(a,b)$ captures
propositional equality between elements $a,b : A$. Its sole introduction rule
is reflexivity: the term $\refl(a) : \IdA_A(a,a)$ witnesses that every element
is equal to itself. The elimination rule---\emph{path induction}, also known as
the~$J$-rule---states that to prove a property of an arbitrary inhabitant of
$\IdA_A(a,b)$, it suffices to verify the property for $\refl(a)$.

In proof assistants based on the Calculus of Inductive Constructions,
the identity type $\mathrm{Eq}$ lives in $\Prop$, a universe
governed by \emph{proof irrelevance}: all inhabitants of a proposition are
definitionally identified. As a consequence, the \emph{Uniqueness of Identity
Proofs} (UIP) principle holds:
\begin{equation}\label{eq:uip}
  \forall\, p, q : \IdA_A(a,b),\quad p =_{\IdA_A(a,b)} q.
\end{equation}
This axiom collapses the entire space of identity proofs to at most one element
per pair of endpoints. From the perspective of homotopy type theory~\cite{HoTTBook},
UIP asserts that every type is a \emph{set} (a $0$-truncated type), precluding
the rich higher-dimensional structure that identity types can carry in
intensional type theory.

% ----------------------------------------------------------------------------
\subsection{The Computational Paths Program}
\label{subsec:comp-paths-program}

Following de~Queiroz, de~Oliveira, and Ramos~\cite{DQOR16, RDQO18, ramos19}, we propose
that equality proofs carry \emph{computational content}: the sequence of
rewriting steps that produced them. Even when the underlying logic satisfies
UIP---so that the propositional equality $a =_A b$ is proof-irrelevant---the
rewrite \emph{traces} are distinct combinatorial objects that can be compared,
composed, and quotiented.
An accompanying Lean~4 formalization is available online; see~\cite{cplean}.

The key insight is a separation of concerns:
\begin{itemize}[leftmargin=2em]
  \item The \textbf{semantic content} of an equality proof is the proposition
    $a =_A b$, which by UIP carries no information beyond its truth value.
  \item The \textbf{computational trace} is a finite sequence of elementary
    rewrite steps recording \emph{how} the equality was derived---which
    congruence rules, symmetries, transitivities, and $\beta/\eta$-reductions
    were applied, and in what order.
\end{itemize}
This separation creates a rich algebraic structure \emph{atop} the
proof-irrelevant equality, without modifying the underlying type theory.

% ----------------------------------------------------------------------------
\subsection{Design Principle: Path = Proof + Trace}
\label{subsec:design-principle}

We now state the central definitions that constitute the formal framework.

\begin{definition}[Elementary Rewrite Step]\label{def:step}
  An \emph{elementary rewrite step} in a type~$A$ is a triple
  \[
    s = (\mathrm{src}, \mathrm{tgt}, \pi) \quad\text{where}\quad
    \mathrm{src}, \mathrm{tgt} : A \quad\text{and}\quad
    \pi : \mathrm{src} =_A \mathrm{tgt}.
  \]
  We write $\Step(A)$ for the type of all elementary rewrite steps in~$A$.
\end{definition}

Each step records a single atomic equation between two elements together with
its justification. To make this concrete, consider the following example from
the $\lambda$-calculus. Given the term
$(\lambda x.\, (\lambda y.\, yx)(\lambda w.\, zw))\, v$, there are (at least)
two distinct sequences of rewrites leading to the normal form $zv$:
\begin{align*}
  s_1 &: \quad (\lambda x.\, (\lambda y.\, yx)(\lambda w.\, zw))\, v
    \;\xrightarrow{\eta}\; (\lambda x.\, (\lambda y.\, yx)\, z)\, v
    \;\xrightarrow{\beta}\; (\lambda y.\, yv)\, z
    \;\xrightarrow{\beta}\; zv, \\
  s_2 &: \quad (\lambda x.\, (\lambda y.\, yx)(\lambda w.\, zw))\, v
    \;\xrightarrow{\beta}\; (\lambda x.\, (\lambda w.\, zw)\, x)\, v
    \;\xrightarrow{\eta}\; (\lambda x.\, zx)\, v
    \;\xrightarrow{\beta}\; zv.
\end{align*}
Each individual arrow ($\xrightarrow{\beta}$ or $\xrightarrow{\eta}$) is an
\emph{elementary step}: it records a source term, a target term, and a
justification (the $\beta$- or $\eta$-rule that licenses the rewrite). The
sequences $s_1$ and $s_2$ are then \emph{computational paths}---they have the
same endpoints but carry different traces. In the theory of $\beta\eta$-equality,
both establish that
$(\lambda x.\, (\lambda y.\, yx)(\lambda w.\, zw))\, v = zv$,
but the \emph{how}---the sequence of rewrites---differs.

More generally, in our framework the elementary steps include: $\beta$- and
$\eta$-reductions for each type former (functions, products, sums, sigma types),
transport equations, congruence rules (which lift a step through a function
application), symmetry and transitivity of paths, and structural rules.
We enumerate all 75 such rules in \cref{ch:rewrite-system}.

Steps can be inverted (swapping source and target) and
mapped through functions.

\begin{definition}[Computational Path]\label{def:path}
  A \emph{computational path} from $a$ to $b$ in a type~$A$ is a pair
  \[
    p = (s, \pi) \quad\text{where}\quad
    s : \List(\Step(A)) \quad\text{and}\quad
    \pi : a =_A b.
  \]
  We write $\Path_A(a,b)$ for the type of computational paths from~$a$
  to~$b$. We do not require that consecutive steps in the list compose
  (i.e., that the target of step~$i$ equals the source of step~$i+1$);
  the proof field~$\pi$ provides the sole typing guarantee.
\end{definition}

The list $s$ is the \emph{computational trace}---it records which elementary
steps were applied. The proof $\pi$ is the \emph{semantic witness}---it
certifies that the composite rewrite is valid. Two paths with the same
endpoints but different traces are \emph{distinct} as elements of
$\Path_A(a,b)$, even though their proof fields are identified by UIP.

\begin{definition}[Semantic Projection]\label{def:toEq}
  The \emph{semantic projection} $\toEq : \Path_A(a,b) \to (a =_A b)$
  extracts the underlying propositional equality from a computational path,
  discarding the trace:
  \[
    \toEq(s, \pi) \;=\; \pi.
  \]
\end{definition}

\begin{definition}[Canonical Witness]\label{def:ofEq}
  For any propositional equality $\pi : a =_A b$, the \emph{canonical
  witness} is the single-step path
  \[
    \ofEq(\pi) \;=\; \bigl([\langle a, b, \pi\rangle],\; \pi\bigr)
    \;:\; \Path_A(a,b).
  \]
\end{definition}

The function $\ofEq$ embeds the standard identity type into the computational
path space. Its image consists precisely of the one-step paths.

% ----------------------------------------------------------------------------
\subsection{Non-UIP for Computational Paths}
\label{subsec:non-uip}

The raison d'\^etre of the computational paths framework is that it recovers
higher-dimensional structure even in a proof-irrelevant setting:

\begin{theorem}[Non-UIP for Paths]\label{thm:non-uip}
  For any nonempty type~$A$, the space of computational paths does not
  satisfy the Uniqueness of Identity Proofs:
  \[
    \neg\,\bigl(\forall\, a, b : A,\;\forall\, p, q : \Path_A(a,b),\;
    p = q\bigr).
  \]
\end{theorem}

\begin{proof}
  Let $a : A$ be any element. Consider two paths from $a$ to itself:
  \begin{align*}
    p &\;=\; \refl(a) \;=\; ([\,],\; \refl) \;:\; \Path_A(a,a), \\
    q &\;=\; \ofEq(\refl) \;=\; \bigl([\langle a, a, \refl\rangle],\;
    \refl\bigr) \;:\; \Path_A(a,a).
  \end{align*}
  These have the same proof field ($\refl$) but differ in their step lists:
  $p.\mathrm{steps} = [\,]$ while $q.\mathrm{steps} = [\langle a, a,
  \refl\rangle]$. Since the step lists are structurally distinct,
  $p \neq q$ as elements of $\Path_A(a,a)$.
\end{proof}

\begin{remark}\label{rem:key-distinction}
  \cref{thm:non-uip} is the foundational result that enables the entire
  subsequent development. It shows that even in a type theory where all
  identity proofs are identified (UIP holds for $\Eq$), the space
  $\Path_A(a,b)$ supports a non-trivial ``higher'' structure. The extra
  information resides in the trace, not in the equality proof.
\end{remark}

% ----------------------------------------------------------------------------
\subsection{Related Work}
\label{subsec:related-work}

Our work connects to several strands of research in type theory and
higher-dimensional algebra~\cite{BaezDolan95}.

\paragraph{Homotopy Type Theory.}
The Univalent Foundations program~\cite{HoTTBook} interprets types as spaces,
identity types as path spaces, and higher identity types as higher homotopy
groups. In HoTT, the identity type \emph{itself} carries higher structure, and
UIP is rejected. Our approach is complementary: we work \emph{within} a
UIP-satisfying type theory and build the higher structure externally via
rewrite traces.

\paragraph{Types as weak $\omega$-groupoids.}
Lumsdaine~\cite{Lumsdaine10} and van~den~Berg--Garner~\cite{vdBG11}
independently showed that the tower of iterated identity types in intensional
type theory carries the structure of a weak $\omega$-groupoid. Our
\cref{thm:omega-groupoid} (\cref{ch:higher-dimensional}) establishes an
analogous result for computational paths, with the crucial difference that
contractibility begins at dimension~3 rather than dimension~1.

\paragraph{Cubical Type Theory.}
Bezem, Coquand, and Huber~\cite{BeCH14} introduced cubical sets as a
constructive model of HoTT. Computational paths offer an alternative
computational semantics: where cubical paths are built from interval
variables, computational paths are built from explicit rewrite steps.~\cite{CCHM18}

\paragraph{Higher-Dimensional Rewriting.}
The rewriting-theoretic perspective on higher algebra, developed by Burroni,
M\'etayer, Lafont, and others~\cite{Burroni93, Metayer03, lafont09}, treats rewrite rules as generators of higher
cells. Our 75-rule rewrite system on paths (\cref{ch:rewrite-system}) can be
seen as an instance of this paradigm, with the strip lemma and confluence
results providing the coherence data.

% ----------------------------------------------------------------------------
\subsection{Outline of the Paper}
\label{subsec:outline}

This paper develops the foundations and applications of the theory of
computational paths in several sections following this introduction.

\begin{description}[leftmargin=2em,style=nextline]
  \item[\cref{sec:basic-constructions}: Basic Constructions.]
    We introduce the fundamental operations on paths---reflexivity, symmetry,
    transitivity, congruence---and establish their strict algebraic laws. We
    develop the path algebra for products, sums, dependent pairs, and function
    types, and define transport and dependent application. We introduce unary,
    binary, and dependent contexts.

  \item[\cref{ch:rewrite-system}: The Rewrite System.]
    We define the single-step rewrite relation $\Step$ with its 75 rules in
    eight groups, its reflexive--transitive closure $\Rw$, and the rewrite
    equality $\RwEq$. We prove soundness, develop normalization, establish
    termination via a recursive path ordering, prove local confluence
    (the strip lemma) and global confluence (via Newman's lemma), and
    construct the quotient $\PathQuot$.

  \item[\cref{ch:groupoid}: The Groupoid of Computational Paths.]
    We show that every type carries a canonical weak groupoid structure~\cite{hofmann98}
    under computational paths, that the quotient $\PathQuot$ is a strict
    groupoid, and that rewrite lifts provide functorial transport of the
    rewrite structure.

  \item[\cref{ch:higher-dimensional}: Higher-Dimensional Structure.]
    We define two-cells (rewrite equalities between paths) and establish
    the weak bicategory structure. We construct the globular tower, define
    derivation cells at each dimension, prove contractibility at
    dimension~$\geq 3$, and establish the main structure theorem:
    computational paths form a weak $\omega$-groupoid.
\end{description}

We then turn to the homotopy-theoretic applications and metatheory.

\begin{description}[leftmargin=2em,style=nextline]
  \item[\cref{sec:fundamental-groups}: Fundamental Groups and Loop Spaces.]
    We define loop spaces and the fundamental group, establish functoriality,
    and introduce the fundamental groupoid.

  \item[\cref{sec:spaces}: Spaces and Their Fundamental Groups.]
    We compute $\pi_1$ for standard spaces, including the circle, torus,
    and pushouts, using the path-expression language.

  \item[\cref{sec:applications}: Applications and Further Results.]
    We state the path-lifting property, covering-space classification, long
    exact sequences, the Hurewicz theorem, excision, Mayer--Vietoris, and a
    catalog of advanced formalized applications.

  \item[\cref{ch:metatheory}: The Rewrite System: Metatheory.]
    We situate the TRS in typed rewriting, prove decidability and automation
    results, and connect computational paths to identity types.

  \item[\cref{ch:conclusion}: Conclusion and Future Directions.]
    We summarize the contributions and discuss further research directions.
\end{description}

\paragraph{Formalization status.}
Sections~\ref{sec:basic-constructions}--\ref{ch:higher-dimensional} are fully formalized in Lean. Later sections mix fully formalized and scaffolded results; we flag the status at the start of each later section and summarize all statuses in \cref{tab:formalization-status} (Section~\ref{sec:formalization}).


% ============================================================================
%  SECTION 2: BASIC CONSTRUCTIONS
% ============================================================================
\section{Computational Paths: Basic Constructions}
\label{sec:basic-constructions}

Throughout this section, $A$, $B$, $C$ denote types in a fixed universe,
and $a, b, c, d$ denote elements of~$A$ unless otherwise stated.

% ----------------------------------------------------------------------------
\subsection{Fundamental Operations}
\label{subsec:fundamental-ops}

We equip the space $\Path_A(a,b)$ with three primitive operations.

\begin{definition}[Reflexivity]\label{def:refl}
  The \emph{reflexive path} at $a : A$ is
  \[
    \refl(a) \;=\; ([\,],\; \refl_a) \;:\; \Path_A(a,a),
  \]
  where the step list is empty and the proof field is the reflexivity
  of~$\Eq$.
\end{definition}

\begin{definition}[Symmetry]\label{def:symm}
  For $p = (s, \pi) : \Path_A(a,b)$, the \emph{symmetric path} is
  \[
    \inv{p} \;=\;
    \bigl(\mathrm{reverse}(\mathrm{map}(\mathrm{symm}_{\Step}, s)),\;
    \pi^{-1}\bigr) \;:\; \Path_A(b,a),
  \]
  where $\mathrm{symm}_{\Step}$ inverts each elementary step and
  $\mathrm{reverse}$ reverses the list.
  We write $\inv{p}$ throughout; the Lean formalization uses the
  name~$\symop$.
\end{definition}

\begin{definition}[Transitivity / Composition]\label{def:trans}
  For $p = (s_1, \pi_1) : \Path_A(a,b)$ and
  $q = (s_2, \pi_2) : \Path_A(b,c)$, the \emph{composite path} is
  \[
    p \comp q \;=\; \mathrm{trans}(p, q) \;=\;
    (s_1 \mathbin{+\!\!+} s_2,\; \pi_1 \cdot \pi_2) \;:\; \Path_A(a,c),
  \]
  where $\mathbin{+\!\!+}$ denotes list concatenation and $\cdot$ is
  transitivity of~$\Eq$.
\end{definition}

\begin{remark}
  We use $p \comp q$ and $\mathrm{trans}(p, q)$ interchangeably,
  adopting the diagrammatic order: $p$ is followed by~$q$.
\end{remark}

% ----------------------------------------------------------------------------
\subsection{Strict Algebraic Laws}
\label{subsec:strict-laws}

A remarkable feature of computational paths is that many algebraic identities
hold as \emph{strict} equalities---i.e., as definitional equalities of the
$\Path$ record structure---not merely up to rewriting. This is a consequence
of the list-based representation: the laws reduce to standard identities on
list concatenation and reversal.

\begin{theorem}[Strict Monoid Laws]\label{thm:strict-monoid}
  For all $p : \Path_A(a,b)$, $q : \Path_A(b,c)$,
  $r : \Path_A(c,d)$:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left identity.}\; $\refl(a) \comp p = p$.
    \item \textbf{Right identity.}\; $p \comp \refl(b) = p$.
    \item \textbf{Associativity.}\;
      $(p \comp q) \comp r = p \comp (q \comp r)$.
  \end{enumerate}
  All three equalities hold as structural equalities of $\Path$ records
  (not merely up to rewriting).
\end{theorem}

\begin{proof}
  (i) By definition,
  $\refl(a) \comp p = ([\,] \mathbin{+\!\!+} s,\; \refl \cdot \pi)
  = (s, \pi) = p$, since prepending the empty list is the identity on
  lists, and $\refl \cdot \pi = \pi$.
  (ii) Similarly,
  $p \comp \refl(b) = (s \mathbin{+\!\!+} [\,],\; \pi \cdot \refl)
  = (s, \pi) = p$.
  (iii) Follows from $\mathrm{List.append\_assoc}$:
  $(s_1 \mathbin{+\!\!+} s_2) \mathbin{+\!\!+} s_3
  = s_1 \mathbin{+\!\!+} (s_2 \mathbin{+\!\!+} s_3)$ and
  associativity of $\Eq.\mathrm{trans}$.
\end{proof}

\begin{theorem}[Strict Involution]\label{thm:strict-involution}
  For all $p : \Path_A(a,b)$:
  \[
    \inv{(\inv{p})} = p.
  \]
\end{theorem}

\begin{proof}
  We compute $\inv{(\inv{p})}$: reversing the reversed list recovers the
  original list, and applying $\mathrm{symm}_{\Step}$ twice to each step
  is the identity (since swapping source and target twice returns to the
  original step). On the proof field, $(\pi^{-1})^{-1} = \pi$.
\end{proof}

\begin{theorem}[Strict Anti-Homomorphism]\label{thm:strict-antihom}
  For all $p : \Path_A(a,b)$ and $q : \Path_A(b,c)$:
  \[
    \inv{(p \comp q)} \;=\; \inv{q} \comp \inv{p}.
  \]
\end{theorem}

\begin{proof}
  By the list identity
  $\mathrm{reverse}(s_1 \mathbin{+\!\!+} s_2) =
  \mathrm{reverse}(s_2) \mathbin{+\!\!+} \mathrm{reverse}(s_1)$
  and the fact that mapping commutes with reversal and append.
\end{proof}

\begin{remark}[Cancellation is not strict]\label{rem:cancel-not-strict}
  The cancellation law $p \comp \inv{p} = \refl(a)$ does \emph{not}
  hold strictly: the left-hand side has step list
  $s \mathbin{+\!\!+} \mathrm{reverse}(\mathrm{map}(\mathrm{symm}_{\Step}, s))$,
  which is non-empty whenever $s \neq [\,]$, while $\refl(a)$ has an
  empty step list. Cancellation holds only up to the rewrite
  relation~$\Step$ (\cref{ch:rewrite-system}).
\end{remark}

% ----------------------------------------------------------------------------
\subsection{Congruence (Functorial Action)}
\label{subsec:congruence}

\begin{definition}[Unary Congruence]\label{def:congrArg}
  For $f : A \to B$ and $p = (s, \pi) : \Path_A(a,b)$, the
  \emph{congruence} (or \emph{functorial action}) of~$f$ on~$p$ is
  \[
    f_*(p) \;=\; \congrArgOp(f, p) \;=\;
    \bigl(\mathrm{map}(\mathrm{map}_f, s),\; \congrArgOp(f, \pi)\bigr)
    \;:\; \Path_B(f(a), f(b)),
  \]
  where $\mathrm{map}_f$ sends a step $\langle x, y, h \rangle$ to
  $\langle f(x), f(y), \congrArgOp(f, h) \rangle$.
\end{definition}

The functorial action satisfies strict algebraic laws:

\begin{theorem}[Functoriality of Congruence]\label{thm:congrArg-functor}
  For $f : A \to B$, $g : B \to C$, and paths $p : \Path_A(a,b)$,
  $q : \Path_A(b,c)$:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Composition.}\;
      $f_*(p \comp q) = f_*(p) \comp f_*(q)$.
    \item \textbf{Symmetry.}\;
      $f_*(\inv{p}) = \inv{f_*(p)}$.
    \item \textbf{Identity.}\;
      $\id_*(p) = p$ \;(where $\id = \lambda x.\, x$).
    \item \textbf{Composition of functions.}\;
      $(g \circ f)_*(p) = g_*(f_*(p))$.
  \end{enumerate}
  All equalities are strict.
\end{theorem}

\begin{proof}
  Each part reduces to a standard identity on list operations:
  (i)~$\mathrm{map}(F, s_1 \mathbin{+\!\!+} s_2) = \mathrm{map}(F, s_1)
  \mathbin{+\!\!+} \mathrm{map}(F, s_2)$.
  (ii)~$\mathrm{map}(F, \mathrm{reverse}(\mathrm{map}(G, s))) =
  \mathrm{reverse}(\mathrm{map}(F \circ G, s))$, combined with the fact
  that $\mathrm{map}_f \circ \mathrm{symm}_{\Step} = \mathrm{symm}_{\Step}
  \circ \mathrm{map}_f$.
  (iii)~$\mathrm{map}_{\id} = \id$ on steps.
  (iv)~$\mathrm{map}_{g \circ f} = \mathrm{map}_g \circ \mathrm{map}_f$
  on steps.
\end{proof}

\begin{corollary}\label{cor:path-functor}
  The assignment $A \mapsto \Path_A$ and $f \mapsto f_*$ is a functor from
  the category of types and functions to the category of types and
  path-preserving maps (strictly preserving composition and identities).
\end{corollary}

% ----------------------------------------------------------------------------
\subsection{Binary Congruence}
\label{subsec:binary-congruence}

For binary functions, congruence decomposes into left and right components.

\begin{definition}[Left, Right, and Binary Maps]\label{def:binary-maps}
  Let $f : A \to B \to C$.
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left map.}\;
      $\mapLeft(f, p, b) = (\lambda x.\, f(x,b))_*(p)
      : \Path_C(f(a_1, b), f(a_2, b))$
      for $p : \Path_A(a_1, a_2)$ and $b : B$.
    \item \textbf{Right map.}\;
      $\mapRight(f, a, q) = f(a)_*(q)
      : \Path_C(f(a, b_1), f(a, b_2))$
      for $a : A$ and $q : \Path_B(b_1, b_2)$.
    \item \textbf{Binary map.}\;
      $\mapTwo(f, p, q) = \mapLeft(f, p, b_1) \comp \mapRight(f, a_2, q)$
      for $p : \Path_A(a_1, a_2)$ and $q : \Path_B(b_1, b_2)$.
  \end{enumerate}
\end{definition}

The binary map first varies the left argument (holding the right argument
at its \emph{source} $b_1$), then varies the right argument (holding the
left argument at its \emph{target} $a_2$). This is the canonical choice
that makes the binary map compose correctly with projections.

The binary map satisfies its own functoriality laws, inherited from those
of the unary congruence. In particular, $\mapTwo(f, -, -)$ preserves
composition in each variable separately:
\[
  \mapTwo(f, p_1 \comp p_2, q_1 \comp q_2) =
  \mapLeft(f, p_1, b_1) \comp \mapLeft(f, p_2, b_1) \comp
  \mapRight(f, a_3, q_1) \comp \mapRight(f, a_3, q_2).
\]
Symmetry of $\mapTwo$ reverses the order of the components:
\[
  \inv{\mapTwo(f, p, q)} = \mapRight(f, a_2, \inv{q}) \comp
  \mapLeft(f, \inv{p}, b_1).
\]

% ----------------------------------------------------------------------------
\subsection{Product Paths}
\label{subsec:product-paths}

\begin{definition}[Product Path Operations]\label{def:prod-paths}
  For $p : \Path_A(a_1, a_2)$ and $q : \Path_B(b_1, b_2)$:
  \begin{enumerate}[label=(\roman*)]
    \item $\prodMk(p, q) = \mapTwo(\mathrm{Prod.mk}, p, q)
      : \Path_{A \times B}((a_1, b_1), (a_2, b_2))$.
    \item $\fst(r) = (\mathrm{Prod.fst})_*(r)$ for
      $r : \Path_{A \times B}((a_1, b_1), (a_2, b_2))$.
    \item $\snd(r) = (\mathrm{Prod.snd})_*(r)$ for
      $r : \Path_{A \times B}((a_1, b_1), (a_2, b_2))$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Product $\beta$/$\eta$-Rules]\label{thm:prod-beta-eta}
  The product path operations satisfy:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{$\beta$-rules.}\;
      $\fst(\prodMk(p, q)) = p$ \;(strictly, by functoriality);\;
      $\snd(\prodMk(p, q))$ reduces to~$q$ via a single rewrite step.
    \item \textbf{$\eta$-rule.}\;
      $\prodMk(\fst(r), \snd(r)) \rew r$
      \;(as a rewrite step, see \cref{ch:rewrite-system}).
  \end{enumerate}
\end{theorem}

The $\eta$-rule is not a strict equality because
$\prodMk(\fst(r), \snd(r))$ applies the binary map construction,
producing a different step list than the original path~$r$.

% ----------------------------------------------------------------------------
\subsection{Sigma Paths}
\label{subsec:sigma-paths}

For a dependent type $B : A \to \Type$, paths between dependent pairs
$\langle a_1, b_1 \rangle$ and $\langle a_2, b_2 \rangle$ in
$\Sigma_{x:A} B(x)$ decompose into a base path and a fiber path.

\begin{definition}[Sigma Path Operations]\label{def:sigma-paths}
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Construction.}\;
      $\sigmaMk(p, q) : \Path_{\Sigma B}(\langle a_1, b_1\rangle,
      \langle a_2, b_2\rangle)$ where $p : \Path_A(a_1, a_2)$ and
      $q : \Path_{B(a_2)}(\tr(p, b_1), b_2)$.
    \item \textbf{First projection.}\;
      $\sigmaFst(r) = (\Sigma.\mathrm{fst})_*(r) : \Path_A(a_1, a_2)$.
    \item \textbf{Second projection.}\;
      $\sigmaSnd(r) : \Path_{B(a_2)}(\tr(\sigmaFst(r), b_1), b_2)$.
  \end{enumerate}
\end{definition}

The sigma path operations satisfy analogous $\beta/\eta$-rules to the
product case. These hold as rewrite steps (not strict equalities), since
the $\sigmaMk$ constructor creates a single-step path via $\ofEq$:
\begin{align*}
  \sigmaFst(\sigmaMk(p, q)) &\rew \ofEq(\toEq(p)), \\
  \sigmaSnd(\sigmaMk(p, q)) &\rew \ofEq(\toEq(q)), \\
  \sigmaMk(\sigmaFst(r), \sigmaSnd(r)) &\rew r.
\end{align*}

% ----------------------------------------------------------------------------
\subsection{Sum Paths}
\label{subsec:sum-paths}

\begin{definition}[Sum Path Constructors]\label{def:sum-paths}
  For $p : \Path_A(a_1, a_2)$ and $q : \Path_B(b_1, b_2)$:
  \begin{enumerate}[label=(\roman*)]
    \item $\inlOp_*(p) = (\mathrm{Sum.inl})_*(p) :
      \Path_{A + B}(\mathrm{inl}(a_1), \mathrm{inl}(a_2))$.
    \item $\inrOp_*(q) = (\mathrm{Sum.inr})_*(q) :
      \Path_{A + B}(\mathrm{inr}(b_1), \mathrm{inr}(b_2))$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Sum $\beta$-Rules]\label{thm:sum-beta}
  For $f : A \to C$, $g : B \to C$, and the eliminator
  $\mathrm{rec}(f, g) : A + B \to C$:
  \begin{align*}
    (\mathrm{rec}(f,g))_*(\inlOp_*(p)) &\rew f_*(p), \\
    (\mathrm{rec}(f,g))_*(\inrOp_*(q)) &\rew g_*(q).
  \end{align*}
\end{theorem}

% ----------------------------------------------------------------------------
\subsection{Function Paths}
\label{subsec:function-paths}

\begin{definition}[Function Path Operations]\label{def:fun-paths}
  Let $f, g : A \to B$.
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Lambda congruence.}\;
      $\lamCongr(p) : \Path_{A \to B}(f, g)$ where
      $p : \prod_{x:A} \Path_B(f(x), g(x))$ is a family of pointwise
      paths. The step list is empty and the proof field is
      $\mathrm{funext}(\lambda x.\, \toEq(p(x)))$.
    \item \textbf{Application.}\;
      $\app(r, a) = (\lambda h.\, h(a))_*(r) : \Path_B(f(a), g(a))$
      for $r : \Path_{A \to B}(f, g)$ and $a : A$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Function $\beta$/$\eta$-Rules]\label{thm:fun-beta-eta}
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{$\beta$.}\;
      $\app(\lamCongr(p), a) \rew p(a)$.
    \item \textbf{$\eta$.}\;
      $\lamCongr(\lambda x.\, \app(q, x)) \rew q$.
  \end{enumerate}
\end{theorem}

Additional strict identities hold for $\lamCongr$: it preserves composition
and symmetry strictly:
\begin{align*}
  \lamCongr(p) \comp \lamCongr(q) &= \lamCongr(\lambda x.\, p(x) \comp q(x)),\\
  \inv{\lamCongr(p)} &= \lamCongr(\lambda x.\, \inv{p(x)}).
\end{align*}

% ----------------------------------------------------------------------------
\subsection{Transport and Dependent Application}
\label{subsec:transport}

\begin{definition}[Transport]\label{def:transport}
  For a type family $D : A \to \Sort$, a path $p : \Path_A(a,b)$, and
  an element $x : D(a)$, the \emph{transport} of $x$ along $p$ is
  \[
    \tr_D(p, x) \;=\; \Eq.\mathrm{rec}(\pi, x) \;:\; D(b),
  \]
  where $\pi = \toEq(p) : a =_A b$. Transport uses only the semantic
  content of~$p$, not its trace.
\end{definition}

\begin{theorem}[Transport Laws]\label{thm:transport-laws}
  The following hold strictly:
  \begin{enumerate}[label=(\roman*)]
    \item $\tr_D(\refl(a), x) = x$.
    \item $\tr_D(p \comp q, x) = \tr_D(q, \tr_D(p, x))$.
    \item $\tr_D(\inv{p}, \tr_D(p, x)) = x$.
    \item $\tr_D(p, \tr_D(\inv{p}, y)) = y$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  All follow from case analysis on the path's proof field.
  Since $\Eq.\mathrm{rec}$ is definitionally the identity when the
  proof is $\refl$, (i) is immediate. Parts (ii)--(iv) follow from
  the corresponding properties of $\Eq.\mathrm{rec}$.
\end{proof}

\begin{definition}[Dependent Application]\label{def:apd}
  For a dependent function $f : \prod_{x:A} D(x)$ and a path
  $p : \Path_A(a,b)$, the \emph{dependent application} is
  \[
    \apd(f, p) \;:\; \Path_{D(b)}(\tr_D(p, f(a)),\; f(b)).
  \]
  When $p = \refl(a)$, this reduces to $\refl(f(a))$.
\end{definition}

% ----------------------------------------------------------------------------
\subsection{Contexts}
\label{subsec:contexts}

Contexts formalize substitution of paths into sub-expressions. They are the
categorical analogue of ``evaluation in context'' from term rewriting.

\begin{definition}[Unary Context]\label{def:context}
  A \emph{context} $C : \Context(A, B)$ is a function
  $\mathrm{fill} : A \to B$. It acts on paths by
  \[
    C[p] \;=\; \congrArgOp(\mathrm{fill}, p) \;:\;
    \Path_B(C[a_1], C[a_2])
  \]
  for $p : \Path_A(a_1, a_2)$, where we write $C[a]$ for
  $\mathrm{fill}(a)$.
\end{definition}

\begin{definition}[Context Substitution]\label{def:context-subst}
  Let $C : \Context(A, B)$.
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left substitution.}\;
      $\substL(C, r, p) = r \comp C[p] : \Path_B(x, C[a_2])$
      for $r : \Path_B(x, C[a_1])$ and $p : \Path_A(a_1, a_2)$.
    \item \textbf{Right substitution.}\;
      $\substR(C, p, t) = C[p] \comp t : \Path_B(C[a_1], y)$
      for $p : \Path_A(a_1, a_2)$ and $t : \Path_B(C[a_2], y)$.
  \end{enumerate}
\end{definition}

Context substitution supports an extensive algebra of identities
(cf.\ \cref{sec:context-rules} in \cref{ch:rewrite-system}),
including:
\begin{itemize}
  \item Unit laws: $\substL(C, \refl, p) \rew C[p]$ and
    $\substR(C, p, \refl) \rew C[p]$.
  \item Associativity:
    $\substR(C, p, t) \comp u \rew \substR(C, p, t \comp u)$.
  \item Idempotence:
    $\substL(C, \substL(C, r, \refl), p) \rew \substL(C, r, p)$.
  \item $\beta$-rules:
    $r \comp C[p] \rew \substL(C, r, p)$ and
    $C[p] \comp t \rew \substR(C, p, t)$.
\end{itemize}

\begin{definition}[Binary Context]\label{def:bicontext}
  A \emph{binary context} $K : \BiContext(A, B, C)$ is a function
  $\mathrm{fill} : A \to B \to C$. It supports $\mapLeft$, $\mapRight$,
  and $\mapTwo$ operations obtained by freezing one argument:
  \begin{align*}
    K.\mapLeft(p, b) &= (\lambda x.\, K[x, b])_*(p), \\
    K.\mapRight(a, q) &= K[a, -]_*(q), \\
    K.\mapTwo(p, q) &= K.\mapLeft(p, b_1) \comp K.\mapRight(a_2, q).
  \end{align*}
\end{definition}

\begin{definition}[Dependent Context]\label{def:depcontext}
  A \emph{dependent context} $C : \DepContext(A, B)$ consists of
  $\mathrm{fill} : \prod_{a:A} B(a)$ for a type family $B : A \to \Type$.
  Its action on a path $p : \Path_A(a_1, a_2)$ produces
  \[
    C.\mathrm{map}(p) \;:\;
    \Path_{B(a_2)}(\tr_B(p, C[a_1]),\; C[a_2]),
  \]
  which is the dependent application $\apd(\mathrm{fill}, p)$.
\end{definition}

Dependent contexts admit analogues of left and right substitution
($\substL$ and $\substR$), with additional transport factors to account
for the dependence of the codomain on the base.

\begin{definition}[Dependent Binary Context]\label{def:depbicontext}
  A \emph{dependent binary context} $K : \DepContext(A, B, C)$, where
  $C : A \to B \to \Type$, consists of
  $\mathrm{fill} : \prod_{a:A} \prod_{b:B} C(a, b)$. It supports
  $\mapLeft$, $\mapRight$, and $\mapTwo$ operations that combine
  transport in the base with fiber paths, generalizing the binary
  context operations.
\end{definition}


% ============================================================================
% Remaining sections follow (converted from chapter files)
% ============================================================================

%%%% Converted from chapters/ch3_rewrite_system.tex (book→article) %%%%

% ============================================================================
% Chapter 3: The Rewrite System
% ============================================================================
\section{The Rewrite System}
\label{ch:rewrite-system}

The fundamental algebraic laws of \cref{sec:basic-constructions}---left and
right identity, associativity, involution, anti-homomorphism---hold as strict
equalities because they reduce to list identities. But the \emph{cancellation}
laws ($p \comp \inv{p} = \refl$) and the $\beta/\eta$-rules for type formers
do not hold strictly: they require non-trivial reorganizations of the step
list. We therefore introduce a \emph{rewrite system} on paths that axiomatizes
these additional identities.

\subsection{The Single-Step Rewrite Relation}
\label{sec:step-relation}

\begin{definition}[Single-Step Rewrite]\label{def:step-rewrite}
  The relation $\rew$ on $\Path_A(a,b)$ is the smallest relation closed under
  the 75 rules organized into eight groups below. We write
  $\Step(p, q)$ or $p \rew q$ to denote that $p$ rewrites to $q$ in one step.
\end{definition}

\subsubsection{Group I: Path Algebra (8 rules)}
\label{sec:group-i}

These rules express the groupoid laws that are \emph{not} strict equalities.

\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em]
  \item\label{rule:sr} \textbf{(sr)}
    $\inv{\refl(a)} \rew \refl(a)$.
  \item\label{rule:ss} \textbf{(ss)}
    $\inv{(\inv{p})} \rew p$.
  \item\label{rule:lrr} \textbf{(lrr)}
    $\refl(a) \comp p \rew p$.
  \item\label{rule:rrr} \textbf{(rrr)}
    $p \comp \refl(b) \rew p$.
  \item\label{rule:tr} \textbf{(tr)}
    $p \comp \inv{p} \rew \refl(a)$.
  \item\label{rule:tsr} \textbf{(tsr)}
    $\inv{p} \comp p \rew \refl(b)$.
  \item\label{rule:stss} \textbf{(stss)}
    $\inv{(p \comp q)} \rew \inv{q} \comp \inv{p}$.
  \item\label{rule:tt} \textbf{(tt)}
    $(p \comp q) \comp r \rew p \comp (q \comp r)$.
\end{enumerate}

\begin{remark}\label{rem:strict-vs-step}
  Rules~\ref{rule:lrr}, \ref{rule:rrr}, \ref{rule:ss}, \ref{rule:stss}, and
  \ref{rule:tt} overlap with the strict equalities of
  \cref{thm:strict-monoid,thm:strict-involution,thm:strict-antihom}. Including
  them in the rewrite system is necessary for two reasons: (i)~the
  \emph{structural closure} rules (\cref{sec:group-viii}) may produce these
  patterns nested inside larger contexts; (ii)~the rewrite system must be
  self-contained for the confluence and termination proofs.
\end{remark}

\subsubsection{Group II: Type-Former $\beta$/$\eta$-Rules (17 rules)}
\label{sec:group-ii}

These rules govern the interaction of path operations with type constructors.

\paragraph{Product rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:prod-fst-beta}
    $\fst(\prodMk(p, q)) \rew p$.
  \item\label{rule:prod-snd-beta}
    $\snd(\prodMk(p, q)) \rew q$.
  \item\label{rule:prod-eta}
    $\prodMk(\fst(r), \snd(r)) \rew r$.
  \item\label{rule:prod-mk-symm}
    $\inv{\prodMk(p, q)} \rew \prodMk(\inv{p}, \inv{q})$.
\end{enumerate}

\paragraph{Sigma rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:sigma-fst-beta}
    $\sigmaFst(\sigmaMk(p, q)) \rew \ofEq(\toEq(p))$.
  \item\label{rule:sigma-snd-beta}
    $\sigmaSnd(\sigmaMk(p, q)) \rew \ofEq(\toEq(q))$.
  \item\label{rule:sigma-eta}
    $\sigmaMk(\sigmaFst(r), \sigmaSnd(r)) \rew r$.
\end{enumerate}

\paragraph{Sum rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:sum-inl-beta}
    $(\mathrm{rec}(f,g))_*(\inlOp_*(p)) \rew f_*(p)$.
  \item\label{rule:sum-inr-beta}
    $(\mathrm{rec}(f,g))_*(\inrOp_*(q)) \rew g_*(q)$.
\end{enumerate}

\paragraph{Function rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:fun-app-beta}
    $\app(\lamCongr(p), a) \rew p(a)$.
  \item\label{rule:fun-eta}
    $\lamCongr(\lambda x.\, \app(q, x)) \rew q$.
  \item\label{rule:lam-symm}
    $\inv{\lamCongr(p)} \rew \lamCongr(\lambda x.\, \inv{p(x)})$.
\end{enumerate}

\paragraph{Map congruence rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:prod-map-congr}
    For $f = (g, h) : A \times B \to A' \times B'$,\;
    $f_*(\prodMk(p,q)) \rew \prodMk(g_*(p), h_*(q))$.
\end{enumerate}

Additional rules (22--25) govern the interaction of dependent contexts with
symmetry and the decomposition of dependent application.

\subsubsection{Group III: Transport Rules (5 rules)}
\label{sec:group-iii}

\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, start=26]
  \item\label{rule:transport-refl}
    $\tr_D(\refl(a), x) \rew x$ \quad (identity transport).
  \item\label{rule:transport-trans}
    $\tr_D(p \comp q, x) \rew \tr_D(q, \tr_D(p, x))$ \quad (distributivity).
  \item\label{rule:transport-symm-left}
    $\tr_D(\inv{p}, \tr_D(p, x)) \rew x$.
  \item\label{rule:transport-symm-right}
    $\tr_D(p, \tr_D(\inv{p}, y)) \rew y$.
\end{enumerate}

Rule~30 addresses transport through sigma constructors.

\subsubsection{Group IV: Context Rules (16 rules)}
\label{sec:context-rules}

These rules govern the interaction of context substitution with path operations.
Let $C : \Context(A, B)$.

\paragraph{Unit rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, start=31]
  \item\label{rule:context-congr}
    $\Step(p, q) \implies \Step(C[p], C[q])$ \quad (context congruence).
  \item\label{rule:context-symm}
    $\inv{C[p]} \rew C[\inv{p}]$ \quad (symmetry through context).
  \item\label{rule:slr}
    \textbf{(slr)}\; $\substL(C, \refl, p) \rew C[p]$.
  \item\label{rule:srr}
    \textbf{(srr)}\; $\substR(C, p, \refl) \rew C[p]$.
\end{enumerate}

\paragraph{Idempotence and cancellation.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:slss}
    \textbf{(slss)}\; $\substL(C, \substL(C, r, \refl), p) \rew \substL(C, r, p)$.
  \item\label{rule:srsr}
    \textbf{(srsr)}\; $\substR(C, p, \substR(C, \refl, t)) \rew \substR(C, p, t)$.
  \item\label{rule:srrrr}
    \textbf{(srrrr)}\; $\substR(C, \refl, \substR(C, p, t)) \rew \substR(C, p, t)$.
\end{enumerate}

\paragraph{$\beta$-rules (folding into substitution form).}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:tsbll}
    \textbf{(tsbll)}\; $r \comp C[p] \rew \substL(C, r, p)$.
  \item\label{rule:tsbrl}
    \textbf{(tsbrl)}\; $C[p] \comp t \rew \substR(C, p, t)$.
\end{enumerate}

\paragraph{Associativity.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:tsblr}
    \textbf{(tsblr)}\; $\substL(C, r, p) \comp t \rew r \comp \substR(C, p, t)$.
  \item\label{rule:tsbrr}
    \textbf{(tsbrr)}\; $\substR(C, p, t) \comp u \rew \substR(C, p, t \comp u)$.
\end{enumerate}

\paragraph{Cancellation.}
\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, resume]
  \item\label{rule:ttsv}
    \textbf{(ttsv)}\; $C[p] \comp (C[\inv{p}] \comp v) \rew C[p \comp \inv{p}] \comp v$.
  \item\label{rule:tstu}
    \textbf{(tstu)}\; $(v \comp C[p]) \comp C[\inv{p}] \rew v \comp C[p \comp \inv{p}]$.
\end{enumerate}

\subsubsection{Groups V--VI: Dependent Context and Bi-Context Rules (20 rules)}
\label{sec:groups-v-vi}

Rules 47--58 are the analogues of Group~IV for dependent contexts
$\DepContext(A, B)$, carrying the additional transport data required by the
dependence of the codomain on the base. Rules 59--66 govern the interaction of
binary contexts ($\BiContext$ and dependent binary contexts) with $\mapLeft$,
$\mapRight$, $\mapTwo$, and their structural closure.

\subsubsection{Group VII: Map Congruence Rules (4 rules)}
\label{sec:group-vii}

\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, start=67]
  \item $\mapLeft(f, -, b)$ preserves $\Step$: $p \rew q$ implies
    $\mapLeft(f, p, b) \rew \mapLeft(f, q, b)$.
  \item $\mapRight(f, a, -)$ preserves $\Step$.
  \item $\mapTwo$ distributes: $\mapTwo(f, p, q) \rew
    \mapRight(f, a_1, q) \comp \mapLeft(f, p, b_2)$
    (alternative factorization).
  \item Interaction of $\ofEq$ with map operations.
\end{enumerate}

\subsubsection{Group VIII: Structural Closure (4 rules)}
\label{sec:group-viii}

The structural closure rules propagate single-step rewrites through the
path constructors, ensuring that the rewrite relation is compatible with
all operations:

\begin{enumerate}[label=\textbf{R\arabic*.}, ref=R\arabic*, leftmargin=3.5em, start=71]
  \item\label{rule:symm-congr}
    \textbf{(symm\_congr)}\;
    $p \rew q \implies \inv{p} \rew \inv{q}$.
  \item\label{rule:trans-congr-left}
    \textbf{(trans\_congr\_left)}\;
    $p \rew q \implies p \comp r \rew q \comp r$.
  \item\label{rule:trans-congr-right}
    \textbf{(trans\_congr\_right)}\;
    $q \rew r \implies p \comp q \rew p \comp r$.
  \item\label{rule:context-congr-closure}
    \textbf{(context\_congr)}\;
    $p \rew q \implies C[p] \rew C[q]$.
\end{enumerate}

\begin{remark}
  Rules~\ref{rule:symm-congr}--\ref{rule:context-congr-closure} make $\rew$
  a \emph{congruence closure}: any rewrite deep inside a path expression can
  be lifted to the top level.
\end{remark}

\subsection{Soundness}
\label{sec:soundness}

\begin{theorem}[Soundness of Step]\label{thm:step-sound}
  If $p \rew q$ then $\toEq(p) = \toEq(q)$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Step(p, q)$. Each of the 75 rules
  preserves the proof field because all path operations are designed to be
  sound with respect to the underlying propositional equality. The structural
  closure rules follow by the induction hypothesis.
\end{proof}

Soundness guarantees that rewriting never changes the \emph{meaning} of a path;
it only reorganizes the computational trace.

\subsection{Multi-Step Rewriting}
\label{sec:multi-step}

\begin{definition}[Multi-Step Rewrite]\label{def:rw}
  The relation $\rews$ on $\Path_A(a,b)$ is the reflexive--transitive
  closure of $\rew$. Formally, $\Rw$ is the smallest relation satisfying:
  \begin{enumerate}[label=(\roman*)]
    \item $\Rw.\refl(p) : p \rews p$ for all $p$.
    \item $\Rw.\mathrm{tail}(h, s) : p \rews r$ whenever $h : p \rews q$
      and $s : q \rew r$.
  \end{enumerate}
\end{definition}

\begin{corollary}\label{cor:rw-sound}
  If $p \rews q$ then $\toEq(p) = \toEq(q)$.
\end{corollary}

\subsection{Rewrite Equality}
\label{sec:rweq}

\begin{definition}[Rewrite Equality]\label{def:rweq}
  The \emph{rewrite equality} $\rweq$ is the equivalence relation generated
  by~$\rew$---equivalently, the symmetric closure of $\rews$. It is the
  smallest relation satisfying:
  \begin{enumerate}[label=(\roman*)]
    \item $\RwEq.\refl(p) : p \rweq p$.
    \item $\RwEq.\mathrm{step}(s) : p \rweq q$ whenever $s : p \rew q$.
    \item $\RwEq.\mathrm{symm}(h) : q \rweq p$ whenever $h : p \rweq q$.
    \item $\RwEq.\mathrm{trans}(h_1, h_2) : p \rweq r$ whenever
      $h_1 : p \rweq q$ and $h_2 : q \rweq r$.
  \end{enumerate}
\end{definition}

\begin{theorem}[Congruence Properties of $\RwEq$]\label{thm:rweq-congruence}
  Rewrite equality is a congruence with respect to all path operations:
  \begin{enumerate}[label=(\roman*)]
    \item $p_1 \rweq p_2$ and $q_1 \rweq q_2$ imply
      $p_1 \comp q_1 \rweq p_2 \comp q_2$.
    \item $p \rweq q$ implies $\inv{p} \rweq \inv{q}$.
    \item $p \rweq q$ implies $f_*(p) \rweq f_*(q)$ for any $f$.
    \item $p \rweq q$ implies $C[p] \rweq C[q]$ for any context $C$.
  \end{enumerate}
  Analogous congruence results hold for $\mapLeft$, $\mapRight$, $\mapTwo$,
  $\BiContext.\mapTwo$, $\DepContext.\mathrm{map}$, $\lamCongr$, $\prodMk$,
  and $\sigmaMk$.
\end{theorem}

\begin{proof}
  Each part follows by induction on the $\RwEq$ derivation, using the
  structural closure rules~\ref{rule:symm-congr}--\ref{rule:context-congr-closure}
  in the base case ($\RwEq.\mathrm{step}$).
\end{proof}

The congruence properties ensure that $\RwEq$ is a well-behaved equivalence
relation that respects the algebraic structure of paths.

\begin{theorem}[Groupoid Laws up to $\RwEq$]\label{thm:rweq-groupoid-laws}
  The following hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\refl(a) \comp p \rweq p$ and $p \comp \refl(b) \rweq p$.
    \item $(p \comp q) \comp r \rweq p \comp (q \comp r)$.
    \item $p \comp \inv{p} \rweq \refl(a)$ and $\inv{p} \comp p \rweq \refl(b)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  Each is a single application of $\RwEq.\mathrm{step}$ to the
  corresponding rule from Group~I.
\end{proof}

\subsection{Normalization}
\label{sec:normalization}

\begin{definition}[Normal Form]\label{def:normal-form}
  A path $p : \Path_A(a,b)$ is \emph{normal} if $p = \ofEq(\toEq(p))$. The
  \emph{normalization function} is
  \[
    \normalize(p) \;=\; \ofEq(\toEq(p)) \;:\; \Path_A(a,b).
  \]
\end{definition}

Since $\toEq$ extracts the underlying equality proof and $\ofEq$ wraps it in a
single-step path, normalization discards the trace and replaces it with the
canonical one-step witness.

\begin{theorem}[Properties of Normalization]\label{thm:normalization}
  \begin{enumerate}[label=(\roman*)]
    \item $\normalize(p)$ is always normal.
    \item $p \rweq \normalize(p)$ for every path $p$.
    \item Two paths $p, q : \Path_A(a,b)$ are $\RwEq$-equivalent if and only if
      $\normalize(p) = \normalize(q)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  Part~(i) is immediate from the definition. Part~(ii): by soundness,
  $\toEq(p) = \toEq(\normalize(p))$, and both $p$ and $\normalize(p)$ can be
  connected via the rewrite rules (the groupoid rules and $\beta/\eta$-rules
  suffice to reduce any path to its normal form). Part~(iii): since
  $\normalize(p) = \ofEq(\toEq(p))$ and $\normalize(q) = \ofEq(\toEq(q))$,
  these are equal iff $\toEq(p) = \toEq(q)$, which holds by proof irrelevance
  of $\Eq$. The ``only if'' direction follows from soundness (\cref{thm:step-sound}).
\end{proof}

\begin{corollary}\label{cor:rweq-decidable}
  Rewrite equality of paths is decidable: $p \rweq q$ iff
  $\normalize(p) = \normalize(q)$, which can be checked by structural
  comparison.
\end{corollary}

\begin{remark}[RwEq triviality in the UIP setting]\label{rem:rweq-triviality}
  An important consequence of \cref{thm:normalization}(iii) deserves
  emphasis. Since $\normalize(p) = \ofEq(\toEq(p))$ and the underlying
  equality proofs $\toEq(p)$, $\toEq(q)$ are identified by proof
  irrelevance whenever $p$ and $q$ share the same endpoints, it follows
  that \emph{all} paths $p, q : \Path_A(a,b)$ are $\RwEq$-equivalent. In
  other words, $\RwEq$ is the total relation on each hom-set
  $\Path_A(a,b)$.

  Because $\RwEq$ is $\Prop$-valued, any two witnesses of $p \rweq q$ are
  equal by proof irrelevance. This means the higher coherence data are
  forced: parallel derivations have the same $\RwEq$ projection, so
  contractibility begins at dimension~3 by design (see
  \cref{thm:contract3}). This is a feature, not a bug: it isolates the
  non-trivial structure at the lowest dimensions while keeping higher
  coherences automatic.

  The value of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS therefore lies not in
  the equivalence relation $\RwEq$ itself---which is indeed trivial in the
  UIP setting---but in the \emph{constructive witnesses} it provides:
  explicit, finite rewrite sequences connecting any path to its normal
  form. The path algebra and groupoid operations at dimension~1 are
  non-trivial, and the derivation cells (\cref{sec:omega-groupoid}) record
  \emph{which} rewrite steps are applied. The rich combinatorial content
  of the rewrite system lives in the derivation tower, not in the bare
  equivalence relation.
\end{remark}

\subsection{Termination}
\label{sec:termination}

\begin{theorem}[Termination]\label{thm:termination}
  The rewrite relation $\rews$ is well-founded: there are no infinite
  reduction sequences.
\end{theorem}

The proof uses a \emph{recursive path ordering} (RPO) adapted to the typed
rewriting setting.

\begin{definition}[Rule Precedence]\label{def:rule-precedence}
  The 75 rewrite rules are assigned a numeric rank
  $\mathrm{rank} : \mathrm{Rule} \to \Nat$, forming a well-founded
  precedence relation. The ranking is chosen so that rules introducing
  simpler path expressions (e.g., $\refl$) have lower rank than rules
  producing compound expressions.
\end{definition}

\begin{definition}[RPO Measure]\label{def:rpo}
  Each path $p$ is assigned a \emph{term} $T(p)$ in the RPO, comprising:
  \begin{itemize}
    \item A \emph{symbol} drawn from $\{\mathrm{nf}\} \cup \mathrm{Rule}
      \cup \{\mathrm{pathLen}(n) : n \in \Nat\}$, where $\mathrm{nf}$
      (normal form) is the least element.
    \item An aggregate weight $\mathrm{pathLenSum}(p) \in \Nat$.
  \end{itemize}
  The ordering $T(p) >_{\mathrm{RPO}} T(q)$ holds when the symbol rank
  of~$p$ strictly exceeds that of~$q$ and the aggregate weight does not
  increase.
\end{definition}

\begin{proposition}\label{prop:rpo-wf}
  The RPO ordering is well-founded.
\end{proposition}

\begin{theorem}\label{thm:rpo-decrease}
  Every application of a rewrite rule strictly decreases the RPO measure:
  if $p \rew q$ via rule $R$, then $T(p) >_{\mathrm{RPO}} T(q)$.
\end{theorem}

\begin{proof}
  By case analysis on the 75 rules. Each rule either reduces the symbol
  rank or maintains the rank while strictly decreasing the aggregate weight.
\end{proof}

\subsection{Confluence}
\label{sec:confluence}

\begin{definition}[Join]\label{def:join}
  A \emph{join} of $q$ and $r$ (where $p \rews q$ and $p \rews r$ for some
  common source~$p$) is a path $m$ together with witnesses $q \rews m$ and
  $r \rews m$.
\end{definition}

\begin{theorem}[Strip Lemma (Local Confluence)]\label{thm:strip-lemma}
  If $p \rew q$ and $p \rews r$, then $q$ and $r$ have a common reduct:
  there exists $m$ with $q \rews m$ and $r \rews m$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $p \rews r$. The base case
  ($r = p$) is trivial. For the inductive case, suppose $p \rews r'$
  and $r' \rew r$. By the induction hypothesis applied to $p \rew q$
  and $p \rews r'$, we obtain a join of $q$ and $r'$ at some $m'$.
  We then perform a \emph{critical pair analysis}: for each pair of
  overlapping rules that could apply to~$r'$, we exhibit an explicit
  join. The analysis covers all pairs among the 75 rules.
\end{proof}

The critical pair analysis is the most technically demanding part of the
confluence proof.

\begin{remark}[Scale and tooling]\label{rem:critical-pair-tooling}
  The scale of the 75-rule system raises maintainability questions. We organize
  the rules into eight groups and structure the critical pair analysis by
  group; overlaps are checked within each group and then across groups, so the
  grouping serves as bookkeeping rather than a modular-confluence theorem that
  would allow independent composition of confluence proofs. In the Lean
  formalization, the finite list of critical pairs is made explicit and each
  joinability witness is proved, providing machine-checked verification of all
  rule interactions.
\end{remark}

Representative cases include:

\begin{itemize}
  \item \textbf{Product $\fst$ overlap.}\;
    When $\fst(\prodMk(p, q))$ can be rewritten by both the $\beta$-rule
    (\ref{rule:prod-fst-beta}) and a structural closure rule, the two
    reducts join at~$p$.

  \item \textbf{Associativity--unit overlap.}\;
    When $((p \comp q) \comp r)$ where $r = \refl$ can be rewritten by
    either \ref{rule:tt}~(associativity) or \ref{rule:rrr}~(right unit),
    the join is $p \comp q$.

  \item \textbf{Context substitution overlap.}\;
    When $\substL(C, r, p) \comp t$ overlaps with the $\beta$-rule
    (\ref{rule:tsbll}) and the associativity rule (\ref{rule:tsblr}),
    the two reducts join at $r \comp \substR(C, p, t)$.
\end{itemize}

\begin{theorem}[Confluence]\label{thm:confluence}
  The rewrite system is confluent: for any paths $p, q, r$ with
  $p \rews q$ and $p \rews r$, there exists $m$ with $q \rews m$
  and $r \rews m$.
\end{theorem}

\begin{proof}
  By Newman's lemma~\cite{Newman42}: a terminating relation is confluent
  if and only if it is locally confluent. Termination is established in
  \cref{thm:termination}, and local confluence follows from the strip
  lemma (\cref{thm:strip-lemma}).
\end{proof}

\begin{corollary}[Unique Normal Forms]\label{cor:unique-nf}
  Every path has a unique normal form (up to structural equality), and
  two paths are $\RwEq$-equivalent if and only if they reduce to the
  same normal form.
\end{corollary}

\begin{proof}
  Existence of normal forms follows from termination. Uniqueness follows
  from confluence: if $p \rews m_1$ and $p \rews m_2$ with $m_1, m_2$
  normal, then by confluence there exists $m$ with $m_1 \rews m$ and
  $m_2 \rews m$; since $m_1$ and $m_2$ are normal, $m_1 = m = m_2$.
\end{proof}

\subsection{Extension Patterns}
\label{sec:extension-patterns}

The rewrite system is designed to be extensible: new type formers or new
computation rules can be added without disrupting termination and confluence,
provided the extension follows the same modular discipline.

\paragraph{Modular rule groups.}
The eight groups isolate distinct sources of rewriting:
\begin{enumerate}[label=(\roman*)]
  \item Group~I: path algebra (unit, associativity, inverse, cancellation).
  \item Group~II: type-former $\beta/\eta$ rules (products, sums, sigma, functions).
  \item Group~III: transport rules.
  \item Group~IV: context rules (substitution in unary contexts).
  \item Group~V: dependent context rules.
  \item Group~VI: bi-context and dependent bi-context rules.
  \item Group~VII: map congruence rules ($\mapLeft$, $\mapRight$, $\mapTwo$).
  \item Group~VIII: structural closure (propagating rewrites through constructors).
\end{enumerate}
New type formers typically extend Group~II with their $\beta/\eta$ rules, and
may require corresponding congruence or context rules in Groups~IV--VII; the
structural closure rules of Group~VIII remain unchanged.

\paragraph{Critical pair analysis for new rules.}
To preserve local confluence, each new rule must be checked for overlaps with
the existing system:
\begin{enumerate}[label=(\roman*)]
  \item Enumerate the new redex patterns (left-hand sides), including their
    appearance under $\symm$, $\trans$, and contexts (by Group~VIII).
  \item Check overlaps against Group~I (algebraic laws) and existing Group~II
    $\beta/\eta$ rules, as these are the most common sources of ambiguity.
  \item For every overlap, exhibit a concrete join term and reduction witnesses.
    These joins are added as new strip-lemma cases, extending the critical-pair
    analysis used in \cref{thm:strip-lemma}.
\end{enumerate}

\paragraph{Extending the recursive path ordering.}
Termination is preserved by extending the rule precedence and RPO measure:
\begin{enumerate}[label=(\roman*)]
  \item Add new rule symbols to $\mathrm{rank} : \mathrm{Rule} \to \Nat$,
    assigning strictly higher ranks to redex-producing rules than to the
    simpler normal-form constructors they reduce to.
  \item Extend the aggregate weight $\mathrm{pathLenSum}$ so that each new
    constructor contributes positively; then orient each new rule so that the
    RHS either lowers the rank or strictly decreases the weight at equal rank.
  \item Re-run the RPO decrease proof (\cref{thm:rpo-decrease}) for the new rules.
\end{enumerate}

\paragraph{Practical workflow.}
A typical extension follows this checklist:
\begin{enumerate}[label=(\roman*)]
  \item Add the new rule constructors in $\Step$ and update the rule tables and
    appendix listings.
  \item Add any missing congruence/context rules needed to propagate the new
    constructors through $\symm$, $\trans$, and contexts.
  \item Extend the precedence ranking and the RPO decrease proof.
  \item Extend the critical-pair analysis with joins for all new overlaps, and
    update the strip-lemma cases accordingly.
  \item Register the new rules with the simplification/tactic infrastructure so
    that $\RwEq$ automation reflects the extension.
\end{enumerate}

\subsection{The Quotient $\PathQuot$}
\label{sec:path-quot}

\begin{definition}[Path Quotient]\label{def:path-quot}
  The \emph{path quotient} is the quotient type
  \[
    \PathQuot_A(a, b) \;=\; \Path_A(a, b) \,/\, {\rweq}.
  \]
  We write $[p]$ for the equivalence class of a path $p$.
\end{definition}

Since $\RwEq$ is a congruence (\cref{thm:rweq-congruence}), all path
operations descend to well-defined operations on the quotient:

\begin{theorem}[Well-Defined Quotient Operations]\label{thm:quot-ops}
  The following operations are well-defined on $\PathQuot$:
  \begin{align*}
    \mathrm{trans} &: \PathQuot_A(a, b) \to \PathQuot_A(b, c) \to \PathQuot_A(a, c), \\
    \mathrm{symm} &: \PathQuot_A(a, b) \to \PathQuot_A(b, a), \\
    f_* &: \PathQuot_A(a, b) \to \PathQuot_B(f(a), f(b)).
  \end{align*}
\end{theorem}

\begin{theorem}[Strict Groupoid Laws on the Quotient]\label{thm:quot-groupoid}
  On $\PathQuot$, all groupoid axioms hold as \textbf{strict equalities}
  (equalities of quotient elements):
  \begin{enumerate}[label=(\roman*)]
    \item $[\refl(a)] \comp [q] = [q]$ \quad and \quad $[p] \comp [\refl(b)] = [p]$.
    \item $([p] \comp [q]) \comp [r] = [p] \comp ([q] \comp [r])$.
    \item $[p] \comp [\inv{p}] = [\refl(a)]$ \quad and \quad
      $[\inv{p}] \comp [p] = [\refl(b)]$.
    \item $[\inv{(\inv{p})}] = [p]$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  Each identity holds because the corresponding rewrite rule from Group~I
  provides a witness of $\RwEq$, which becomes an equality after quotienting.
\end{proof}

\begin{theorem}[Equivalence with the Identity Type]\label{thm:quot-equiv}
  The semantic projection $\toEq$ descends to a bijection
  \[
    \PathQuot_A(a, b) \;\cong\; (a =_A b).
  \]
\end{theorem}

\begin{proof}
  By \cref{thm:normalization}(iii), two paths are $\RwEq$-equivalent
  iff they have the same underlying equality proof (which is unique by
  UIP). Hence each equivalence class corresponds to exactly one element
  of the identity type.
\end{proof}

\subsection{Well-Formed Traces and Canonicalization}
\label{sec:well-formed-traces}

\begin{definition}[Well-Formed Trace]\label{def:wf-trace}
  A trace $s : \List(\Step(A))$ is \emph{well-formed} from $a$ to $b$,
  written $\mathrm{WFTrace}_A(a, b, s)$, if it is generated by:
  \begin{enumerate}[label=(\roman*)]
    \item $\mathrm{WFTrace}_A(a, a, [\,])$.
    \item If $s = \langle a, c, \pi \rangle :: s'$ and
      $\mathrm{WFTrace}_A(c, b, s')$, then $\mathrm{WFTrace}_A(a, b, s)$.
  \end{enumerate}
  In this case there is a canonical composite proof
  $\mathrm{comp}(s) : a =_A b$, obtained by chaining the step proofs in
  order. A computational path $p = (s, \pi)$ is \emph{well-formed} when
  $\mathrm{WFTrace}_A(a, b, s)$ and $\pi = \mathrm{comp}(s)$.
\end{definition}

\begin{theorem}[Canonical Trace]\label{thm:canonical-trace}
  Every path $p : \Path_A(a, b)$ is rewrite-equivalent to one with a
  well-formed trace. In particular, $p \rweq \normalize(p)$, and
  $\normalize(p) = \ofEq(\toEq(p))$ has a single-step well-formed trace.
\end{theorem}

\begin{proof}
  By \cref{thm:normalization}(ii), $p \rweq \normalize(p)$. The path
  $\normalize(p)$ has trace $[\langle a, b, \toEq(p) \rangle]$, which is
  well-formed by \cref{def:wf-trace}(ii) with a trivial tail.
\end{proof}

\paragraph{Semantics.}
The semantic projection depends only on rewrite-equivalence classes:
if $p \rweq q$ then $\toEq(p) = \toEq(q)$ by soundness
(\cref{thm:step-sound}). Hence the meaning of a computational path is
determined by its $\RwEq$-class, not by the raw trace; well-formed traces
serve as canonical representatives.


%%%% Converted from chapters/ch4_groupoid.tex (book→article) %%%%

% ============================================================================
% Chapter 4: The Groupoid of Computational Paths
% ============================================================================
\section{The Groupoid of Computational Paths}
\label{ch:groupoid}

Having established the rewrite system and its metatheoretic properties, we
now show that the algebraic structure of computational paths gives rise to
categorical structures: a \emph{weak} groupoid on the raw path space, a
\emph{strict} groupoid on the quotient, and functorial transport of the
entire rewrite structure.

\subsection{Weak Category and Weak Groupoid}
\label{sec:weak-groupoid}

\begin{definition}[Weak Category]\label{def:weak-cat}
  A \emph{weak category} on a type $A$ consists of:
  \begin{itemize}
    \item A composition $\mathrm{comp} : \Path_A(a,b) \to \Path_A(b,c) \to
      \Path_A(a,c)$.
    \item An identity $\mathrm{id} : (a : A) \to \Path_A(a,a)$.
    \item Witnesses (in $\Rw$) of the associativity and unit laws:
      \begin{align*}
        &\mathrm{comp}(\mathrm{comp}(p, q), r) \rews
          \mathrm{comp}(p, \mathrm{comp}(q, r)), \\
        &\mathrm{comp}(\mathrm{id}(a), p) \rews p, \\
        &\mathrm{comp}(p, \mathrm{id}(b)) \rews p.
      \end{align*}
  \end{itemize}
\end{definition}

\begin{theorem}\label{thm:type-weak-cat}
  Every type $A$ carries a canonical weak category with
  $\mathrm{comp} = \mathrm{trans}$ and $\mathrm{id} = \refl$. The unit
  and associativity laws hold via single rewrite steps (hence a fortiori
  via $\Rw$).
\end{theorem}

\begin{proof}
  The three witnesses are provided by rules~\ref{rule:lrr} (left unit),
  \ref{rule:rrr} (right unit), and \ref{rule:tt} (associativity) from
  Group~I of the rewrite system.
\end{proof}

\begin{definition}[Weak Groupoid]\label{def:weak-gpd}
  A \emph{weak groupoid} on $A$ extends a weak category with:
  \begin{itemize}
    \item An inversion $\mathrm{inv} : \Path_A(a,b) \to \Path_A(b,a)$.
    \item Witnesses of the cancellation laws:
      \begin{align*}
        &\mathrm{comp}(\mathrm{inv}(p), p) \rews \mathrm{id}(b), \\
        &\mathrm{comp}(p, \mathrm{inv}(p)) \rews \mathrm{id}(a).
      \end{align*}
  \end{itemize}
\end{definition}

\begin{theorem}\label{thm:type-weak-gpd}
  Every type $A$ is a weak groupoid under computational paths, with
  $\mathrm{inv} = \symop$.
\end{theorem}

\begin{proof}
  The cancellation laws are provided by rules~\ref{rule:tsr}
  ($\inv{p} \comp p \rew \refl(b)$) and~\ref{rule:tr}
  ($p \comp \inv{p} \rew \refl(a)$).
\end{proof}

\begin{remark}\label{rem:weakness}
  The word ``weak'' is used precisely: the groupoid laws hold only up to
  the rewrite relation $\Rw$, not as strict equalities of $\Path$ records.
  The strict equalities of \cref{thm:strict-monoid} (unit and associativity)
  provide even stronger witnesses, but the cancellation laws genuinely
  require the rewrite system.
\end{remark}

\subsection{Strict Category and Strict Groupoid on the Quotient}
\label{sec:strict-groupoid}

\begin{definition}[Strict Category]\label{def:strict-cat}
  A \emph{strict category} on $A$ is a category in the usual sense: the
  associativity and unit laws hold as equalities (not merely up to~$\Rw$).
\end{definition}

\begin{definition}[Strict Groupoid]\label{def:strict-gpd}
  A \emph{strict groupoid} on $A$ extends a strict category with an
  inversion satisfying the cancellation laws as equalities.
\end{definition}

\begin{theorem}\label{thm:quot-strict-gpd}
  The quotient $\PathQuot_A(-,-)$ carries the structure of a strict groupoid.
\end{theorem}

\begin{proof}
  By \cref{thm:quot-groupoid}, all groupoid axioms hold as equalities of
  quotient elements. The operations $\mathrm{trans}$, $\symop$, and $\refl$
  descend to well-defined operations on $\PathQuot$ by the congruence
  property of $\RwEq$ (\cref{thm:rweq-congruence}).
\end{proof}

This result establishes a clean separation between two levels of structure:

\begin{center}
\begin{tabular}{lll}
  \toprule
  \textbf{Level} & \textbf{Object} & \textbf{Laws} \\
  \midrule
  Raw paths & $\Path_A(a,b)$ & Weak groupoid (laws up to $\Rw$) \\
  Quotient  & $\PathQuot_A(a,b)$ & Strict groupoid (laws as equalities) \\
  \bottomrule
\end{tabular}
\end{center}

The quotient recovers the standard identity type (\cref{thm:quot-equiv}),
while the raw path space carries the additional combinatorial structure
needed for higher-dimensional algebra.

\subsection{Equality Functors}
\label{sec:eq-functor}

\begin{definition}[Equality Functor]\label{def:eq-functor}
  An \emph{equality functor} from $A$ to $B$ consists of:
  \begin{itemize}
    \item An object map $\mathrm{obj} : A \to B$.
    \item A path map $\mathrm{map} : \Path_A(a,b) \to \Path_B(\mathrm{obj}(a),
      \mathrm{obj}(b))$.
    \item Functoriality witnesses:
      \begin{align*}
        \mathrm{map}(\refl(a)) &= \refl(\mathrm{obj}(a)), \\
        \mathrm{map}(p \comp q) &= \mathrm{map}(p) \comp \mathrm{map}(q).
      \end{align*}
  \end{itemize}
\end{definition}

\begin{proposition}\label{prop:congrArg-functor}
  For any function $f : A \to B$, the pair $(\mathrm{obj} = f,\;
  \mathrm{map} = f_*)$ is an equality functor. The functoriality
  witnesses hold as strict equalities by \cref{thm:congrArg-functor}.
\end{proposition}

\subsection{Rewrite Lifts}
\label{sec:rewrite-lifts}

A \emph{rewrite lift} transports not only paths but also the rewrite
structure from one type to another.

\begin{definition}[Rewrite Lift]\label{def:rewrite-lift}
  A \emph{rewrite lift} from $A$ to $B$ consists of:
  \begin{itemize}
    \item An object map $\mathrm{obj} : A \to B$.
    \item A path map $\mathrm{mapPath} : \Path_A(a,b) \to
      \Path_B(\mathrm{obj}(a), \mathrm{obj}(b))$.
    \item A step map: $\Step(p, q) \implies \Step(\mathrm{mapPath}(p),
      \mathrm{mapPath}(q))$.
  \end{itemize}
\end{definition}

\begin{theorem}\label{thm:lift-rw-rweq}
  Any rewrite lift transports both $\Rw$ and $\RwEq$:
  \begin{enumerate}[label=(\roman*)]
    \item $p \rews q$ implies $\mathrm{mapPath}(p) \rews \mathrm{mapPath}(q)$.
    \item $p \rweq q$ implies $\mathrm{mapPath}(p) \rweq \mathrm{mapPath}(q)$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  Part~(i) by induction on the $\Rw$ derivation, using the step map at
  each tail step. Part~(ii) by induction on the $\RwEq$ derivation, using
  (i) for the step case and the closure properties of $\RwEq$.
\end{proof}

\begin{proposition}\label{prop:canonical-lifts}
  Each of the following produces a canonical rewrite lift:
  \begin{enumerate}[label=(\roman*)]
    \item Any function $f : A \to B$ (via $\congrArgOp(f, -)$).
    \item Any context $C : \Context(A, B)$ (via $C[-]$).
    \item Any binary context $K : \BiContext(A, B, C)$ with a fixed
      argument (via $K.\mapLeft(-, b)$ or $K.\mapRight(a, -)$).
    \item Any dependent context $C : \DepContext(A, B)$ (via $C.\mathrm{map}$).
  \end{enumerate}
\end{proposition}

\begin{proof}
  In each case, the step map is provided by the corresponding structural
  closure rule (\ref{rule:context-congr-closure}) from Group~VIII.
\end{proof}

Rewrite lifts compose: if $L_1 : A \to B$ and $L_2 : B \to C$ are rewrite
lifts, their composition $L_2 \circ L_1$ is a rewrite lift from $A$ to $C$.
This makes the collection of types with rewrite lifts into a category,
which refines the category of types with equality functors.


%%%% Converted from chapters/ch5_higher_dimensional.tex (book→article) %%%%

% ============================================================================
% Chapter 5: Higher-Dimensional Structure
% ============================================================================
\section{Higher-Dimensional Structure}
\label{ch:higher-dimensional}

We now ascend from the one-dimensional algebra of paths to the
higher-dimensional structure that constitutes the central contribution of this
work. Rewrite equalities between paths serve as \emph{two-cells}, and iterated
derivation structures provide cells at every dimension. The resulting tower
forms a weak $\omega$-groupoid, with a sharp contractibility threshold at
dimension~3.

\subsection{Two-Cells and the Bicategory of Paths}
\label{sec:two-cells}

\begin{definition}[Two-Cell]\label{def:two-cell}
  A \emph{two-cell} between paths $p, q : \Path_A(a,b)$ is a witness of
  rewrite equality:
  \[
    \eta : p \rweq q.
  \]
  Two-cells inhabit $\Prop$ (they are proof-irrelevant), since $\RwEq$ is a
  proposition.
\end{definition}

\begin{definition}[Two-Cell Operations]\label{def:two-cell-ops}
  Two-cells support the following operations:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Identity.}\; $\mathrm{id}_p : p \rweq p$ \quad
      (via $\RwEq.\refl$).
    \item \textbf{Vertical composition.}\;
      $\eta \circ_v \theta : p \rweq r$ \quad for $\eta : p \rweq q$ and
      $\theta : q \rweq r$ \quad (via $\RwEq.\mathrm{trans}$).
    \item \textbf{Left whiskering.}\;
      $f \triangleright_L \eta : f \comp g \rweq f \comp h$ \\
      for $f : \Path_A(a,b)$ and $\eta : g \rweq h$ where
      $g, h : \Path_A(b,c)$ \\
      (via the congruence of $\mathrm{trans}$ in its second argument).
    \item \textbf{Right whiskering.}\;
      $\eta \triangleleft_R h : f \comp h \rweq g \comp h$ \\
      for $\eta : f \rweq g$ and $h : \Path_A(b,c)$ \\
      (via the congruence of $\mathrm{trans}$ in its first argument).
    \item \textbf{Horizontal composition.}\;
      $\eta \circ_h \theta : f \comp g \rweq f' \comp g'$ \\
      for $\eta : f \rweq f'$ and $\theta : g \rweq g'$ \\
      (defined as $(\eta \triangleleft_R g) \circ_v (f' \triangleright_L \theta)$).
  \end{enumerate}
\end{definition}

\subsubsection{Associator and Unitor Two-Cells}

The rewrite rules from Group~I provide canonical two-cells witnessing the
coherence data of a bicategory:

\begin{definition}[Associator]\label{def:associator}
  For composable paths $p : \Path_A(a,b)$, $q : \Path_A(b,c)$,
  $r : \Path_A(c,d)$, the \emph{associator} is the two-cell
  \[
    \alpha_{p,q,r} : (p \comp q) \comp r \;\rweq\; p \comp (q \comp r),
  \]
  given by $\RwEq.\mathrm{step}$ applied to rule~\ref{rule:tt}.
\end{definition}

\begin{definition}[Unitors]\label{def:unitors}
  The \emph{left} and \emph{right unitors} are:
  \begin{align*}
    \lambda_p &: \refl(a) \comp p \;\rweq\; p &
    &\text{(via rule~\ref{rule:lrr})}, \\
    \rho_p &: p \comp \refl(b) \;\rweq\; p &
    &\text{(via rule~\ref{rule:rrr})}.
  \end{align*}
\end{definition}

\subsubsection{Coherence Laws}

\begin{theorem}[Pentagon Coherence]\label{thm:pentagon}
  For composable paths $p, q, r, s$, the two canonical ways of
  reassociating the four-fold composite agree:
  \[
    \alpha_{p \comp q, r, s} \circ_v \alpha_{p, q, r \comp s}
    \;=\;
    (\alpha_{p,q,r} \triangleleft_R s) \circ_v
    \alpha_{p, q \comp r, s} \circ_v
    (p \triangleright_L \alpha_{q,r,s}).
  \]
  This equality of two-cells holds by proof irrelevance of $\RwEq$.
\end{theorem}

\begin{theorem}[Triangle Coherence]\label{thm:triangle}
  For composable paths $p : \Path_A(a,b)$ and $q : \Path_A(b,c)$:
  \[
    \alpha_{p, \refl(b), q} \circ_v (p \triangleright_L \lambda_q)
    \;=\;
    \rho_p \triangleleft_R q.
  \]
  Again, this holds by proof irrelevance.
\end{theorem}

\begin{theorem}[Interchange Law]\label{thm:interchange}
  For four two-cells $\eta_1, \eta_2, \theta_1, \theta_2$ arranged in a
  $2 \times 2$ grid:
  \[
    (\eta_1 \circ_h \theta_1) \circ_v (\eta_2 \circ_h \theta_2)
    \;=\;
    (\eta_1 \circ_v \eta_2) \circ_h (\theta_1 \circ_v \theta_2).
  \]
  This is the \emph{middle-four interchange}. It holds because both
  sides inhabit the same $\Prop$-valued type.
\end{theorem}

\begin{remark}\label{rem:proof-irrel-coherence}
  The pentagon, triangle, and interchange laws hold trivially (by
  proof irrelevance for propositions) because two-cells are $\Prop$-valued.
  This is a feature, not a deficiency: it means that all coherence
  conditions at the two-cell level and above are \emph{automatically}
  satisfied. The non-trivial content of the theory lies at the
  one-cell level, where distinct paths encode genuinely different
  computational traces.
\end{remark}

\subsubsection{The Weak Bicategory and Weak 2-Groupoid}

\begin{definition}[Weak Bicategory]\label{def:weak-bicat}
  A \emph{weak bicategory} consists of:
  \begin{itemize}
    \item 0-cells (objects), 1-cells (morphisms), 2-cells.
    \item Composition and identity at the 1-cell level.
    \item Vertical and horizontal composition, whiskering, identity at
      the 2-cell level.
    \item Associator and unitors as invertible 2-cells.
    \item Pentagon and triangle coherences.
  \end{itemize}
\end{definition}

\begin{theorem}\label{thm:weak-bicat}
  Computational paths form a weak bicategory, with:
  \begin{center}
  \begin{tabular}{ll}
    0-cells: & elements of $A$, \\
    1-cells: & paths $p : \Path_A(a,b)$, \\
    2-cells: & rewrite equalities $\eta : p \rweq q$.
  \end{tabular}
  \end{center}
\end{theorem}

\begin{definition}[Weak 2-Groupoid]\label{def:weak-2-gpd}
  A \emph{weak 2-groupoid} extends a weak bicategory with:
  \begin{itemize}
    \item An inversion $\mathrm{inv}_1$ on 1-cells, with cancellation
      two-cells: $p \comp \inv{p} \rweq \refl(a)$ and $\inv{p} \comp p \rweq \refl(b)$.
    \item An inversion on 2-cells: $\eta : p \rweq q$ implies $\inv{\eta} : q \rweq p$.
  \end{itemize}
\end{definition}

\begin{theorem}\label{thm:weak-2-gpd}
  Computational paths form a weak 2-groupoid, with $\mathrm{inv}_1 = \symop$
  and inversion on 2-cells given by $\RwEq.\mathrm{symm}$.
\end{theorem}

\subsection{The Globular Tower}
\label{sec:globular-tower}

\begin{definition}[Globular Cell]\label{def:globular-cell}
  A \emph{globular cell} over a type $\beta$ is a triple
  \[
    c = (\mathrm{src}, \mathrm{tgt}, \mathrm{path})
    \quad\text{where}\quad
    \mathrm{src}, \mathrm{tgt} : \beta \quad\text{and}\quad
    \mathrm{path} : \Path_\beta(\mathrm{src}, \mathrm{tgt}).
  \]
  Globular cells carry reflexivity, symmetry, and composition operations
  inherited from $\Path$, satisfying the analogous algebraic laws.
\end{definition}

\begin{definition}[Globular Tower]\label{def:globular-tower}
  The \emph{globular tower} over a type $A$ is defined inductively:
  \begin{align*}
    \mathrm{Level}_0(A) &\;=\; A, \\
    \mathrm{Level}_{n+1}(A) &\;=\; \mathrm{GlobularCell}(\mathrm{Level}_n(A)).
  \end{align*}
  Each level carries $\refl$, $\symop$, and $\mathrm{trans}$ operations,
  as well as a functorial $\mathrm{map}$ operation that sends a function
  $f : A \to B$ to level-wise maps $\mathrm{Level}_n(f) :
  \mathrm{Level}_n(A) \to \mathrm{Level}_n(B)$.
\end{definition}

\begin{proposition}\label{prop:globular-tower-functorial}
  The $\mathrm{map}$ operation on globular levels satisfies:
  \begin{enumerate}[label=(\roman*)]
    \item $\mathrm{map}(\refl(x)) = \refl(\mathrm{map}(x))$.
    \item $\mathrm{map}(\symop(c)) = \symop(\mathrm{map}(c))$.
    \item $\mathrm{map}(\mathrm{trans}(p, q, h)) =
      \mathrm{trans}(\mathrm{map}(p), \mathrm{map}(q), f_*(h))$.
  \end{enumerate}
\end{proposition}

The globular tower provides the \emph{geometric} scaffolding for the
$\omega$-groupoid, but it does not encode the rewrite structure. For that,
we need the derivation cells.

\subsection{Derivation Cells and the Weak $\omega$-Groupoid}
\label{sec:omega-groupoid}

\subsubsection{Dimension 2: Derivations Between Paths}

\begin{definition}[Derivation$_2$]\label{def:derivation2}
  A \emph{derivation} (or \emph{type-valued two-cell}) between paths
  $p, q : \Path_A(a,b)$ is an element of the inductive type
  $\Derivation_2(p, q)$ with constructors:
  \begin{enumerate}[label=(\roman*)]
    \item $\Derivation_2.\refl(p) : \Derivation_2(p, p)$.
    \item $\Derivation_2.\mathrm{step}(s) : \Derivation_2(p, q)$ for
      $s : p \rew q$.
    \item $\Derivation_2.\mathrm{inv}(\delta) : \Derivation_2(q, p)$ for
      $\delta : \Derivation_2(p, q)$.
    \item $\Derivation_2.\mathrm{vcomp}(\delta_1, \delta_2) :
      \Derivation_2(p, r)$ for $\delta_1 : \Derivation_2(p, q)$ and
      $\delta_2 : \Derivation_2(q, r)$.
  \end{enumerate}
\end{definition}

Unlike $\RwEq$ (which is $\Prop$-valued), $\Derivation_2$ is
\emph{type-valued}: it carries explicit derivation structure, recording
which steps and closure operations were applied.

\begin{proposition}\label{prop:d2-projects}
  Every $\Derivation_2(p,q)$ projects to an $\RwEq(p,q)$ witness via a
  forgetful map $\Derivation_2(p,q) \to \RwEq(p,q)$. Moreover,
  $\Derivation_2(p,q)$ is inhabited if and only if $p \rweq q$.
\end{proposition}

$\Derivation_2$ supports horizontal operations:

\begin{definition}[Horizontal Operations on $\Derivation_2$]\label{def:d2-horizontal}
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Left whiskering.}\;
      $f \triangleright_L \delta : \Derivation_2(f \comp g, f \comp h)$
      for $\delta : \Derivation_2(g, h)$.
    \item \textbf{Right whiskering.}\;
      $\delta \triangleleft_R h : \Derivation_2(f \comp h, g \comp h)$
      for $\delta : \Derivation_2(f, g)$.
    \item \textbf{Horizontal composition.}\;
      $\delta_1 \circ_h \delta_2 : \Derivation_2(p \comp q, p' \comp q')$
      for $\delta_1 : \Derivation_2(p, p')$ and $\delta_2 : \Derivation_2(q, q')$.
  \end{enumerate}
\end{definition}

\subsubsection{Dimension 3: Meta-Steps and Derivations Between Derivations}

\begin{definition}[MetaStep$_3$]\label{def:metastep3}
  A \emph{primitive three-cell} $\mathrm{MetaStep}_3(\delta_1, \delta_2)$
  between derivations $\delta_1, \delta_2 : \Derivation_2(p, q)$ witnesses
  that $\delta_1$ and $\delta_2$ are ``equivalent as derivations.'' The
  constructors include:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Groupoid laws for derivations:}
      \begin{align*}
        &\mathrm{vcomp}(\refl(p), \delta) \;\mapsto\; \delta, \\
        &\mathrm{vcomp}(\delta, \refl(q)) \;\mapsto\; \delta, \\
        &\mathrm{vcomp}(\mathrm{vcomp}(\delta_1, \delta_2), \delta_3)
          \;\mapsto\; \mathrm{vcomp}(\delta_1,
          \mathrm{vcomp}(\delta_2, \delta_3)), \\
        &\mathrm{inv}(\mathrm{inv}(\delta)) \;\mapsto\; \delta, \\
        &\mathrm{vcomp}(\mathrm{inv}(\delta), \delta) \;\mapsto\; \refl(q), \\
        &\mathrm{vcomp}(\delta, \mathrm{inv}(\delta)) \;\mapsto\; \refl(p), \\
        &\mathrm{inv}(\mathrm{vcomp}(\delta_1, \delta_2)) \;\mapsto\;
          \mathrm{vcomp}(\mathrm{inv}(\delta_2), \mathrm{inv}(\delta_1)).
      \end{align*}
    \item \textbf{Step coherence:} any two single-step derivations
      $\mathrm{step}(s_1)$ and $\mathrm{step}(s_2)$ for the same
      $p \rew q$ are connected.
    \item \textbf{$\RwEq$-coherence:} any two derivations projecting to
      the same $\RwEq$ witness are connected:
      $\delta_1.\mathrm{toRwEq} = \delta_2.\mathrm{toRwEq} \implies
      \mathrm{MetaStep}_3(\delta_1, \delta_2)$.
    \item \textbf{Bicategorical coherences:} pentagon and triangle for
      derivation-level associators.
    \item \textbf{Whiskering:} whiskering preserves meta-steps.
  \end{enumerate}
\end{definition}

\begin{definition}[Derivation$_3$]\label{def:derivation3}
  $\Derivation_3(\delta_1, \delta_2)$ is the free groupoid generated by
  $\mathrm{MetaStep}_3$: it has constructors $\refl$, $\mathrm{step}$
  (from $\mathrm{MetaStep}_3$), $\mathrm{inv}$, and $\mathrm{vcomp}$.
\end{definition}

\subsubsection{The Contractibility Theorem}

\begin{theorem}[Contractibility at Dimension $\geq 3$]\label{thm:contract3}
  For any two parallel derivations $\delta_1, \delta_2 : \Derivation_2(p,q)$,
  there exists a three-cell connecting them:
  \[
    \mathrm{contract}_3(\delta_1, \delta_2) \;:\; \Derivation_3(\delta_1, \delta_2).
  \]
\end{theorem}

\begin{proof}
  Since $\RwEq$ is $\Prop$-valued, the projections
  $\delta_1.\mathrm{toRwEq}$ and $\delta_2.\mathrm{toRwEq}$ are equal
  by proof irrelevance. The $\RwEq$-coherence constructor of
  $\mathrm{MetaStep}_3$ then produces a primitive three-cell, which lifts
  to $\Derivation_3$ via the $\mathrm{step}$ constructor.
\end{proof}

\begin{corollary}[Loop Contraction]\label{cor:loop-contract}
  Every loop derivation $\delta : \Derivation_2(p, p)$ contracts to the
  identity:
  \[
    \Derivation_3(\delta,\; \Derivation_2.\refl(p)).
  \]
\end{corollary}

\begin{remark}[Critical Design Choice]\label{rem:contract-threshold}
  Contractibility starts at dimension~3, \textbf{not} at dimension~2. At
  dimension~2, $\Derivation_2(p,q)$ is inhabited only when $p \rweq q$;
  it does not connect arbitrary parallel paths. This is essential for
  capturing non-trivial fundamental groups. For example, on the circle
  $S^1$, the loop generator and $\refl$ are \emph{not} connected by a
  two-cell, which is what allows $\pi_1(S^1) \cong \ZZ$.
\end{remark}

\begin{remark}[Higher structure vs.\ HoTT]\label{rem:hott-contrast}
  In HoTT, higher cells arise as iterated identity types and can carry
  intrinsic higher homotopy, whereas here they are \emph{syntactic}:
  two-cells are proofs of $\RwEq$ (hence $\Prop$-valued), and higher
  $\Derivation_k$ are generated by the rewrite system and the path-expression
  constructors. The choice that two-cells are proof-irrelevant and that
  contractibility begins at dimension~3 is deliberate: it preserves
  non-trivial $\pi_1$ while collapsing higher coherence to rewrite-derived
  homotopies. The tradeoff is that we avoid univalence and HIT axioms and gain
  explicit, computable traces, but we do not model the full hierarchy of
  higher homotopy types available in HoTT.
\end{remark}

\subsubsection{Dimensions 4 and Beyond}

The pattern continues uniformly:

\begin{definition}[Higher Derivation Cells]\label{def:higher-cells}
  \begin{enumerate}[label=(\roman*)]
    \item $\mathrm{MetaStep}_4$ and $\Derivation_4(\mu_1, \mu_2)$
      for $\mu_1, \mu_2 : \Derivation_3(\delta_1, \delta_2)$, with
      analogous groupoid laws, step coherence, and whiskering.
    \item For $n \geq 5$, $\mathrm{DerivationHigh}_n(c_1, c_2)$
      for $c_1, c_2 : \Derivation_4(\mu_1, \mu_2)$, parametrized by
      dimension.
  \end{enumerate}
\end{definition}

\begin{theorem}[Contractibility at Dimension $\geq 4$]\label{thm:contract4}
  For any two parallel three-cells $\mu_1, \mu_2 : \Derivation_3(\delta_1,
  \delta_2)$:
  \[
    \mathrm{contract}_4(\mu_1, \mu_2) \;:\; \Derivation_4(\mu_1, \mu_2).
  \]
  More generally, for all $k \geq 3$, any two parallel $(k-1)$-cells are
  connected by a $k$-cell.
\end{theorem}

\begin{proof}
  The same argument as \cref{thm:contract3}: the projection of each
  higher cell to its $\Prop$-valued counterpart is unique by proof
  irrelevance, and the coherence constructor lifts this to an explicit
  higher cell.
\end{proof}

\subsubsection{The Cell Types}

\begin{definition}[Cell Type at Each Dimension]\label{def:cell-types}
  \[
    \mathrm{Cell}_k(A) \;=\;
    \begin{cases}
      A & k = 0, \\
      \Sigma_{a,b : A}\; \Path_A(a,b) & k = 1, \\
      \Sigma_{a,b,p,q}\; \Derivation_2(p,q) & k = 2, \\
      \Sigma_{\ldots}\; \Derivation_3(\delta_1, \delta_2) & k = 3, \\
      \Sigma_{\ldots}\; \Derivation_4(\mu_1, \mu_2) & k = 4, \\
      \Sigma_{\ldots}\; \mathrm{DerivationHigh}_{k-5}(c_1, c_2) & k \geq 5.
    \end{cases}
  \]
\end{definition}

\subsubsection{The Main Structure Theorem}

\begin{definition}[Weak $\omega$-Groupoid]\label{def:omega-gpd}
  A \emph{weak $\omega$-groupoid} (in the sense of Batanin--Leinster
  \cite{Leinster04}) on a type $A$ consists of:
  \begin{itemize}
    \item Cells at every dimension: $\mathrm{Cell}_k(A)$ for $k \in \Nat$.
    \item Groupoid operations (identity, composition, inversion) at each
      dimension.
    \item Contractibility: for $k \geq 3$, any two parallel $(k-1)$-cells
      are connected by a $k$-cell.
    \item Bicategorical coherence: pentagon and triangle at the
      2-cell level, witnessed as 3-cells.
  \end{itemize}
\end{definition}

\begin{theorem}[Main Structure Theorem]\label{thm:omega-groupoid}
  For any type $A$, the tower
  \[
    A, \quad \Path, \quad \Derivation_2, \quad \Derivation_3, \quad
    \Derivation_4, \quad \ldots
  \]
  forms a weak $\omega$-groupoid with contractibility starting at
  dimension~3; the higher coherence is simplified by proof irrelevance of
  $\RwEq$.
\end{theorem}

\begin{proof}
  The construction assembles:
  \begin{itemize}
    \item $\mathrm{contract}_3$ (\cref{thm:contract3}) for the
      contractibility at dimension~3.
    \item $\mathrm{contract}_4$ (\cref{thm:contract4}) for dimension~4.
    \item The parametrized $\mathrm{contractHigh}_n$ for dimensions
      $\geq 5$.
    \item The pentagon coherence (\cref{thm:pentagon}) as a 3-cell:
      $\mathrm{MetaStep}_3.\mathrm{pentagon}$ provides the pentagon
      equation between the two canonical reassociation derivations.
    \item The triangle coherence (\cref{thm:triangle}) as a 3-cell:
      $\mathrm{MetaStep}_3.\mathrm{triangle}$ provides the triangle
      equation.
  \end{itemize}
  Groupoid operations at each dimension are given by the constructors
  of the derivation types ($\refl$, $\mathrm{vcomp}$, $\mathrm{inv}$).
\end{proof}

\subsection{The Infinity-Groupoid Approximation}
\label{sec:infinity-gpd}

\begin{definition}[Coherence at Level $n$]\label{def:coherence-level}
  \[
    \mathrm{CoherenceAt}(A, n) \;=\;
    \begin{cases}
      \top & n \leq 1, \\
      \forall\, \delta_1, \delta_2 : \Derivation_2(p,q).\;
        \Derivation_3(\delta_1, \delta_2) & n = 2, \\
      \forall\, \mu_1, \mu_2 : \Derivation_3(\delta_1,\delta_2).\;
        \Derivation_4(\mu_1, \mu_2) & n = 3, \\
      \forall\, c_1, c_2.\; \mathrm{DerivationHigh}_{n-4}(c_1, c_2) & n \geq 4.
    \end{cases}
  \]
\end{definition}

\begin{theorem}\label{thm:infinity-gpd}
  For any type $A$, the canonical coherence witnesses at every level
  assemble into an $\infty$-groupoid structure:
  \[
    \mathrm{coherenceAt}(A, n) : \mathrm{CoherenceAt}(A, n)
    \quad\text{for all}\; n \in \Nat.
  \]
\end{theorem}

\begin{definition}[$n$-Groupoid Truncation]\label{def:n-truncation}
  The \emph{$n$-truncation} of the $\omega$-groupoid collapses all cells
  above dimension $n$ to the trivial type $\mathbf{1}$:
  \[
    \mathrm{TruncCell}_k(A, n) \;=\;
    \begin{cases}
      \mathrm{Cell}_k(A) & k \leq n, \\
      \mathbf{1} & k > n.
    \end{cases}
  \]
\end{definition}

\begin{theorem}\label{thm:1-truncation}
  The 1-truncation of the $\omega$-groupoid recovers the strict groupoid
  $\PathQuot$ of \cref{thm:quot-strict-gpd}.
\end{theorem}

\subsection{Double Groupoid and Symmetric Monoidal Structure}
\label{sec:enriched-structures}

The proof-irrelevance of two-cells enables additional algebraic structures
on the computational path space.

\subsubsection{Double Groupoid}

\begin{definition}[Double Groupoid]\label{def:double-gpd}
  A \emph{double groupoid} is a weak 2-groupoid equipped with an explicit
  interchange law: the two ways of composing a $2 \times 2$ grid of
  two-cells (vertical-then-horizontal vs.\ horizontal-then-vertical)
  are equal.
\end{definition}

\begin{theorem}\label{thm:double-gpd}
  Computational paths form a double groupoid. The interchange law holds
  by proof irrelevance of $\RwEq$.
\end{theorem}

\subsubsection{Groupoid-Enriched Category}

\begin{definition}[Groupoid-Enriched Category]\label{def:gpd-enriched}
  A \emph{groupoid-enriched category} is a weak bicategory whose
  hom-categories (the categories of 2-cells between fixed 1-cells) are
  groupoids---i.e., all 2-cells are invertible, and the groupoid axioms
  (associativity, units, inverses for vertical composition) hold as
  equalities.
\end{definition}

\begin{theorem}\label{thm:gpd-enriched}
  Computational paths form a groupoid-enriched category. All groupoid
  axioms for 2-cells hold by proof irrelevance on $\RwEq$.
\end{theorem}

\subsubsection{Anti-Involution Structure}

\begin{definition}[Anti-Involution]\label{def:anti-involution}
  The symmetry operation $\mathrm{inv}$ on the monoidal path algebra is an
  \emph{anti-involution}: it reverses composition while squaring to the identity.
  \begin{enumerate}[label=(\roman*)]
    \item $\inv{(p \comp q)} \rweq \inv{q} \comp \inv{p}$ \quad
      (anti-homomorphism, via rule~\ref{rule:stss}).
    \item $\inv{(\inv{p})} \rweq p$ \quad (involution, via rule~\ref{rule:ss}).
  \end{enumerate}
\end{definition}

\begin{remark}\label{rem:not-braiding}
  The anti-homomorphism $\inv{(p \comp q)} \rweq \inv{q} \comp \inv{p}$ is
  \emph{not} a braiding: it does not produce a two-cell $p \comp q \rweq
  q \comp p$, but rather a two-cell from $\inv{(p \comp q)}$ to $\inv{q}
  \comp \inv{p}$. Thus the monoidal structure is \emph{not} symmetric
  monoidal in general. Commutativity of composition arises only in
  double loop spaces via the Eckmann--Hilton argument
  (\cref{thm:eckmann-hilton}), where it is mediated by the interchange
  law, not by the anti-involution.
\end{remark}

\medskip

Having established the algebraic foundations and the higher-dimensional structure, we now turn to the homotopy theory built on them: fundamental groups, covering spaces, fibrations, exact sequences, and the computation of $\pi_1$ for standard spaces. Formalization status varies across these applications; see \cref{tab:formalization-status} and the status notes at the start of each section.


%%%% Converted from chapters/ch6_fundamental_groups.tex (article (as-is)) %%%%

%% ============================================================================
%% Chapter 6: Fundamental Groups and Loop Spaces
%% Part II of "The Algebra of Computational Paths"
%% ============================================================================

\section{Fundamental Groups and Loop Spaces}\label{sec:fundamental-groups}

\begin{remark}[Formalization status]
  This section is fully formalized in Lean: the loop-space definitions and fundamental-group results are mechanically verified. See \cref{tab:formalization-status} for the section-by-section summary as we move into mixed-status applications.
\end{remark}

With the algebraic and higher-dimensional foundations established, we now turn to the homotopy-theoretic applications of computational paths.~\cite{Hatcher02, May99} The central notion is the \emph{fundamental group}, which captures the structure of loops in a type up to rewrite equivalence. Throughout what follows, we work with the computational path structure $\Path_A(a,b)$ carrying explicit rewrite traces, modulo the rewrite equality $\mathrm{RwEq}$ developed in \cref{ch:rewrite-system}.

\subsection{Loop Spaces}\label{subsec:loop-spaces}

\begin{definition}[Loop space]\label{def:loop-space}
Let $A$ be a type and $a : A$ a basepoint. The \emph{loop space} of $A$ at $a$ is
\[
  \Omega(A, a) \;=\; \Path_A(a, a),
\]
the type of computational paths from $a$ to itself. The loop space carries three fundamental operations:
\begin{itemize}
  \item \emph{Composition}: $\mathsf{comp}(p, q) = \mathsf{trans}(p, q)$ for $p, q : \Omega(A, a)$;
  \item \emph{Identity}: $\mathsf{id} = \mathsf{refl}(a)$;
  \item \emph{Inversion}: $\mathsf{inv}(p) = \mathsf{symm}(p)$.
\end{itemize}
\end{definition}

By Theorem~2.4 (the monoid laws for computational paths), composition in $\Omega(A,a)$ is strictly associative: for all $p, q, r : \Omega(A,a)$,
\[
  \mathsf{comp}(\mathsf{comp}(p, q), r) \;=\; \mathsf{comp}(p, \mathsf{comp}(q, r)),
\]
and $\mathsf{refl}(a)$ is a strict two-sided unit. Thus $\Omega(A,a)$ is a monoid in the strict sense. However, inverse laws hold only up to rewrite equality: $\mathsf{comp}(p, \mathsf{inv}(p)) \not= \mathsf{refl}(a)$ as path structures (since the traces differ), but $\mathrm{RwEq}(\mathsf{comp}(p, \mathsf{inv}(p)),\, \mathsf{refl}(a))$ holds by Rules~5 and~6 of the $\mathrm{LND_{EQ}}$-TRS.

\begin{definition}[Loop quotient]\label{def:loop-quotient}
The \emph{loop quotient} at basepoint $a$ is
\[
  \mathrm{LoopQuot}(A, a) \;=\; \PathRwQuot(A, a, a) \;=\; \Path_A(a, a) \;/\; \mathrm{RwEq}.
\]
The operations of $\Omega(A,a)$ descend to the quotient:
\begin{align*}
  \mathsf{comp}\bigl([p], [q]\bigr) &= [\mathsf{trans}(p, q)], \\
  \mathsf{inv}\bigl([p]\bigr) &= [\mathsf{symm}(p)], \\
  \mathsf{id} &= [\mathsf{refl}(a)].
\end{align*}
These are well-defined by the congruence property of $\mathrm{RwEq}$ (Theorem~3.6).
\end{definition}

\subsection{The Fundamental Group}\label{subsec:fundamental-group}

\begin{definition}[Fundamental group]\label{def:pi-one}
The \emph{fundamental group} of a type $A$ at basepoint $a$ is
\[
  \pi_1(A, a) \;=\; \mathrm{LoopQuot}(A, a)
\]
equipped with group multiplication $[p] \cdot [q] = [\mathsf{trans}(p, q)]$, identity element $e = [\mathsf{refl}(a)]$, and inversion $[p]^{-1} = [\mathsf{symm}(p)]$.
\end{definition}

\begin{theorem}[Group axioms]\label{thm:pi1-group}
$\pi_1(A, a)$ is a group: the following identities hold as strict equalities on the quotient.
\begin{enumerate}
  \item \emph{Associativity}: $(\alpha \cdot \beta) \cdot \gamma = \alpha \cdot (\beta \cdot \gamma)$ for all $\alpha, \beta, \gamma : \pi_1(A,a)$.
  \item \emph{Left identity}: $e \cdot \alpha = \alpha$.
  \item \emph{Right identity}: $\alpha \cdot e = \alpha$.
  \item \emph{Left inverse}: $\alpha^{-1} \cdot \alpha = e$.
  \item \emph{Right inverse}: $\alpha \cdot \alpha^{-1} = e$.
\end{enumerate}
\end{theorem}

\begin{proof}
Associativity on the quotient follows from the strict associativity of $\mathsf{trans}$ on computational paths (Theorem~2.4(iii)). The identity laws follow from the corresponding $\mathrm{RwEq}$ witnesses: $\mathrm{RwEq}(\mathsf{trans}(\mathsf{refl}(a), p),\, p)$ and $\mathrm{RwEq}(\mathsf{trans}(p, \mathsf{refl}(a)),\, p)$, which are provided by Rules~3 and~4. The inverse laws use Rules~5 and~6: $\mathrm{RwEq}(\mathsf{trans}(p, \mathsf{symm}(p)),\, \mathsf{refl}(a))$ and $\mathrm{RwEq}(\mathsf{trans}(\mathsf{symm}(p), p),\, \mathsf{refl}(a))$. Since $\mathrm{RwEq}$ is exactly the kernel of the quotient map, these witnesses yield strict equalities in $\mathrm{LoopQuot}(A,a)$.
\end{proof}

Several additional identities follow from the group structure:

\begin{corollary}\label{cor:pi1-identities}
For all $\alpha, \beta : \pi_1(A, a)$:
\begin{enumerate}
  \item $e^{-1} = e$.
  \item $(\alpha^{-1})^{-1} = \alpha$.
  \item $(\alpha \cdot \beta)^{-1} = \beta^{-1} \cdot \alpha^{-1}$.
\end{enumerate}
\end{corollary}

\begin{proof}
(1) follows from $e^{-1} \cdot e = e$ and right cancellation. (2) follows from $\mathrm{RwEq}(\mathsf{symm}(\mathsf{symm}(p)),\, p)$ (Rule~2). (3) follows from $\mathrm{RwEq}(\mathsf{symm}(\mathsf{trans}(p, q)),\, \mathsf{trans}(\mathsf{symm}(q), \mathsf{symm}(p)))$ (Rule~7).
\end{proof}

The strict group structure also supports cancellation lemmas that are essential for later algebraic computations:

\begin{lemma}[Cancellation]\label{lem:cancellation}
In $\pi_1(A, a)$:
\begin{enumerate}
  \item \emph{Right cancellation}: if $\alpha \cdot \gamma = \beta \cdot \gamma$, then $\alpha = \beta$.
  \item \emph{Left cancellation}: if $\alpha \cdot \beta = \alpha \cdot \gamma$, then $\beta = \gamma$.
\end{enumerate}
\end{lemma}

\begin{proof}
For right cancellation, compose both sides with $\gamma^{-1}$ on the right and apply associativity and the inverse law. Left cancellation is analogous.
\end{proof}

\subsection{Functoriality}\label{subsec:pi1-functoriality}

\begin{theorem}[Induced homomorphism]\label{thm:induced-hom}
A based map $f : (A, a) \to (B, b)$ (i.e., a function $f : A \to B$ with $f(a) = b$) induces a group homomorphism
\[
  f_* : \pi_1(A, a) \to \pi_1(B, b)
\]
defined on representatives by $f_*([p]) = [\mathsf{congrArg}(f, p)]$.
\end{theorem}

\begin{proof}
Well-definedness: if $\mathrm{RwEq}(p, q)$, then $\mathrm{RwEq}(\mathsf{congrArg}(f, p),\, \mathsf{congrArg}(f, q))$ by Theorem~3.6. The map is a homomorphism because $\mathsf{congrArg}$ is functorial (Theorem~2.8):
\[
  f_*(\alpha \cdot \beta) = [\mathsf{congrArg}(f, \mathsf{trans}(p, q))] = [\mathsf{trans}(\mathsf{congrArg}(f, p), \mathsf{congrArg}(f, q))] = f_*(\alpha) \cdot f_*(\beta).
\]
Identity preservation follows from $\mathsf{congrArg}(f, \mathsf{refl}(a)) = \mathsf{refl}(f(a))$.
\end{proof}

\begin{theorem}[Functoriality]\label{thm:pi1-functor}
The fundamental group construction is functorial:
\begin{enumerate}
  \item $(\mathrm{id}_A)_* = \mathrm{id}_{\pi_1(A,a)}$.
  \item For $f : (A, a) \to (B, b)$ and $g : (B, b) \to (C, c)$, $(g \circ f)_* = g_* \circ f_*$.
\end{enumerate}
\end{theorem}

\begin{proof}
(1) follows from $\mathsf{congrArg}(\mathrm{id}, p) = p$. (2) follows from $\mathsf{congrArg}(g \circ f, p) = \mathsf{congrArg}(g, \mathsf{congrArg}(f, p))$, both of which hold as equalities of computational paths.
\end{proof}

\begin{theorem}[Product formula]\label{thm:pi1-product}
For types $A$ and $B$ with basepoints $a : A$ and $b : B$,
\[
  \pi_1(A \times B, (a, b)) \;\cong\; \pi_1(A, a) \times \pi_1(B, b).
\]
\end{theorem}

\begin{proof}
The isomorphism is given by encoding and decoding maps at the quotient level:
\begin{align*}
  \Phi &: \pi_1(A \times B, (a,b)) \to \pi_1(A,a) \times \pi_1(B,b), & \Phi([\gamma]) &= ([\mathsf{fst}(\gamma)],\, [\mathsf{snd}(\gamma)]); \\
  \Psi &: \pi_1(A,a) \times \pi_1(B,b) \to \pi_1(A \times B, (a,b)), & \Psi([\alpha], [\beta]) &= [\mathsf{prodMk}(\alpha, \beta)].
\end{align*}
Well-definedness of $\Phi$ holds because projection preserves $\mathrm{RwEq}$: if $\mathrm{RwEq}(\gamma_1, \gamma_2)$ then $\mathrm{RwEq}(\mathsf{fst}(\gamma_1), \mathsf{fst}(\gamma_2))$, and similarly for $\mathsf{snd}$. Well-definedness of $\Psi$ holds because $\mathsf{prodMk}$ preserves $\mathrm{RwEq}$ in each component.

The round-trip $\Phi \circ \Psi = \mathrm{id}$ follows from the product $\beta$-rules (Theorem~2.13):
\[
  \mathsf{fst}(\mathsf{prodMk}(p, q)) = p, \qquad \mathsf{snd}(\mathsf{prodMk}(p, q)) = q.
\]
The round-trip $\Psi \circ \Phi = \mathrm{id}$ follows from the product $\eta$-rule:
\[
  \mathrm{RwEq}\bigl(\mathsf{prodMk}(\mathsf{fst}(\gamma), \mathsf{snd}(\gamma)),\, \gamma\bigr).
\]
Both $\Phi$ and $\Psi$ are homomorphisms: $\Phi$ preserves multiplication because $\mathsf{fst}$ and $\mathsf{snd}$ distribute over $\mathsf{trans}$ (by the congruence rules), and $\Psi$ preserves multiplication because $\mathsf{prodMk}$ distributes over $\mathsf{trans}$ componentwise.
\end{proof}

\subsection{Iterated Loop Spaces and Higher Homotopy Groups}\label{subsec:higher-homotopy}

\begin{definition}[Iterated loop space]\label{def:iterated-loop}
The \emph{$n$-fold iterated loop space} is defined recursively:
\begin{align*}
  \Omega^0(A, a) &= A, \\
  \Omega^{n+1}(A, a) &= \Omega(\Omega^n(A, a),\, \mathsf{pt}_n),
\end{align*}
where $\mathsf{pt}_0 = a$ and $\mathsf{pt}_{n+1} = \mathsf{refl}(\mathsf{pt}_n)$.
\end{definition}

\begin{definition}[Higher homotopy groups]\label{def:pi-n}
The \emph{$n$-th homotopy group} is
\[
  \pi_n(A, a) = \pi_0(\Omega^n(A, a)),
\]
where $\pi_0$ denotes path-connected components (the quotient by the relation of being connected by a path). For $n \geq 1$, this coincides with $\mathrm{LoopQuot}(\Omega^{n-1}(A, a),\, \mathsf{pt}_{n-1})$.~\cite{Brunerie16}
\end{definition}

The group operations on $\pi_n(A,a)$ for $n \geq 1$ are inherited from the loop space structure of $\Omega^n(A,a)$: composition in $\Omega^n$ descends to multiplication in $\pi_n$, reflexivity gives the identity, and symmetry gives inversion.

\begin{theorem}[Eckmann--Hilton]\label{thm:eckmann-hilton}
For $n \geq 2$, the group $\pi_n(A, a)$ is abelian.~\cite{EckHil62}
\end{theorem}

\begin{proof}
The double loop space $\Omega^2(A, a)$ admits two composition operations:
\begin{itemize}
  \item \emph{Vertical composition} $\alpha \circ_v \beta$: sequential concatenation of derivations;
  \item \emph{Horizontal composition} $\alpha \circ_h \beta$: defined via whiskering,
  \[
    \alpha \circ_h \beta \;=\; (\alpha \triangleright_R \mathsf{refl}(a)) \circ_v (\mathsf{refl}(a) \triangleleft_L \beta),
  \]
  where $\triangleright_R$ and $\triangleleft_L$ denote right and left whiskering.
\end{itemize}

The proof proceeds in three steps, each witnessed by a 3-cell (an element of $\mathrm{Derivation}_3$):

\medskip
\noindent\textbf{Step 1} (Whiskering by $\mathsf{refl}$ is trivial). Since $\mathsf{trans}(\mathsf{refl}(a), \mathsf{refl}(a))$ reduces definitionally to $\mathsf{refl}(a)$ in the computational-paths framework, left and right whiskering by $\mathsf{refl}(a)$ act as the identity on $\Omega^2$-elements. More precisely, for $\alpha : \Omega^2(A,a)$:
\begin{align*}
  \alpha \triangleright_R \mathsf{refl}(a) &\equiv_3 \alpha, \\
  \mathsf{refl}(a) \triangleleft_L \alpha &\equiv_3 \alpha,
\end{align*}
where $\equiv_3$ denotes the existence of a connecting $\mathrm{Derivation}_3$ cell.

\medskip
\noindent\textbf{Step 2} (Horizontal equals vertical). Combining the whiskering triviality:
\[
  \alpha \circ_h \beta \;=\; (\alpha \triangleright_R \mathsf{refl}) \circ_v (\mathsf{refl} \triangleleft_L \beta) \;\equiv_3\; \alpha \circ_v \beta.
\]

\medskip
\noindent\textbf{Step 3} (Commutativity via interchange). The interchange law (Theorem~5.3, realized by the primitive 3-cell $\mathsf{MetaStep}_3.\mathsf{interchange}$) states
\[
  (\alpha \triangleright_R g) \circ_v (f' \triangleleft_L \beta) \;\equiv_3\; (f \triangleleft_L \beta) \circ_v (\alpha \triangleright_R g').
\]
Specializing $f = f' = g = g' = \mathsf{refl}(a)$ and combining with Step~2:
\[
  \alpha \circ_v \beta \;\equiv_3\; \alpha \circ_h \beta \;\equiv_3\; \alpha \circ_h' \beta \;\equiv_3\; \beta \circ_v \alpha,
\]
where $\circ_h'$ denotes the alternative horizontal composition (left-whisker first, then right-whisker). Since $\equiv_3$-related derivations yield the same $\mathrm{RwEq}$ witness (by proof irrelevance at level~3), this gives strict commutativity in $\pi_2(A,a)$ and, by iteration, in $\pi_n(A,a)$ for all $n \geq 2$.
\end{proof}

\begin{remark}\label{rem:pi1-nonabelian}
The Eckmann--Hilton argument does \emph{not} apply to $\pi_1$. This is essential: non-abelian fundamental groups, such as $\pi_1(S^1 \vee S^1) \cong \mathbb{Z} * \mathbb{Z}$, constitute key examples developed in \cref{sec:spaces}.
\end{remark}

\subsection{The Fundamental Groupoid}\label{subsec:fundamental-groupoid}

While $\pi_1(A, a)$ depends on a choice of basepoint, the \emph{fundamental groupoid} captures the path structure of $A$ in a basepoint-free manner.

\begin{definition}[Fundamental groupoid]\label{def:fundamental-groupoid}
The \emph{fundamental groupoid} $\Pi_1(A)$ of a type $A$ is the strict groupoid with:
\begin{itemize}
  \item \emph{Objects}: points $a : A$;
  \item \emph{Morphisms}: $\mathrm{Hom}_{\Pi_1(A)}(a, b) = \PathRwQuot(A, a, b)$;
  \item \emph{Composition}: induced by $\mathsf{trans}$;
  \item \emph{Identity}: $\mathrm{id}_a = [\mathsf{refl}(a)]$;
  \item \emph{Inverse}: induced by $\mathsf{symm}$.
\end{itemize}
All groupoid axioms (associativity, unit laws, inverse laws) hold strictly on the quotient by Theorem~3.15.
\end{definition}

\begin{theorem}[Basepoint independence]\label{thm:basepoint-independence}
For any path $p : \Path_A(a, b)$, conjugation by $[p]$ induces a group isomorphism
\[
  \varphi_p : \pi_1(A, a) \xrightarrow{\;\cong\;} \pi_1(A, b), \qquad \varphi_p(\alpha) = [p]^{-1} \cdot \alpha \cdot [p].
\]
\end{theorem}

\begin{proof}
The map $\varphi_p$ is a homomorphism:
\[
  \varphi_p(\alpha \cdot \beta) = [p]^{-1} \cdot \alpha \cdot \beta \cdot [p] = [p]^{-1} \cdot \alpha \cdot [p] \cdot [p]^{-1} \cdot \beta \cdot [p] = \varphi_p(\alpha) \cdot \varphi_p(\beta),
\]
using the insertion of $[p] \cdot [p]^{-1} = e$. The map $\varphi_{\mathsf{symm}(p)}$ provides a two-sided inverse.
\end{proof}

\begin{theorem}[Functoriality of the fundamental groupoid]\label{thm:groupoid-functor}
A function $f : A \to B$ induces a groupoid functor
\[
  \Pi_1(f) : \Pi_1(A) \to \Pi_1(B)
\]
defined on objects by $\Pi_1(f)(a) = f(a)$ and on morphisms by $\Pi_1(f)([\gamma]) = [\mathsf{congrArg}(f, \gamma)]$. This construction is functorial:
\begin{enumerate}
  \item $\Pi_1(\mathrm{id}_A) = \mathrm{id}_{\Pi_1(A)}$.
  \item $\Pi_1(g \circ f) = \Pi_1(g) \circ \Pi_1(f)$.
\end{enumerate}
Natural transformations between induced functors correspond to paths: if $h : \Path_B(f(a), g(a))$ for all $a$, then $\Pi_1(f) \Rightarrow \Pi_1(g)$.
\end{theorem}

\begin{proof}
Well-definedness and functoriality follow from the functoriality of $\mathsf{congrArg}$ (Theorem~2.8) and its compatibility with $\mathrm{RwEq}$ (Theorem~3.6). For the naturality claim, given paths $h_a : \Path(f(a), g(a))$, the naturality square
\[
  [\mathsf{congrArg}(g, \gamma)] \cdot [h_b]^{-1} = [h_a]^{-1} \cdot [\mathsf{congrArg}(f, \gamma)]
\]
holds in $\Pi_1(B)$ because both sides, lifted to paths, are connected by $\mathrm{RwEq}$.
\end{proof}

\begin{remark}\label{rem:pi1-automorphism}
The fundamental group $\pi_1(A, a)$ is recovered as the automorphism group $\mathrm{Aut}_{\Pi_1(A)}(a) = \mathrm{Hom}_{\Pi_1(A)}(a, a)$. Path-connectedness of $A$ corresponds to connectedness of $\Pi_1(A)$ as a category: for every pair of objects, the morphism set is non-empty. Simple-connectedness corresponds to codiscreteness: every morphism set is a singleton.
\end{remark}


%%%% Converted from chapters/ch7_spaces.tex (article (as-is)) %%%%

%% ============================================================================
%% Chapter 7: Spaces and Their Fundamental Groups
%% Part II of "The Algebra of Computational Paths"
%% ============================================================================

\section{Spaces and Their Fundamental Groups}\label{sec:spaces}

\begin{remark}[Formalization status]
  This section mixes fully formalized and scaffolded results. The circle and torus computations are fully formalized, while the figure-eight, Seifert--van Kampen, and suspension results are partially scaffolded; see \cref{tab:formalization-status}.
\end{remark}

\subsection{From \texorpdfstring{$\Path$}{Path} to Path Expressions}\label{subsec:pathexpr-bridge}

Up to this point, equality witnesses live in the core type $\Path_A(a,b)$. To define spaces such as $S^1$ without higher inductive types, we move to a \emph{syntactic extension} of paths: a path-expression language that freely adjoins formal generators.

\begin{definition}[Path expressions with generators]\label{def:pathexpr-generators}
Fix a type $A$ and a chosen family of formal generators. The type $\mathrm{PathExpr}_A(a,b)$ is the free term language generated by:
\begin{itemize}
  \item an embedding $\mathrm{atom} : \Path_A(a,b) \to \mathrm{PathExpr}_A(a,b)$,
  \item the chosen generators (e.g.\ a loop symbol),
  \item the usual constructors $\refl$, $\symm$, $\trans$, and the congruence operations.
\end{itemize}
When no generators are added, $\mathrm{PathExpr}_A$ merely re-encodes $\Path_A$; when generators are present, it strictly extends $\Path_A$ by adding formal paths not available in the ambient type theory. A fully formal definition appears in \cref{sec:pathexpr}.
\end{definition}

The relationship between $\Path$ and $\mathrm{PathExpr}$ is therefore twofold: $\Path$ embeds via $\mathrm{atom}$, and the added generators provide the extra loop structure needed to model spaces like $S^1$. The $\mathrm{LND_{EQ}}$ rewrite rules lift verbatim to $\mathrm{PathExpr}$ by matching on the same syntactic constructors, so $\mathrm{RwEq}$ and the induced groupoid structure extend unchanged. Thus in this section we compute $\pi_1$ by taking loops in $\mathrm{PathExpr}$ and quotienting by $\mathrm{RwEq}$.

We now compute the fundamental groups of standard spaces within the computational-paths framework. The key technical device is the path expression construction described above: we model spaces as ordinary types equipped with formal loop generators at the syntactic level, then compute $\pi_1$ via winding-number arguments and free-product word decompositions.

\subsection{The Computational Circle \texorpdfstring{$S^1$}{S¹}}\label{subsec:circle}

\begin{definition}[Circle]\label{def:circle}
The \emph{computational-path circle} $S^1$ is a single-point type
\[
  S^1 = \{ \mathsf{base} \}
\]
equipped with a formal loop generator via the path expression system. Concretely, we define a type $\mathrm{CirclePathExpr}$ of \emph{path expressions} between points of $S^1$, generated by:
\begin{align*}
  \mathsf{loop} &: \mathrm{CirclePathExpr}(\mathsf{base}, \mathsf{base}), \\
  \mathsf{refl}(a) &: \mathrm{CirclePathExpr}(a, a), \\
  \mathsf{symm}(p) &: \mathrm{CirclePathExpr}(b, a) \quad\text{for } p : \mathrm{CirclePathExpr}(a, b), \\
  \mathsf{trans}(p, q) &: \mathrm{CirclePathExpr}(a, c) \quad\text{for } p : \mathrm{CirclePathExpr}(a, b),\ q : \mathrm{CirclePathExpr}(b, c).
\end{align*}
\end{definition}

\begin{remark}[Relation to higher inductive types]\label{rem:circle-hit}
  This construction is analogous to a higher inductive type (HIT)---we add
  a formal loop generator to the path expression system. The key difference
  from HoTT's circle HIT is that our generator lives in the
  \emph{path-expression} layer, not in the identity type itself: $S^1$ is
  an ordinary single-point type in the ambient theory, and the non-trivial
  loop structure is entirely a feature of the computational-path
  machinery.
\end{remark}

Since $S^1$ has a single point, every path expression is a loop expression. The essential algebraic invariant is the \emph{winding number}.

\begin{definition}[Winding number]\label{def:winding}
The \emph{winding number} function $w : \mathrm{CirclePathExpr}(\mathsf{base}, \mathsf{base}) \to \mathbb{Z}$ is defined recursively by:
\begin{align*}
  w(\mathsf{loop}) &= 1, \\
  w(\mathsf{refl}(a)) &= 0, \\
  w(\mathsf{symm}(p)) &= -w(p), \\
  w(\mathsf{trans}(p, q)) &= w(p) + w(q).
\end{align*}
\end{definition}

The winding number is a complete invariant for path expressions modulo rewrite equality:

\begin{lemma}\label{lem:winding-invariant}
Let $p, q : \mathrm{CirclePathExpr}(\mathsf{base}, \mathsf{base})$. Then $w(p) = w(q)$ if and only if $p$ and $q$ represent the same element of $\pi_1(S^1, \mathsf{base})$.
\end{lemma}

\begin{proof}
The forward direction: the winding number is invariant under the $\mathrm{LND_{EQ}}$ rewrite rules. Each rule preserves $w$: for instance, $w(\mathsf{trans}(\mathsf{refl}, p)) = 0 + w(p) = w(p)$, confirming Rule~3. Rule~5 gives $w(\mathsf{trans}(p, \mathsf{symm}(p))) = w(p) + (-w(p)) = 0 = w(\mathsf{refl})$. All other rules are verified similarly.

The reverse direction: if $w(p) = w(q)$, then both $p$ and $q$ are rewrite-equivalent to the canonical power expression $\mathsf{loop}^{w(p)}$. This follows because every path expression $p$ rewrites to $\mathsf{loop}^{w(p)}$ via the normalization procedure: use Rule~8 (associativity) to flatten nested $\mathsf{trans}$, Rule~2 to eliminate double $\mathsf{symm}$, and Rules~5--6 to cancel adjacent $\mathsf{loop} \cdot \mathsf{loop}^{-1}$ pairs.
\end{proof}

\begin{definition}[Integer powers]\label{def:loop-powers}
For $n \in \mathbb{Z}$, the \emph{$n$-th power} of the loop generator is:
\[
  \mathsf{loop}^n = \begin{cases}
    \underbrace{\mathsf{trans}(\mathsf{loop}, \ldots, \mathsf{loop})}_{n} & \text{if } n \geq 0, \\
    \mathsf{symm}\bigl(\mathsf{loop}^{|n|}\bigr) & \text{if } n < 0.
  \end{cases}
\]
\end{definition}

\begin{theorem}\label{thm:pi1-circle}
$\pi_1(S^1, \mathsf{base}) \cong \mathbb{Z}$.
\end{theorem}

\begin{proof}
Define mutually inverse maps:
\begin{align*}
  \Phi &: \pi_1(S^1, \mathsf{base}) \to \mathbb{Z}, & \Phi([p]) &= w(p); \\
  \Psi &: \mathbb{Z} \to \pi_1(S^1, \mathsf{base}), & \Psi(n) &= [\mathsf{loop}^n].
\end{align*}
$\Phi$ is well-defined by the invariance of $w$ under rewriting. $\Phi$ is a homomorphism: $\Phi([\mathsf{trans}(p, q)]) = w(p) + w(q) = \Phi([p]) + \Phi([q])$.

The round-trip $\Phi \circ \Psi = \mathrm{id}_{\mathbb{Z}}$: $\Phi(\Psi(n)) = w(\mathsf{loop}^n) = n$, verified by induction on $n$.

The round-trip $\Psi \circ \Phi = \mathrm{id}_{\pi_1}$: for any $[p]$, $\Psi(\Phi([p])) = [\mathsf{loop}^{w(p)}] = [p]$ by Lemma~\ref{lem:winding-invariant}.
\end{proof}

\subsection{The Torus \texorpdfstring{$T^2$}{T²}}\label{subsec:torus}

\begin{definition}[Torus]\label{def:torus}
The \emph{torus} is defined as the product $T^2 = S^1 \times S^1$, with basepoint $(\mathsf{base}, \mathsf{base})$.
\end{definition}

The two generating loops of the torus are:
\begin{align*}
  \alpha &= \mathsf{prodMk}(\mathsf{loop}, \mathsf{refl}(\mathsf{base})) : \Omega(T^2, (\mathsf{base}, \mathsf{base})), \\
  \beta  &= \mathsf{prodMk}(\mathsf{refl}(\mathsf{base}), \mathsf{loop}) : \Omega(T^2, (\mathsf{base}, \mathsf{base})).
\end{align*}

\begin{theorem}\label{thm:pi1-torus}
$\pi_1(T^2, (\mathsf{base}, \mathsf{base})) \cong \mathbb{Z} \times \mathbb{Z}$.
\end{theorem}

\begin{proof}
This is an immediate consequence of the product formula (Theorem~\ref{thm:pi1-product}) and the circle computation (Theorem~\ref{thm:pi1-circle}):
\[
  \pi_1(S^1 \times S^1, (\mathsf{base}, \mathsf{base})) \cong \pi_1(S^1, \mathsf{base}) \times \pi_1(S^1, \mathsf{base}) \cong \mathbb{Z} \times \mathbb{Z}.
\]
The two generators correspond to $[\alpha] \mapsto (1, 0)$ and $[\beta] \mapsto (0, 1)$. The commutativity relation $[\alpha] \cdot [\beta] = [\beta] \cdot [\alpha]$ holds because $\mathbb{Z} \times \mathbb{Z}$ is abelian.
\end{proof}

\subsection{The Figure-Eight and Free Products}\label{subsec:figure-eight}

\begin{definition}[Wedge sum]\label{def:wedge}
For pointed types $(A, a_0)$ and $(B, b_0)$, the \emph{wedge sum} $A \vee B$ is the pushout
\[
  A \xleftarrow{\;f\;} \{\ast\} \xrightarrow{\;g\;} B
\]
where $f(\ast) = a_0$ and $g(\ast) = b_0$, with basepoint $\mathsf{inl}(a_0) = \mathsf{inr}(b_0)$.
\end{definition}

\begin{definition}[Figure-eight]\label{def:figure-eight}
The \emph{figure-eight space} is the wedge sum $S^1 \vee S^1$, with basepoint at the junction where the two circles meet.
\end{definition}

The figure-eight has two fundamental loops:
\begin{itemize}
  \item \emph{Loop $A$}: the loop of the left circle, embedded via $\mathsf{inl}$;
  \item \emph{Loop $B$}: the loop of the right circle, conjugated to the common basepoint:
  \[
    \mathsf{loopB} = \mathsf{glue} \cdot \mathsf{inr}(\mathsf{loop}) \cdot \mathsf{glue}^{-1},
  \]
  where $\mathsf{glue} : \Path(\mathsf{inl}(\mathsf{base}), \mathsf{inr}(\mathsf{base}))$ is the identification path of the wedge.
\end{itemize}

\begin{theorem}\label{thm:pi1-figure-eight}
$\pi_1(S^1 \vee S^1, \mathsf{base}) \cong \mathbb{Z} * \mathbb{Z}$, the free product of $\mathbb{Z}$ with itself.
\end{theorem}

The proof uses a provenance-based Seifert--van Kampen argument: loops in $S^1 \vee S^1$ are encoded as \emph{free product words}---reduced alternating sequences of elements from $\pi_1(S^1)$ (left) and $\pi_1(S^1)$ (right). The encoding and decoding maps establish a bijection between $\pi_1(S^1 \vee S^1)$ and the free product word type.

\begin{remark}\label{rem:nonabelian}
The fundamental group $\mathbb{Z} * \mathbb{Z}$ is non-abelian: the elements $[\mathsf{loopA}] \cdot [\mathsf{loopB}]$ and $[\mathsf{loopB}] \cdot [\mathsf{loopA}]$ are distinct as reduced words. This confirms that $\pi_1$ is not always abelian (cf.\ Remark~\ref{rem:pi1-nonabelian}), in contrast to $\pi_n$ for $n \geq 2$.
\end{remark}

\begin{definition}[Bouquet of circles]\label{def:bouquet}
The \emph{bouquet} $\bigvee_n S^1$ is the wedge sum of $n$ copies of the circle at a common basepoint.
\end{definition}

\begin{corollary}\label{cor:pi1-bouquet}
$\pi_1\bigl(\bigvee_n S^1, \mathsf{base}\bigr) \cong F_n$, the free group on $n$ generators.
\end{corollary}

\begin{proof}
By induction on $n$, using the Seifert--van Kampen theorem and the fact that $\pi_1(S^1) \cong \mathbb{Z}$. The base case $n = 1$ is Theorem~\ref{thm:pi1-circle}. The inductive step uses $\bigvee_{n+1} S^1 \cong \bigl(\bigvee_n S^1\bigr) \vee S^1$ and the free product decomposition.
\end{proof}

\subsection{The Seifert--van Kampen Theorem}\label{subsec:svk}

The computations above are unified by the Seifert--van Kampen theorem, which computes the fundamental group of a pushout in terms of the fundamental groups of its constituents.

\begin{definition}[Pushout]\label{def:pushout}
Given types $A$, $B$, $C$ and maps $f : C \to A$, $g : C \to B$, the \emph{pushout} $\mathrm{Pushout}(A, B, C, f, g)$ is the type generated by:
\begin{itemize}
  \item $\mathsf{inl}(a)$ for $a : A$;
  \item $\mathsf{inr}(b)$ for $b : B$;
  \item $\mathsf{glue}(c) : \Path(\mathsf{inl}(f(c)),\, \mathsf{inr}(g(c)))$ for $c : C$.
\end{itemize}
\end{definition}

\begin{definition}[Amalgamated free product]\label{def:amalgamated}
Given groups $G$, $H$, and $K$ with homomorphisms $\varphi : K \to G$ and $\psi : K \to H$, the \emph{amalgamated free product} $G *_K H$ is the quotient of the free product $G * H$ by the normal closure of $\{\varphi(k) \cdot \psi(k)^{-1} : k \in K\}$.
\end{definition}

\begin{theorem}[Seifert--van Kampen]\label{thm:svk}
Let $f : C \to A$ and $g : C \to B$, and fix a basepoint $c_0 : C$. Then there is an equivalence
\[
  \pi_1\bigl(\mathrm{Pushout}(A, B, C, f, g),\; \mathsf{inl}(f(c_0))\bigr) \;\simeq\; \pi_1(A, f(c_0)) *_{\pi_1(C, c_0)} \pi_1(B, g(c_0)),
\]
where the amalgamation maps are $f_* : \pi_1(C, c_0) \to \pi_1(A, f(c_0))$ and $g_* : \pi_1(C, c_0) \to \pi_1(B, g(c_0))$.
\end{theorem}

\begin{proof}[Proof sketch]
The proof follows the HoTT approach of Favonia and Shulman~\cite{favonia18}, adapted to the computational-paths setting. The encoding map sends a loop in the pushout to a word in the amalgamated free product by tracking provenance: each segment of the loop is recorded as belonging to $A$, $B$, or as a glue path. The decoding map builds a pushout loop from a word. The key technical conditions are:
\begin{enumerate}
  \item The glue paths provide the naturality data for the $\pi_1(C)$-action, ensuring that the amalgamation relation holds.
  \item The encode--decode round-trip uses the fact that path expressions in the pushout can be reduced to canonical word form.
  \item The decode--encode round-trip uses the pushout elimination principle.
\end{enumerate}
The formalization packages this via a \emph{provenance encoding} structure that records, for each path segment, whether it originated from the left or right injection.
\end{proof}

The Seifert--van Kampen theorem recovers the previous computations as special cases:

\begin{corollary}\label{cor:svk-wedge}
$\pi_1(A \vee B, \mathsf{base}) \cong \pi_1(A, a_0) * \pi_1(B, b_0)$ for the wedge sum of pointed types.
\end{corollary}

\begin{proof}
The wedge $A \vee B$ is the pushout of $A \xleftarrow{f} \{\ast\} \xrightarrow{g} B$ where $f(\ast) = a_0$, $g(\ast) = b_0$. Since $\pi_1(\{\ast\}, \ast) = \{e\}$ is trivial, the amalgamated free product $\pi_1(A) *_{\{e\}} \pi_1(B)$ is the ordinary free product $\pi_1(A) * \pi_1(B)$.
\end{proof}

\begin{corollary}\label{cor:svk-figure-eight}
$\pi_1(S^1 \vee S^1) \cong \mathbb{Z} * \mathbb{Z}$.
\end{corollary}

\subsection{Suspensions and Spheres}\label{subsec:suspensions}

\begin{definition}[Suspension]\label{def:suspension}
The \emph{suspension} $\Sigma X$ of a type $X$ is defined by:
\begin{itemize}
  \item Two constructors: $\mathsf{north}, \mathsf{south} : \Sigma X$;
  \item A path constructor: $\mathsf{merid}(x) : \Path(\mathsf{north}, \mathsf{south})$ for each $x : X$.
\end{itemize}
\end{definition}

The suspension provides a recursive construction of higher-dimensional spheres:

\begin{proposition}\label{prop:sphere-suspension}
$S^{n+1} \simeq \Sigma S^n$, where $S^0 = \{\mathsf{north}, \mathsf{south}\}$ (two discrete points).
\end{proposition}

The key loop in a suspension is the \emph{base loop} at the north pole:
\[
  \sigma(x) = \mathsf{merid}(x) \cdot \mathsf{merid}(x_0)^{-1} : \Omega(\Sigma X, \mathsf{north}).
\]

\begin{theorem}\label{thm:pi1-suspension}
For any type $X$ with at least two points, $\pi_1(\Sigma X, \mathsf{north})$ is trivial (i.e., every loop is rewrite-equivalent to $\mathsf{refl}$).
\end{theorem}

\begin{proof}[Proof sketch]
Any loop at $\mathsf{north}$ is a concatenation of paths of the form $\mathsf{merid}(x) \cdot \mathsf{merid}(y)^{-1}$. But $\mathsf{merid}(x) \cdot \mathsf{merid}(y)^{-1} \cdot \mathsf{merid}(y) \cdot \mathsf{merid}(x')^{-1}$ collapses by cancellation. By induction on the word length, every loop reduces to $\mathsf{merid}(x) \cdot \mathsf{merid}(x)^{-1} = \mathsf{refl}$.
\end{proof}

\begin{corollary}\label{cor:pi1-higher-spheres}
For $n \geq 2$, $\pi_1(S^n) = 0$.
\end{corollary}

\subsection{Further Examples}\label{subsec:further-spaces}

The computational-paths framework accommodates a range of additional spaces whose fundamental groups are computed via similar techniques.

\paragraph{Klein bottle.}
The Klein bottle $K$ is a one-point type with two formal loop generators $\alpha$ and $\beta$ subject to the relation $\alpha \cdot \beta = \beta \cdot \alpha^{-1}$. This yields
\[
  \pi_1(K) \cong \langle \alpha, \beta \mid \alpha \beta \alpha^{-1} \beta \rangle \cong \mathbb{Z} \rtimes \mathbb{Z}.
\]

\paragraph{Real projective spaces.}
The real projective space $\mathbb{R}P^n$ for $n \geq 2$ has $\pi_1(\mathbb{R}P^n) \cong \mathbb{Z}/2\mathbb{Z}$, detected by the double-cover $S^n \to \mathbb{R}P^n$.

\paragraph{Lens spaces.}
The lens space $L(p, q)$ has $\pi_1(L(p,q)) \cong \mathbb{Z}/p\mathbb{Z}$, computed from the cyclic covering.

\paragraph{Mapping cylinders and mapping cones.}
For a map $f : A \to B$, the \emph{mapping cylinder} $M_f$ deformation-retracts onto $B$, hence $\pi_1(M_f) \cong \pi_1(B)$. The \emph{mapping cone} $C_f$ fits into the Seifert--van Kampen framework as a pushout, and its fundamental group is computed by the amalgamated free product with $\pi_1(A)$ quotiented by $f_*$.


%% ============================================================================
%% Chapter 8: Applications and Further Results
%% Part II of "The Algebra of Computational Paths"
%% ============================================================================

\section{Applications and Further Results}
\label{sec:applications}

\begin{remark}[Formalization status]
  This section condenses advanced applications from the Lean development.
  Core results on fibrations and covering spaces are fully formalized, while
  the Hurewicz and excision statements are partially scaffolded and the
  catalogued topics are stated with pointers to their Lean sources. See
  \cref{tab:formalization-status}.
\end{remark}

The algebraic and fundamental-group computations above are only the first
layer of the computational-paths program. In the full development, the same
rewrite-equality machinery supports the classical infrastructure of algebraic
topology: path lifting for fibrations, classification of coverings, long exact
sequences, and the comparison between homotopy and homology via Hurewicz.
We summarize the main theorems in this section, emphasizing statements and
Lean provenance rather than full proofs.

Throughout, a \emph{fibration} is presented by explicit path-lifting data
respecting rewrite equality. Homotopy groups are defined using iterated loop
quotients $\pi_n(X,x_0) = \PathQuot(\Omega^{n-1}(X,x_0))$, and homology is
computed from the cellular chain complexes induced by path-expression
attachments. We use classical notation, but all constructions are carried out
within the computational-paths framework and are mechanized in Lean.

\subsection{Fibrations and Covering Spaces}
\label{subsec:fibrations-coverings}

Let $p : E \to B$ be a fibration with fiber $F_b = \{ e : E \mid p(e) = b \}$.
The lifting data transport points and paths between fibers, giving an action
of $\pi_1(B,b_0)$ on $F_{b_0}$ and a homotopy-theoretic control over the
structure of $E$. The Lean formalization encodes the lifting operation as a
structure compatible with $\RwEq$, so that all transport maps are well defined
on the quotient $\PathQuot$.

\begin{theorem}[Path-lifting for fibrations]\label{thm:path-lifting}
Let $p : E \to B$ be a fibration, $b_0, b_1 : B$, and $e_0 : E$ with
$p(e_0) = b_0$. For every base path $\gamma : \Path_B(b_0, b_1)$ there exist
an endpoint $e_1 : E$ and a lifted path
$\tilde{\gamma} : \Path_E(e_0, e_1)$ such that
$p(\tilde{\gamma}) \rweq \gamma$. Any two lifts with the same endpoints are
related by $\RwEq$, so fiber transport is well defined on $\PathQuot$.
\end{theorem}

\begin{proof}[Proof sketch]
The lifting operation is part of the fibration structure in
\texttt{Fibration.lean}. One defines $\tilde{\gamma}$ by induction on the
path expression for $\gamma$, using the closure of lifting under $\symm$,
$\trans$, and congruence. Uniqueness up to $\RwEq$ follows from the defining
coherence of the lift structure, yielding a well-defined transport on
$\PathQuot$.
\end{proof}

Covering spaces are fibrations with discrete fibers and a strict uniqueness
of path lifts. The computational-paths setting makes the monodromy action
explicit, producing the classical classification by subgroups of the
fundamental group.

\begin{theorem}[Covering space classification]\label{thm:covering-classification}
Let $(X,x_0)$ be connected and let $\pi_1(X,x_0)$ be its computational-path
fundamental group. Connected covering spaces of $X$ are classified up to
equivalence by conjugacy classes of subgroups of $\pi_1(X,x_0)$. The
correspondence sends a covering $p : E \to X$ to the stabilizer of the
monodromy action on the fiber $p^{-1}(x_0)$.
\end{theorem}

\begin{proof}[Proof sketch]
The key ingredients are the unique-lifting property of coverings
(\texttt{CoveringSpace.lean}) and the explicit action of $\pi_1(X,x_0)$ on the
fiber, yielding subgroup data. Conversely, the construction of a covering
from a subgroup follows the classical universal cover argument, adapted to
path expressions. See \texttt{CoveringClassification.lean}.
\end{proof}

The lifting framework also yields the standard long exact sequence in
homotopy groups. We write $F$ for the fiber of $p$ over $b_0$ and choose
$e_0 : F$ as basepoint in $E$.

\begin{theorem}[Long exact sequence of a fibration]\label{thm:les-fibration}
For a pointed fibration $p : (E,e_0) \to (B,b_0)$ with fiber $F$, there is a
natural long exact sequence of homotopy groups
\[
  \cdots \to \pi_{n+1}(B,b_0) \xrightarrow{\partial}
  \pi_n(F,e_0) \to \pi_n(E,e_0) \to \pi_n(B,b_0)
  \to \pi_{n-1}(F,e_0) \to \cdots,
\]
exact at every stage for $n \geq 1$, with the $n=1$ terms forming a pointed
exact sequence of groups and sets.
\end{theorem}

\begin{proof}[Proof sketch]
The boundary map lifts a representative loop in $B$ to a path in $E$ and then
projects its endpoint into the fiber, using the path-lifting structure of
Theorem~\ref{thm:path-lifting}. Exactness is proved by explicit rewrite
normalization of lifted composites. The construction is formalized in
\texttt{LongExactSequence.lean}, and the Hopf fibration example appears in
\texttt{HopfFibration.lean}.
\end{proof}

Applying the long exact sequence to the Hopf fibration
$S^1 \hookrightarrow S^3 \to S^2$ yields $\pi_3(S^2) \cong \ZZ$ with its
generator represented by the lifted Hopf loop, recovering the classical
calculation inside the computational-paths framework.

\subsection{The Hurewicz Theorem}
\label{subsec:hurewicz}

To compare computational homotopy with homology, the library builds cellular
chain complexes from path-expression attachments and defines the Hurewicz map
as the quotient of loop concatenation by $\RwEq$. The key is that rewriting
identifies the same attaching spheres that appear in classical CW complexes,
allowing the standard inductive arguments to go through.

\begin{theorem}[Hurewicz]\label{thm:hurewicz}
Let $(X,x_0)$ be $(n-1)$-connected with $n \geq 2$. Then the Hurewicz map
\[
  h_n : \pi_n(X,x_0) \longrightarrow H_n(X;\ZZ)
\]
is an isomorphism, and $h_{n+1}$ is surjective. For $n=1$, the induced map
$\pi_1(X,x_0) \to H_1(X;\ZZ)$ is the abelianization.
\end{theorem}

\begin{proof}[Proof sketch]
The proof follows the classical cellular induction: the $(n-1)$-connectedness
forces vanishing of lower homology, so the Hurewicz map is detected on the
first nontrivial attaching sphere. The computational-paths version uses the
long exact sequence of the pair and explicit normalization in the loop
quotients. See \texttt{Hurewicz.lean} and \texttt{HurewiczTheorem.lean}.
\end{proof}

\subsection{Excision and Mayer--Vietoris}
\label{subsec:excision-mv}

Pushouts in the path-expression language support an excision principle for
homotopy and homology. The resulting Blakers--Massey statement plays the role
of excision for relative groups, and it feeds directly into the
Mayer--Vietoris sequence for unions.

\begin{theorem}[Excision / Blakers--Massey]\label{thm:blakers-massey}
Let $X = A \cup_C B$ be a pushout of pointed types where $C \to A$ is
$(m-1)$-connected and $C \to B$ is $(n-1)$-connected. Then the canonical map
from the homotopy pushout to $X$ is $(m+n-1)$-connected. In particular, the
relative homotopy groups satisfy excision:
\[
  \pi_k(A,C) \xrightarrow{\;\cong\;} \pi_k(X,B)
\]
for $k < m+n-1$, and the map is surjective for $k = m+n-1$.
\end{theorem}

\begin{proof}[Proof sketch]
The proof adapts the cubical and HoTT arguments to path expressions: the
connectivity hypotheses allow every relative loop to be rewritten into a word
that lies in a single summand, and the strip-lemma normalization provides the
required fillers. The formalization appears in \texttt{BlakersMassey.lean}.
\end{proof}

\begin{theorem}[Mayer--Vietoris sequence]\label{thm:mayer-vietoris}
Let $X = U \cup V$ be a union of pointed subtypes with $W = U \cap V$. There
is a long exact sequence in homology
\[
  \cdots \to H_n(W) \to H_n(U) \oplus H_n(V) \to H_n(X)
  \to H_{n-1}(W) \to \cdots,
\]
natural with respect to maps of covers and compatible with the connecting
homomorphism induced by the pushout boundary.
\end{theorem}

\begin{proof}[Proof sketch]
The chain complex for $X$ is modeled as a pushout of the chain complexes for
$U$ and $V$, using excision to identify the relative terms. The resulting
short exact sequence of complexes yields the long exact sequence in homology.
See \texttt{MayerVietoris.lean}.
\end{proof}

\subsection{A Catalog of Advanced Formalized Results}
\label{subsec:catalog-advanced}

Beyond the core applications above, the Lean library formalizes a range of
advanced results. We list representative theorems below with minimal context;
full statements and proofs can be found in the cited files.

\paragraph{Cobordism theory.}
\begin{theorem}[Thom--Pontryagin correspondence]\label{thm:thom-pontryagin}
Framed cobordism classes of closed $n$-manifolds are naturally identified
with the stable homotopy group $\pi_n^S$. The construction and its
computational-path formulation are in \texttt{CobordismTheory.lean}.
\end{theorem}
\begin{theorem}[Cobordism ring computation]\label{thm:cobordism-ring}
The oriented cobordism ring is computed via the Thom spectrum and described
by the standard polynomial generators used in classical topology. See
\texttt{CobordismRing.lean}.
\end{theorem}

\paragraph{K-theory and Bott periodicity.}
\begin{theorem}[Bott periodicity]\label{thm:bott}
For every space $X$, reduced topological $K$-theory is $2$-periodic:
$\widetilde{K}^{n+2}(X) \cong \widetilde{K}^n(X)$. The proof is formalized in
\texttt{BottPeriodicity.lean} and the underlying spectrum in
\texttt{KTheory.lean}.
\end{theorem}
\begin{theorem}[Algebraic $K$-theory of paths]\label{thm:alg-k-theory}
The algebraic $K$-theory of computational-path groupoids admits localization
and long exact sequences analogous to the classical Quillen--Thomason
framework. See \texttt{AlgebraicKTheoryPaths.lean}.
\end{theorem}

\paragraph{Spectral sequences.}
\begin{theorem}[Serre spectral sequence]\label{thm:serre-ss}
For a fibration $F \to E \to B$, there is a Serre spectral sequence
$E_2^{p,q} \cong H^p(B; H^q(F))$ converging to $H^{p+q}(E)$.
The construction appears in \texttt{SpectralSequence.lean}.
\end{theorem}
\begin{theorem}[Adams spectral sequence]\label{thm:adams-ss}
The Adams spectral sequence computes stable homotopy groups from the
Ext groups of the Steenrod algebra; its computational-paths realization is
formalized in \texttt{AdamsSpectralSequence.lean}.
\end{theorem}

\paragraph{Morse theory and handle decomposition.}
\begin{theorem}[Morse inequalities and handles]\label{thm:morse}
Smooth manifolds admit Morse functions whose critical points yield a handle
decomposition, and the resulting Morse complex computes homology. See
\texttt{MorseTheory.lean}, \texttt{MorseHomology.lean}, and
\texttt{HandleDecomposition.lean}.
\end{theorem}

\paragraph{Sheaf cohomology.}
\begin{theorem}[Sheafification and derived cohomology]\label{thm:sheaf-cohomology}
Sheafification is a left adjoint to the inclusion of sheaves into presheaves,
and the derived functors of global sections yield sheaf cohomology with the
expected long exact sequences. See \texttt{SheafificationPaths.lean},
\texttt{SheafCohomologyPaths.lean}, and \texttt{DerivedSheaves.lean}.
\end{theorem}

\paragraph{Stable homotopy theory.}
\begin{theorem}[Spectra and stable stems]\label{thm:stable-homotopy}
The library constructs the stable homotopy category via spectra and defines
stable homotopy groups as colimits of loop suspensions, including low-degree
stable stems. See \texttt{SpectrumTheory.lean}, \texttt{StableHomotopy.lean},
and \texttt{StableStems.lean}.
\end{theorem}

\paragraph{Model categories.}
\begin{theorem}[Model structures and Quillen adjunctions]\label{thm:model-category}
Computational-path spaces carry a Quillen model structure, and the fundamental
groupoid construction extends to a Quillen adjunction between path spaces and
groupoid-like models. See \texttt{ModelCategory.lean} and
\texttt{QuillenAdjunction.lean}.
\end{theorem}

\paragraph{Characteristic classes and vector bundles.}
\begin{theorem}[Characteristic classes]\label{thm:characteristic-classes}
Vector bundles and principal bundles admit characteristic classes with the
expected naturality and Whitney sum formulas, and principal bundles are
classified by maps into classifying spaces. See \texttt{VectorBundle.lean},
\texttt{PrincipalBundle.lean}, and \texttt{CharacteristicClass.lean}.
\end{theorem}

%% ============================================================================
%% Chapter 9: The Rewrite System: Metatheory
%% Part III of "The Algebra of Computational Paths"
%% ============================================================================

\section{The Rewrite System: Metatheory}
\label{ch:metatheory}

\begin{remark}[Formalization status]
  This section is fully formalized in Lean; all metatheoretic results and
  automation tools are mechanically verified. See
  \cref{tab:formalization-status}.
\end{remark}

In Section~\ref{ch:rewrite-system}, we introduced the 75-rule
rewrite system on computational paths, established its soundness,
normalization properties, termination, and confluence, and constructed
the quotient $\PathQuot$. In this chapter, we examine the rewrite system
from a \emph{metatheoretic} perspective: we situate it within the
framework of typed term rewriting, develop the syntactic path expression
language $\mathrm{PathExpr}$, analyze the strip lemma in detail, establish
the decidability of rewrite equality, describe a suite of tactics
for proof automation, and clarify the connection between
computational paths and the identity types of Homotopy Type Theory.

\subsection{The Typed Rewriting Perspective}
\label{sec:typed-rewriting}

\begin{definition}[Typed Rewriting System]\label{def:typed-trs}
  A \emph{typed term rewriting system} (typed TRS) consists of:
  \begin{enumerate}[label=(\roman*)]
    \item A set of \emph{sorts} (types), here the endpoint pairs $(a, b)$
      for $a, b : A$.
    \item A set of \emph{typed terms} (path expressions), well-typed by
      their source and target.
    \item A \emph{reduction relation} $\rew$ on terms of the same sort,
      given by the 75 rules of Section~\ref{ch:rewrite-system}.
  \end{enumerate}
  The rewrite system on $\Path_A(a, b)$ is thus a many-sorted first-order
  TRS in the sense of Klop~\cite{Klop92} and Terese~\cite{Terese03}, with
  sorts indexed by pairs of elements.
\end{definition}

\begin{remark}\label{rem:trs-features}
  Our TRS has several distinctive features compared to classical term
  rewriting:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Dependent sorts.} The sort of a path depends on its
      endpoints, which are themselves elements of the ambient type~$A$.
      Rules like associativity (Rule~\ref{rule:tt}) change the
      intermediate typing---$(p \comp q) \comp r$ has the same endpoints
      as $p \comp (q \comp r)$, but the subterms have different types.
    \item \textbf{Higher-order constructors.} The $\lamCongr$ and
      $\congrArgOp$ constructors take functions as arguments, making the
      system a \emph{higher-order} TRS in the sense of
      Nipkow~\cite{Nipkow91}.
    \item \textbf{Proof-irrelevant semantics.} While the syntactic terms
      (path expressions) are first-order or higher-order, the semantic
      interpretation collapses via $\toEq$ to the proof-irrelevant
      identity type. This separation between syntax and semantics is
      fundamental to the theory.
  \end{enumerate}
\end{remark}

\begin{definition}[The $\mathrm{LND}_{\mathrm{EQ}}$-TRS]\label{def:lndeq}
  The complete rewrite system is called the $\mathrm{LND}_{\mathrm{EQ}}$-TRS
  (following the terminology of~\cite{RDQO18}). The rules are enumerated
  using the mnemonic names of \cref{tab:lndeq-rules}.
\end{definition}

\begin{table}[ht]
\centering
\caption{The $\mathrm{LND}_{\mathrm{EQ}}$-TRS rule mnemonics and their
  correspondence to the constructors of the $\mathrm{Step}$ relation.}
\label{tab:lndeq-rules}
\small
\begin{tabular}{lllp{5.4cm}}
\toprule
\textbf{Mnemonic} & \textbf{Rule name} & \textbf{Group} & \textbf{Description} \\
\midrule
sr   & $\mathit{symm\_refl}$  & I   & $\inv{\refl} \rew \refl$ \\
ss   & $\mathit{symm\_symm}$  & I   & $\inv{(\inv{p})} \rew p$ \\
lrr  & $\mathit{trans\_refl\_left}$  & I & $\refl \comp p \rew p$ \\
rrr  & $\mathit{trans\_refl\_right}$ & I & $p \comp \refl \rew p$ \\
tr   & $\mathit{trans\_symm}$ & I   & $p \comp \inv{p} \rew \refl$ \\
tsr  & $\mathit{symm\_trans}$ & I   & $\inv{p} \comp p \rew \refl$ \\
stss & $\mathit{symm\_trans\_congr}$ & I & $\inv{(p \comp q)} \rew \inv{q} \comp \inv{p}$ \\
tt   & $\mathit{trans\_assoc}$ & I  & $(p \comp q) \comp r \rew p \comp (q \comp r)$ \\
\midrule
mx2l1 & $\mathit{map2\_subst}$ & II & $\mapTwo$ factorization \\
mx2l2--mx2r2 & $\mathit{prod\_\beta}$ & II & Product $\beta$-rules \\
mxetaProd & $\mathit{prod\_\eta}$ & II & Product $\eta$-rule \\
mxsigmaFst/Snd & $\mathit{sigma\_\beta}$ & II & $\Sigma$-type $\beta$-rules \\
mxetaSigma & $\mathit{sigma\_\eta}$ & II & $\Sigma$-type $\eta$-rule \\
mxcase & $\mathit{sum\_rec\_\beta}$ & II & Sum $\beta$-rules \\
mxetaFun & $\mathit{fun\_\eta}$ & II & Function $\eta$-rule \\
mxlam & $\mathit{fun\_app\_\beta}$ & II & Function $\beta$-rule \\
\midrule
slr/srr & $\mathit{ctx\_subst\_refl}$ & IV & Context unit rules \\
slss/srsr & $\mathit{ctx\_subst\_idempotent}$ & IV & Context idempotence \\
tsbll/tsbrl & $\mathit{ctx\_subst\_\beta}$ & IV & Context $\beta$-rules \\
tsblr/tsbrr & $\mathit{ctx\_subst\_assoc}$ & IV & Context associativity \\
ttsv/tstu & $\mathit{ctx\_cancel}$ & IV & Context cancellation \\
\bottomrule
\end{tabular}
\end{table}

The precedence ranking assigns each rule a natural number via the function
$\mathrm{rank} : \mathrm{Rule} \to \Nat$ (defined in the formalization). The ranking
is compatible with the termination ordering: rules producing simpler
expressions receive lower ranks.

\subsection{PathExpr: A First-Order Term Language}
\label{sec:pathexpr}

While the type $\Path_A(a, b)$ is a \emph{record} (a list of steps paired
with a proof), reasoning about rewrites requires a \emph{syntactic}
representation of path expressions. The $\mathrm{PathExpr}$ type provides
this.

\begin{definition}[Path Expression]\label{def:pathexpr}
  The type $\mathrm{PathExpr}_{A}(a, b)$ is an inductive type with
  constructors:
  \begin{align*}
    \mathrm{atom} &: \Path_A(a, b) \to \mathrm{PathExpr}_A(a, b), \\
    \refl &: (a : A) \to \mathrm{PathExpr}_A(a, a), \\
    \mathrm{symm} &: \mathrm{PathExpr}_A(a, b) \to \mathrm{PathExpr}_A(b, a), \\
    \mathrm{trans} &: \mathrm{PathExpr}_A(a, b) \to \mathrm{PathExpr}_A(b, c)
      \to \mathrm{PathExpr}_A(a, c), \\
    \congrArgOp &: (f : A \to B) \to \mathrm{PathExpr}_A(a, b)
      \to \mathrm{PathExpr}_B(f(a), f(b)), \\
    \mapTwo &: (f : A \to B \to C) \to \mathrm{PathExpr}_A(a_1, a_2)
      \to \mathrm{PathExpr}_B(b_1, b_2) \\
      &\qquad\qquad\qquad\qquad\quad
      \to \mathrm{PathExpr}_C(f\,a_1\,b_1,\; f\,a_2\,b_2), \\
    \mathrm{context\_map} &: \Context(A, B) \to \mathrm{PathExpr}_A(a, b)
      \to \mathrm{PathExpr}_B(C(a), C(b)), \\
    \mathrm{context\_subst\_left} &: \Context(A, B)
      \to \mathrm{PathExpr}_B(x, C(a_1))
      \to \mathrm{PathExpr}_A(a_1, a_2) \\
      &\qquad\qquad\qquad\qquad\quad
      \to \mathrm{PathExpr}_B(x, C(a_2)), \\
    \mathrm{context\_subst\_right} &: \Context(A, B)
      \to \mathrm{PathExpr}_A(a_1, a_2)
      \to \mathrm{PathExpr}_B(C(a_2), y) \\
      &\qquad\qquad\qquad\qquad\quad
      \to \mathrm{PathExpr}_B(C(a_1), y).
  \end{align*}
\end{definition}

The key property of $\mathrm{PathExpr}$ is that it separates the
\emph{syntactic structure} of a path from its \emph{semantic content}.

\begin{definition}[Evaluation]\label{def:pathexpr-eval}
  The \emph{evaluation function}
  $\mathrm{eval} : \mathrm{PathExpr}_A(a, b) \to \Path_A(a, b)$
  interprets each constructor by the corresponding path operation:
  \begin{align*}
    \mathrm{eval}(\mathrm{atom}(p)) &= p, \\
    \mathrm{eval}(\refl(a)) &= \refl(a), \\
    \mathrm{eval}(\mathrm{symm}(e)) &= \mathrm{symm}(\mathrm{eval}(e)), \\
    \mathrm{eval}(\mathrm{trans}(e_1, e_2)) &= \mathrm{trans}(\mathrm{eval}(e_1),
      \mathrm{eval}(e_2)),
  \end{align*}
  and similarly for the remaining constructors.
\end{definition}

\begin{definition}[Size Measure]\label{def:pathexpr-size}
  The \emph{size} of a path expression is defined recursively:
  \begin{align*}
    \mathrm{size}(\mathrm{atom}(p)) &= 1, \qquad
    \mathrm{size}(\refl(a)) = 1, \\
    \mathrm{size}(\mathrm{symm}(e)) &= \mathrm{size}(e) + 1, \\
    \mathrm{size}(\mathrm{trans}(e_1, e_2)) &= \mathrm{size}(e_1)
      + \mathrm{size}(e_2) + 1,
  \end{align*}
  and analogously for the remaining constructors. The size provides a
  termination measure for recursive functions on path expressions.
\end{definition}

\subsubsection{Rewriting on PathExpr}

The single-step and multi-step rewrite relations lift from $\Path$ to
$\mathrm{PathExpr}$, with the same 75 rules applied syntactically. The
critical property is that evaluation commutes with rewriting:

\begin{theorem}[Evaluation Preserves Rewriting]\label{thm:eval-rw}
  If $e_1 \rew e_2$ as path expressions, then
  $\mathrm{eval}(e_1) \rew \mathrm{eval}(e_2)$ as paths (or
  $\mathrm{eval}(e_1) \rweq \mathrm{eval}(e_2)$).
\end{theorem}

\begin{proof}
  By induction on the derivation of $e_1 \rew e_2$. Each syntactic rule
  application maps to the corresponding semantic rule via $\mathrm{eval}$.
\end{proof}

\subsubsection{Confluence of PathExpr}

The main payoff of the $\mathrm{PathExpr}$ language is that confluence can
be stated and proved at the syntactic level, then transferred to $\Path$.

\begin{definition}[Join for PathExpr]\label{def:pathexpr-join}
  A \emph{join} of path expressions $e_1$ and $e_2$ is a triple
  $(m, h_1, h_2)$ where $m$ is a path expression, $h_1 : e_1 \rews m$,
  and $h_2 : e_2 \rews m$.
\end{definition}

\begin{theorem}[PathExpr Confluence]\label{thm:pathexpr-confluence}
  The rewrite system on $\mathrm{PathExpr}$ is confluent: for any
  $e_1 \rews e$ and $e_2 \rews e$ (or, equivalently, any two rewrites
  from a common source), explicit join witnesses can be computed by the
  reduction strategy.
\end{theorem}

The formalization packages this result as the \emph{join-of-rewrite}
interface, which provides:
\[
  \mathrm{joinRw} : \Rw(p, q) \to \Rw(p, r) \to
  \mathrm{Join}(q, r),
\]
where the join includes an explicit meet term and the two reduction
certificates.

\begin{corollary}[Confluence Transfer]\label{cor:confluence-transfer}
  The confluence of $\mathrm{PathExpr}$ rewrites transfers to
  $\Path$-level joins: if $\Rw(\mathrm{eval}(e), p)$ and
  $\Rw(\mathrm{eval}(e), q)$, then $p$ and $q$ have a common reduct.
\end{corollary}

\begin{proof}
  Apply $\mathrm{eval}$ to the $\mathrm{PathExpr}$-level join and use
  \cref{thm:eval-rw}.
\end{proof}

\subsection{The Strip Lemma and Local Confluence in Detail}
\label{sec:strip-detail}

The strip lemma (\cref{thm:strip-lemma}) is the technical heart of the
confluence proof. We now describe its structure in more detail.

\begin{theorem}[Strip Lemma, Detailed]\label{thm:strip-detailed}
  Let $p \rew q$ (a single step) and $p \rews r$ (a multi-step
  reduction). Then there exists a path $m$ with $q \rews m$ and
  $r \rews m$. The proof proceeds by induction on the length of
  $p \rews r$:
  \begin{enumerate}[label=(\roman*)]
    \item \textbf{Base case} ($r = p$): take $m = q$.
    \item \textbf{Inductive case} ($p \rews r'$ and $r' \rew r$):
      by the induction hypothesis applied to $p \rew q$ and $p \rews r'$,
      obtain a join $m'$ of $q$ and $r'$. Then analyze the critical pair
      $(m' \leftarrow r' \rew r)$ to produce the final join~$m$.
  \end{enumerate}
\end{theorem}

\subsubsection{Critical Pair Analysis}

The critical pairs of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS arise when
two rules overlap---i.e., the left-hand side of one rule is a subterm of
the left-hand side of another, or the same term matches two distinct rules.

\begin{definition}[Critical Pair]\label{def:critical-pair}
  A \emph{critical pair} is a pair $(q_1, q_2)$ of paths obtained by
  applying two different rules (or the same rule at two different
  positions) to a common redex $p$, yielding $p \rew q_1$ and
  $p \rew q_2$.
\end{definition}

The 75 rules generate a finite (though large) set of critical pairs.
The principal families of critical pairs are:

\begin{enumerate}[label=(\arabic*)]
  \item \textbf{Associativity--unit overlap.}\;
    The term $(p \comp \refl) \comp r$ matches both Rule~\ref{rule:rrr}
    (reducing to $p \comp r$) and Rule~\ref{rule:tt} (reducing to
    $p \comp (\refl \comp r)$). The latter then reduces by
    Rule~\ref{rule:lrr} to $p \comp r$. The join is $p \comp r$.

  \item \textbf{Associativity--inverse overlap.}\;
    The term $(p \comp \inv{p}) \comp r$ matches both Rule~\ref{rule:tr}
    composed with Rule~\ref{rule:lrr} (reducing to $r$) and
    Rule~\ref{rule:tt} (reducing to $p \comp (\inv{p} \comp r)$). The
    latter further reduces by the inverse law and left unit.

  \item \textbf{Product $\beta$--$\eta$ overlap.}\;
    The term $\prodMk(\fst(r), \snd(r))$ where $r = \prodMk(p, q)$:
    applying $\eta$ first gives $r = \prodMk(p, q)$; applying $\beta$ to
    each component gives $\prodMk(p, q)$.

  \item \textbf{Context--structural overlap.}\;
    A context substitution $\substL(C, r, p)$ where $p \rew p'$: the
    structural rule and the context-specific rule may both apply. The
    joins are produced via the context congruence property.

  \item \textbf{Symmetry--composition overlap.}\;
    The term $\inv{(p \comp \refl)}$ matches both Rule~\ref{rule:rrr}
    (under symmetry congruence, giving $\inv{p}$) and
    Rule~\ref{rule:stss} (giving $\inv{\refl} \comp \inv{p}$, which
    reduces to $\refl \comp \inv{p}$ and then to $\inv{p}$).
\end{enumerate}

\begin{proposition}[All Critical Pairs are Joinable]\label{prop:critical-pairs}
  Every critical pair $(q_1, q_2)$ of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS
  is joinable: there exists $m$ with $q_1 \rews m$ and $q_2 \rews m$.
  The join witnesses are explicitly constructed in the formalization.
\end{proposition}

\begin{proof}
  By exhaustive case analysis. The formalization covers all cases, with each
  critical pair resolved by exhibiting a concrete join term and the
  reduction sequences reaching it.
\end{proof}

\begin{theorem}[Constructive Confluence]\label{thm:constructive-confluence}
  The confluence proof is \emph{constructive}: given two multi-step
  reductions from a common source, the join witness (the common reduct
  together with both reduction sequences) is computable. The
  formalization encapsulates this as an algebraic interface that, given
  any two multi-step reductions from a common source, produces the join
  witness.
\end{theorem}

\subsection{Decidability and the Path Tactic}
\label{sec:decidability}

\begin{theorem}[Decidability of $\RwEq$]\label{thm:rweq-decidable}
  Rewrite equality of computational paths is decidable: there is an
  algorithm that, given paths $p, q : \Path_A(a, b)$, determines whether
  $p \rweq q$.
\end{theorem}

\begin{proof}
  By \cref{thm:normalization}(iii), $p \rweq q$ if and only if
  $\normalize(p) = \normalize(q)$. Since $\normalize(p) = \ofEq(\toEq(p))$
  and $\normalize(q) = \ofEq(\toEq(q))$, equality of the normal forms
  reduces to equality of the underlying propositional equalities
  $\toEq(p)$ and $\toEq(q)$, which are equal by proof irrelevance.
  Thus $p \rweq q$ holds for \emph{all} paths with the same endpoints,
  and the decision procedure is trivial: always return ``yes.''
\end{proof}

\begin{remark}\label{rem:trivial-decidability}
  The triviality of the decision procedure is a consequence of proof
  irrelevance in the ambient type theory. In an intensional type theory
  without UIP (such as the core of HoTT), $\RwEq$-equivalence would be a
  genuinely non-trivial decision problem. In our setting, the interest
  lies not in the \emph{decision} but in the \emph{witnesses}: the
  explicit rewrite sequences connecting $p$ to its normal form.
\end{remark}

\subsubsection{The Path Simplification Tactic}

The formalization provides a suite of tactics for automating
proofs involving rewrite equality:

\begin{definition}[Path Tactics]\label{def:path-tactics}
  The following tactics are provided for reasoning about $\RwEq$:
  \begin{itemize}
    \item \emph{Reflexivity} ($\mathit{path\_rfl}$): closes $\RwEq$ goals that are reflexive
      ($p \rweq p$), via $\RwEq.\refl$.
    \item \emph{Symmetry} ($\mathit{path\_symm}$): transforms a goal $p \rweq q$ into
      $q \rweq p$, via $\RwEq.\mathrm{symm}$.
    \item \emph{Simplification} ($\mathit{path\_simp}$): applies the simplification
      procedure with the library of $\RwEq$ lemmas (all 75 rules and their
      derived consequences are registered as simplification lemmas).
    \item \emph{Transitivity} ($\mathit{path\_trans}$): applies transitivity with an
      intermediate path from a given hypothesis.
    \item \emph{Congruence} ($\mathit{path\_congr\_left}$/$\mathit{path\_congr\_right}$):
      applies the congruence property of $\mathrm{trans}$ in the left or
      right argument.
    \item \emph{Associativity} ($\mathit{path\_assoc}$): reassociates $\mathrm{trans}$ chains to
      the right.
    \item \emph{Canonicalization} ($\mathit{path\_canon}$): closes
      goals by reducing both sides to $\ofEq$.
  \end{itemize}
\end{definition}

\begin{example}
  The path simplification tactic automates routine rewrite-equality
  reasoning. For instance, the identity $\refl(a) \comp p \rweq p$
  is closed immediately by simplification (applying the left-unit
  rule), and a congruence goal
  $p \rweq q \;\implies\; p \comp r \rweq q \comp r$
  is resolved by the left-congruence tactic.
\end{example}

\subsection{Connection to HoTT Identity Types}
\label{sec:hott-connection}

The computational paths framework has a precise relationship with
the identity types of Homotopy Type Theory.

\begin{theorem}[J-Elimination]\label{thm:j-elim}
  The computational path structure satisfies the $J$-elimination rule
  (path induction): for any type family
  $D : \Pi_{a,b : A}.\, \Path_A(a, b) \to \Type$ and any
  $d : \Pi_{a : A}.\, D(a, a, \refl(a))$, there exists
  \[
    J(D, d) : \Pi_{a, b : A}.\, \Pi_{p : \Path_A(a,b)}.\, D(a, b, p).
  \]
\end{theorem}

\begin{proof}
  Define $J(D, d, a, b, p) = \mathrm{transport}_D(p, d(a))$, where the
  transport is along the path from $(a, a, \refl(a))$ to $(a, b, p)$
  induced by the underlying equality $\toEq(p) : a =_A b$.
\end{proof}

\begin{theorem}[Function Extensionality]\label{thm:funext}
  For functions $f, g : A \to B$, if $h : \Pi_{x : A}.\, \Path_B(f(x), g(x))$
  (a pointwise path), then there exists a path
  $\mathrm{funext}(h) : \Path_{A \to B}(f, g)$.
\end{theorem}

\begin{proof}
  Construct $\mathrm{funext}(h) = \lamCongr(h)$, the function congruence
  path. Its trace records the pointwise rewrite sequence; its proof field
  is the propositional function extensionality of the ambient theory.
\end{proof}

\begin{theorem}[HoTT Compatibility]\label{thm:hott-compat}
  The path quotient $\PathQuot_A(a, b)$ is equivalent (as a type) to the
  propositional identity type $a =_A b$
  (Theorem~\ref{thm:quot-equiv}). Under this equivalence:
  \begin{enumerate}[label=(\roman*)]
    \item Path composition corresponds to transitivity of equality.
    \item Path inversion corresponds to symmetry.
    \item Congruence corresponds to $\mathrm{ap}$ (the action on paths).
    \item Transport corresponds to $\mathrm{transport}$.
    \item The $J$-rule (\cref{thm:j-elim}) corresponds to the standard
      $J$-eliminator.
  \end{enumerate}
\end{theorem}

\begin{remark}[The Univalence Question]\label{rem:univalence}
  The computational paths framework does \emph{not} require the
  univalence axiom or higher inductive types (HITs) as primitive axioms.
  Instead:
  \begin{itemize}
    \item The higher-dimensional structure (weak $\omega$-groupoid) is
      \emph{derived} from the rewrite system on traces, not postulated.
    \item Non-trivial fundamental groups arise from the path expression
      calculus (formal generators and relations), not from HITs.
    \item The contractibility at dimension~$\geq 3$
      (\cref{thm:contract3}) is a \emph{consequence} of proof irrelevance,
      not an axiom.
  \end{itemize}
  This provides a complementary approach to HoTT: where HoTT enriches
  the identity type by rejecting UIP, computational paths enrich the
  \emph{computational content} of equality proofs while retaining UIP at
  the propositional level.
\end{remark}

\subsection{Organization and Dependency Structure}
\label{sec:module-organization}

The metatheoretic results are organized across the following components
in the formalization:

\begin{center}
\small
\begin{tabular}{lp{7.5cm}}
\toprule
\textbf{Component} & \textbf{Contents} \\
\midrule
Step definitions & The 75-rule $\mathrm{Step}$ relation and soundness proof \\
Multi-step closure & Reflexive--transitive closure $\Rw$ \\
Rewrite equality & Rewrite equality $\RwEq$ and all congruence lemmas \\
Normalization & Normal forms and the $\normalize$ function \\
Rule enumeration & Rule enumeration and mnemonic names \\
Termination & Rule precedence and RPO measure \\
Strip lemma & The strip lemma (local confluence) \\
Confluence & Join structure and the join-of-rewrite interface \\
Confluence witnesses & Concrete join witnesses \\
Full confluence & Full confluence theorem \\
Constructive confluence & Constructive confluence certificates \\
Path expressions & Syntactic path expressions \\
Expression confluence & Join-of-rewrite for path expressions \\
Expression--path transfer & Confluence transfer to $\Path$ \\
Path tactics & The path simplification tactic suite \\
Quotient & The quotient $\PathQuot$ and its operations \\
Equivalence & Equivalence $\PathQuot \simeq \mathrm{Eq}$ \\
Minimal axioms & Minimal axiom sets for the TRS \\
\bottomrule
\end{tabular}
\end{center}

The logical dependency chain for the full metatheory is:
\[
  \mathrm{Step} \to \mathrm{Rw} \to \mathrm{RwEq} \to
  \mathrm{Normalization} \to \mathrm{Termination} \to
  \text{Strip Lemma} \to \mathrm{Confluence} \to \mathrm{Quot}.
\]
The $\mathrm{PathExpr}$ branch runs in parallel:
\[
  \mathrm{PathExpr} \to \text{Expression Confluence} \to
  \text{Expression--Path Transfer},
\]
joining the main branch at the confluence level.


%%%% Converted from chapters/ch12_conclusion.tex (book→article) %%%%

% ============================================================================
% Chapter 10: Conclusion and Future Directions
% Part III of "The Algebra of Computational Paths"
% ============================================================================
\section{Conclusion and Future Directions}
\label{ch:conclusion}

\subsection{Summary of Contributions}
\label{sec:summary}

This paper has developed a comprehensive mathematical theory of
\emph{computational paths}---a framework in which propositional
equalities carry explicit rewrite traces recording the computational
steps by which they were derived. The principal contributions are:

\paragraph{A complete algebraic framework.}
Starting from the definition of a computational path as a pair
$(s, \pi)$ of a step list and a propositional equality
(\cref{def:path}), we constructed the full path algebra: reflexivity,
symmetry, transitivity, congruence, transport, dependent application,
and operations for products, sums, dependent pairs, and function types
(Section~\ref{sec:basic-constructions}). The key insight is that even in a
proof-irrelevant setting where UIP holds for $\Eq$, the computational
traces are distinct combinatorial objects that support a rich algebraic
structure (\cref{thm:non-uip}).

\paragraph{A confluent, terminating rewrite system.}
The 75 rules of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS
(Section~\ref{ch:rewrite-system}), organized into eight groups---path
algebra, type-former $\beta$/$\eta$-rules, transport, contexts,
dependent contexts, bi-contexts, map congruence, and structural
closure---axiomatize the identities that do not hold strictly on
computational traces. We proved soundness
(\cref{thm:step-sound}), termination (\cref{thm:termination}),
local confluence via the strip lemma (\cref{thm:strip-lemma}),
and global confluence via Newman's lemma (\cref{thm:confluence}).
The quotient $\PathQuot$ by rewrite equality recovers the standard
identity type (\cref{thm:quot-equiv}).

\paragraph{Weak $\omega$-groupoid structure.}
The tower of iterated derivation cells---paths, derivations between
paths, meta-derivations between derivations, and so on---forms a weak
$\omega$-groupoid in the sense of Batanin--Leinster
(\cref{thm:omega-groupoid}), with contractibility beginning at
dimension~3 (\cref{thm:contract3}). This threshold is critical: it
preserves non-trivial fundamental groups while ensuring that all
higher coherence conditions are automatically satisfied via proof
irrelevance (\cref{rem:contract-threshold}).

\paragraph{Comprehensive homotopy theory.}
Building on the algebraic foundations, we developed:
\begin{itemize}
  \item Fundamental groups and their functoriality
    (Section~\ref{sec:fundamental-groups}), including the product formula,
    Eckmann--Hilton argument, and basepoint independence.
  \item Computations of $\pi_1$ for standard spaces
    (Section~\ref{sec:spaces}): the circle ($\pi_1 \cong \ZZ$), torus
    ($\ZZ \times \ZZ$), figure-eight ($\ZZ * \ZZ$), Klein bottle,
    projective spaces, lens spaces, and bouquets.
  \item The Seifert--van Kampen theorem for pushouts
    (\cref{thm:svk}), yielding $\pi_1$ of wedge sums and
    amalgamated free products.
  \item Applications and further results
    (Section~\ref{sec:applications}), including fibration and covering-space
    theory, the Hurewicz theorem, excision and Mayer--Vietoris, and a catalog
    of advanced formalized constructions.
\end{itemize}

\paragraph{Metatheory and automation.}
The syntactic path expression language $\mathrm{PathExpr}$
(Section~\ref{ch:metatheory}) enables constructive confluence proofs
with explicit join witnesses. A dedicated tactic suite
automates rewrite-equality reasoning.

\subsection{The Formalization}
\label{sec:formalization}

The entire development is mechanically verified in the Lean~4 proof assistant, comprising:

\medskip
\begin{center}
\fbox{\parbox{0.9\linewidth}{\centering\textbf{Lean~4 formalization repository:} \url{https://github.com/Arthur742Ramos/ComputationalPathsLean}}}
\end{center}
\medskip

\begin{center}
\begin{tabular}{lr}
\toprule
\textbf{Metric} & \textbf{Count} \\
\midrule
Source files & 380 \\
Total lines of code & 76,260 \\
Definitions & 1,710 \\
Theorems & 885 \\
Structures & 701 \\
Inductive types & 69 \\
\bottomrule
\end{tabular}
\end{center}

\medskip

\noindent
\cref{tab:formalization-status} summarizes the verification status of
the principal results across all sections.

\begin{table}[p]
\centering
\caption{Formalization status of principal results. \emph{FF}: Fully
  Formalized (statement and proof checked). \emph{PS}: Partially
  Scaffolded (definitions formalized, some proofs admitted). \emph{SO}:
  Statement Only (proof body deferred).}
\label{tab:formalization-status}
\footnotesize
\begin{tabular}{lll}
\toprule
\textbf{Result} & \textbf{Section} & \textbf{Status} \\
\midrule
Non-UIP for Paths (Thm.~1.7) & \S\ref{sec:introduction} & FF \\
Strict Monoid Laws (Thm.~2.4) & \S\ref{sec:basic-constructions} & FF \\
Functoriality of Congruence (Thm.~2.8) & \S\ref{sec:basic-constructions} & FF \\
Product/Sigma/Sum/Fun $\beta\eta$ & \S\ref{sec:basic-constructions} & FF \\
Transport Laws (Thm.~2.18) & \S\ref{sec:basic-constructions} & FF \\
Soundness (Thm.~3.3) & \S\ref{ch:rewrite-system} & FF \\
Normalization (Thm.~3.8) & \S\ref{ch:rewrite-system} & FF \\
Termination (Thm.~3.10) & \S\ref{ch:rewrite-system} & FF \\
Strip Lemma / Confluence (Thm.~3.14--3.15) & \S\ref{ch:rewrite-system} & FF \\
Weak / Strict Groupoid (Thm.~4.3, 4.7) & \S\ref{ch:groupoid} & FF \\
Rewrite Lifts (Thm.~4.10) & \S\ref{ch:groupoid} & FF \\
Weak Bicategory (Thm.~5.7) & \S\ref{ch:higher-dimensional} & FF \\
Contractibility at Dim~$\geq 3$ (Thm.~5.11) & \S\ref{ch:higher-dimensional} & FF \\
$\omega$-Groupoid (Thm.~5.16) & \S\ref{ch:higher-dimensional} & FF \\
\midrule
$\pi_1$ Group Axioms (Thm.~6.3) & \S\ref{sec:fundamental-groups} & FF \\
Induced Homomorphism (Thm.~6.6) & \S\ref{sec:fundamental-groups} & FF \\
Product Formula / Eckmann--Hilton (Thm.~6.8, 6.10) & \S\ref{sec:fundamental-groups} & FF \\
Fundamental Groupoid (Thm.~6.15) & \S\ref{sec:fundamental-groups} & FF \\
$\pi_1(S^1) \cong \ZZ$ (Thm.~7.4) & \S\ref{sec:spaces} & FF \\
$\pi_1(T^2) \cong \ZZ\times\ZZ$ (Thm.~7.6) & \S\ref{sec:spaces} & FF \\
$\pi_1(S^1 \vee S^1) \cong \ZZ * \ZZ$ (Thm.~7.8) & \S\ref{sec:spaces} & PS \\
Seifert--van Kampen (Thm.~7.14) & \S\ref{sec:spaces} & PS \\
$\pi_1(\Sigma X) = 0$ (Thm.~7.16) & \S\ref{sec:spaces} & PS \\
\midrule
Path-Lifting for Fibrations (Thm.~8.1) & \S\ref{sec:applications} & FF \\
Covering Space Classification (Thm.~8.2) & \S\ref{sec:applications} & FF \\
Long Exact Sequence (Thm.~8.3) & \S\ref{sec:applications} & FF \\
Hurewicz Theorem (Thm.~8.4) & \S\ref{sec:applications} & PS \\
Excision / Blakers--Massey (Thm.~8.5) & \S\ref{sec:applications} & PS \\
Mayer--Vietoris (Thm.~8.6) & \S\ref{sec:applications} & PS \\
\midrule
Decidability of $\RwEq$ (Thm.~9.8) & \S\ref{ch:metatheory} & FF \\
$J$-Elimination (Thm.~9.11) & \S\ref{ch:metatheory} & FF \\
HoTT Compatibility (Thm.~9.13) & \S\ref{ch:metatheory} & FF \\
\bottomrule
\end{tabular}
\end{table}

\paragraph{Design decisions.}
Several design choices shaped the formalization:
\begin{enumerate}[label=(\roman*)]
  \item \textbf{Path as record, not inductive.} Computational paths are
    represented as records (a step list plus a proof), not as an inductive
    family. This makes the monoid laws (left/right unit, associativity)
    hold definitionally---a significant advantage for proof ergonomics.
  \item \textbf{Step as an inductive proposition.} The single-step
    rewrite relation $\Step$ is defined as an inductive type in $\Prop$,
    making it proof-irrelevant. This simplifies the higher-dimensional
    theory: two-cells and above are automatically well-behaved.
  \item \textbf{Quotient types for the fundamental group.} The quotient
    $\PathQuot$ uses the ambient theory's built-in quotient type, ensuring that the
    fundamental group inherits decidable equality and supports the
    universal property of quotients.
  \item \textbf{Interface-based confluence.} The confluence interface
    is organized as an algebraic structure, allowing different confluence
    strategies (constructive, classical, syntactic) to be plugged in
    transparently.
  \item \textbf{Universe polymorphism.} The entire development is
    universe-polymorphic, with $\Path$, $\Step$, $\Rw$, $\RwEq$, and
    $\PathQuot$ defined at universe level~$u$.
\end{enumerate}

\paragraph{Proof automation.}
The path simplification tactic (Section~\ref{sec:decidability}) proved
essential for managing the combinatorial complexity of the rewrite system.
With the rules from Section~\ref{ch:rewrite-system} and their congruence
variants registered as simplification lemmas, the tactic resolves most
$\RwEq$ goals automatically. For more complex goals, the dedicated tactics
(transitivity, left/right congruence, associativity) provide fine-grained
control.

\paragraph{Formalization structure.}
The formalization is organized into a hierarchy reflecting the paper's
structure:
\begin{itemize}
  \item \emph{Path foundations}: paths, steps, fundamental operations,
    contexts.
  \item \emph{Rewriting}: the TRS, confluence, normalization,
    quotient.
  \item \emph{Groupoid theory}: weak and strict groupoid structures,
    rewrite lifts.
  \item \emph{Higher-dimensional structure}: globular tower, derivation cells,
    $\omega$-groupoid.
  \item \emph{Homotopy theory}: fundamental groups, loop spaces, spaces.
  \item \emph{Fibrations}: fibrations, covering spaces, exact sequences.
  \item \emph{Homological algebra}: abelianization, Hurewicz, spectral sequences.
  \item \emph{Advanced topics}: Eilenberg--MacLane, Postnikov, operads,
    K-theory.
\end{itemize}

A complete dependency graph is available in the online repository.

\subsection{Future Directions}
\label{sec:future}

Several natural extensions of this work are under investigation:

\paragraph{Cubical computational paths.}
The current framework uses \emph{list-based} traces (sequences of
elementary steps). An alternative representation uses
\emph{cubical} traces, where a path in dimension~$n$ is an $n$-cube
with specified boundary. This would align computational paths more
closely with cubical type theory~\cite{BeCH14}, while retaining the
rewrite-based computational content. The key challenge is defining the
appropriate notion of ``cubical step'' and establishing confluence for
the resulting system.

\paragraph{Machine-checked higher-categorical coherence.}
While contractibility at dimension~$\geq 3$ is established
(\cref{thm:contract3}), the explicit coherence data at dimension~2
(pentagon, triangle, interchange) is only verified via proof
irrelevance. A finer analysis---producing explicit derivation witnesses
for each coherence law without appealing to proof irrelevance---would
yield a fully constructive weak 2-category structure, potentially
useful in settings without proof irrelevance.

\paragraph{Computational content extraction.}
The rewrite traces carried by computational paths contain
\emph{algorithmic information}: the sequence of rewrites encodes a
proof strategy. Extracting this information systematically could yield:
\begin{itemize}
  \item Certified program transformations guided by equality proofs.
  \item Optimization strategies based on trace analysis (e.g.,
    detecting redundant steps, finding shorter traces).
  \item Connections to cost semantics and complexity of equational
    reasoning.
\end{itemize}

\paragraph{Applications to automated reasoning.}
The $\mathrm{LND}_{\mathrm{EQ}}$-TRS is a self-contained equational
theory with good metatheoretic properties (confluent, terminating,
decidable). It could serve as a decision procedure kernel for
automated theorem provers dealing with equality reasoning in
dependent type theories.

\paragraph{Connections to higher-dimensional rewriting.}
The rewrite rules on paths are themselves generators of 2-cells
(derivations), and the critical-pair analysis produces 3-cells. This
is an instance of Squier's theory~\cite{Squier94} of higher-dimensional
rewriting, where the homotopical properties of a rewrite system
(e.g., finite derivation type) are captured by higher-dimensional
cells. Establishing a precise connection between the
$\mathrm{LND}_{\mathrm{EQ}}$-TRS and Squier's framework would link
computational paths to the broader program of higher-dimensional
algebra.

\paragraph{Synthetic homotopy theory.}
The computational-paths approach provides a new setting for
\emph{synthetic} homotopy theory---developing homotopy theory directly
from the algebraic structure of paths, without reference to topological
spaces. Extending the current development to cover more of synthetic
homotopy theory (e.g., Blakers--Massey, the James construction, the
Hopf invariant) would demonstrate the power of the framework.

\paragraph{Scaling the formalization.}
The current formalization of 76,260 lines covers a substantial portion
of basic algebraic topology. Scaling to more advanced topics
(e.g., stable homotopy theory, chromatic homotopy theory, derived
algebraic geometry) will require:
\begin{itemize}
  \item More sophisticated automation (e.g., a dedicated tactic for
    spectral sequence computations).
  \item Better library management and modular design patterns.
  \item Potential integration with existing formalized mathematics libraries
    for the algebraic prerequisites.
\end{itemize}

\bigskip

\noindent
In summary, computational paths offer a distinctive perspective on the
algebra of equality: by recording \emph{how} an equality was derived
(not just \emph{that} it holds), we recover higher-dimensional structure
in a proof-irrelevant setting, build a complete homotopy theory with
explicit combinatorial foundations, and provide a framework where all
coherence conditions are either computationally verified or automatically
satisfied. The mechanized formalization demonstrates that this program can
be carried out rigorously and at scale.


%%%% Appendix %%%%

% ============================================================================
% Appendix A: Complete List of Rewrite Rules
% ============================================================================
\section{Complete List of Rewrite Rules}
\label{app:rules}

We list all 75 rewrite rules of the $\mathrm{LND}_{\mathrm{EQ}}$-TRS,
organized by group. Each rule is given with its formal name (matching the
constructor of the $\mathrm{Step}$ relation in the
formalization), its $\mathrm{LND}_{\mathrm{EQ}}$ mnemonic, and a
mathematical description. The notation follows Section~\ref{ch:rewrite-system}:
$p \rew q$ denotes a single rewrite step from~$p$ to~$q$.

\subsection{Group I: Path Algebra (8 rules)}

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em]
  \item $\mathit{symm\_refl}$ \hfill \textbf{(sr)} \\
    $\inv{\refl(a)} \;\rew\; \refl(a)$.

  \item $\mathit{symm\_symm}$ \hfill \textbf{(ss)} \\
    $\inv{(\inv{p})} \;\rew\; p$.

  \item $\mathit{trans\_refl\_left}$ \hfill \textbf{(lrr)} \\
    $\refl(a) \comp p \;\rew\; p$.

  \item $\mathit{trans\_refl\_right}$ \hfill \textbf{(rrr)} \\
    $p \comp \refl(b) \;\rew\; p$.

  \item $\mathit{trans\_symm}$ \hfill \textbf{(tr)} \\
    $p \comp \inv{p} \;\rew\; \refl(a)$.

  \item $\mathit{symm\_trans}$ \hfill \textbf{(tsr)} \\
    $\inv{p} \comp p \;\rew\; \refl(b)$.

  \item $\mathit{symm\_trans\_congr}$ \hfill \textbf{(stss)} \\
    $\inv{(p \comp q)} \;\rew\; \inv{q} \comp \inv{p}$.

  \item $\mathit{trans\_assoc}$ \hfill \textbf{(tt)} \\
    $(p \comp q) \comp r \;\rew\; p \comp (q \comp r)$.
\end{enumerate}

\subsection{Group II: Type-Former $\beta$/$\eta$-Rules (17 rules)}

\paragraph{Map decomposition.}
\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=9]
  \item $\mathit{map2\_subst}$ \hfill \textbf{(mx2l1)} \\
    $\mapTwo(f, p, q) \;\rew\; \mapRight(f, a_1, q) \comp \mapLeft(f, p, b_2)$.
\end{enumerate}

\paragraph{Product rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, resume]
  \item $\mathit{prod\_fst\_beta}$ \hfill \textbf{(mx2l2)} \\
    $\fst(\prodMk(p, q)) \;\rew\; p$.

  \item $\mathit{prod\_snd\_beta}$ \hfill \textbf{(mx2r1)} \\
    $\snd(\prodMk(p, q)) \;\rew\; q$.

  \item $\mathit{prod\_rec\_beta}$ \hfill \textbf{(mx2r2)} \\
    $\mathrm{rec}(f) \circ \prodMk(p, q) \;\rew\; \mapTwo(f, p, q)$.

  \item $\mathit{prod\_eta}$ \hfill \textbf{(mxetaProd)} \\
    $\prodMk(\fst(r), \snd(r)) \;\rew\; r$.

  \item $\mathit{prod\_mk\_symm}$ \hfill \textbf{(mx3l)} \\
    $\inv{\prodMk(p, q)} \;\rew\; \prodMk(\inv{p}, \inv{q})$.

  \item $\mathit{prod\_map\_congrArg}$ \hfill \textbf{(mxc)} \\
    $\congrArgOp(f, \prodMk(p, q)) \;\rew\; \prodMk(\congrArgOp(\fst \circ f, p),
    \congrArgOp(\snd \circ f, q))$.
\end{enumerate}

\paragraph{Sigma type rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, resume]
  \item $\mathit{sigma\_fst\_beta}$ \hfill \textbf{(mxsigmaFst)} \\
    $\sigmaFst(\sigmaMk(p, q)) \;\rew\; \ofEq(\toEq(p))$.

  \item $\mathit{sigma\_snd\_beta}$ \hfill \textbf{(mxsigmaSnd)} \\
    $\sigmaSnd(\sigmaMk(p, q)) \;\rew\; \ofEq(\toEq(q))$.

  \item $\mathit{sigma\_eta}$ \hfill \textbf{(mxetaSigma)} \\
    $\sigmaMk(\sigmaFst(r), \sigmaSnd(r)) \;\rew\; r$.

  \item $\mathit{sigma\_mk\_symm}$ \hfill \textbf{(smsigma)} \\
    $\inv{\sigmaMk(p, q)} \;\rew\; \sigmaMk(\inv{p}, \inv{q'})$
    where $q'$ incorporates the transport correction.
\end{enumerate}

\paragraph{Sum type rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, resume]
  \item $\mathit{sum\_rec\_inl\_beta}$ \hfill \textbf{(mxcase)} \\
    $(\mathrm{rec}(f, g))_*(\inlOp_*(p)) \;\rew\; f_*(p)$.

  \item $\mathit{sum\_rec\_inr\_beta}$ \hfill \textbf{(mxcase)} \\
    $(\mathrm{rec}(f, g))_*(\inrOp_*(q)) \;\rew\; g_*(q)$.
\end{enumerate}

\paragraph{Function type rules.}
\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, resume]
  \item $\mathit{fun\_app\_beta}$ \hfill \textbf{(mxlam)} \\
    $\app(\lamCongr(p), a) \;\rew\; p(a)$.

  \item $\mathit{fun\_eta}$ \hfill \textbf{(mxetaFun)} \\
    $\lamCongr(\lambda x.\, \app(q, x)) \;\rew\; q$.

  \item $\mathit{lam\_congr\_symm}$ \hfill \textbf{(mx3r)} \\
    $\inv{\lamCongr(p)} \;\rew\; \lamCongr(\lambda x.\, \inv{p(x)})$.
\end{enumerate}

\paragraph{Dependent application.}
\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, resume]
  \item $\mathit{apd\_refl}$ \\
    $\apd(f, \refl(a)) \;\rew\; \refl(f(a))$.
\end{enumerate}

\subsection{Group III: Transport Rules (5 rules)}

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=26]
  \item $\mathit{transport\_refl\_beta}$ \\
    $\tr_D(\refl(a), x) \;\rew\; x$.

  \item $\mathit{transport\_trans\_beta}$ \\
    $\tr_D(p \comp q, x) \;\rew\; \tr_D(q, \tr_D(p, x))$.

  \item $\mathit{transport\_symm\_left\_beta}$ \\
    $\tr_D(\inv{p}, \tr_D(p, x)) \;\rew\; x$.

  \item $\mathit{transport\_symm\_right\_beta}$ \\
    $\tr_D(p, \tr_D(\inv{p}, y)) \;\rew\; y$.

  \item $\mathit{transport\_sigmaMk\_fst\_beta}$ \\
    $\fst(\tr_\Sigma(\sigmaMk(p, q), x)) \;\rew\; \tr_D(p, \fst(x))$.
\end{enumerate}

\subsection{Group IV: Context Rules (16 rules)}

Let $C : \Context(A, B)$ throughout.

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=31]
  \item $\mathit{context\_congr}$ \\
    $p \rew q \implies C[p] \;\rew\; C[q]$ \hfill (context congruence).

  \item $\mathit{context\_map\_symm}$ \hfill \textbf{(smss)} \\
    $\inv{C[p]} \;\rew\; C[\inv{p}]$.

  \item $\mathit{context\_tt\_cancel\_left}$ \hfill \textbf{(ttsv)} \\
    $C[p] \comp (C[\inv{p}] \comp v) \;\rew\; C[p \comp \inv{p}] \comp v$.

  \item $\mathit{context\_tt\_cancel\_right}$ \hfill \textbf{(tstu)} \\
    $(v \comp C[p]) \comp C[\inv{p}] \;\rew\; v \comp C[p \comp \inv{p}]$.

  \item $\mathit{context\_subst\_left\_beta}$ \hfill \textbf{(tsbll)} \\
    $r \comp C[p] \;\rew\; \substL(C, r, p)$.

  \item $\mathit{context\_subst\_left\_of\_right}$ \\
    $\substL(C, \substR(C, p, t), q) \;\rew\; \substR(C, p, t \comp C[q])$.

  \item $\mathit{context\_subst\_left\_assoc}$ \hfill \textbf{(tsblr)} \\
    $\substL(C, r, p) \comp t \;\rew\; r \comp \substR(C, p, t)$.

  \item $\mathit{context\_subst\_right\_beta}$ \hfill \textbf{(tsbrl)} \\
    $C[p] \comp t \;\rew\; \substR(C, p, t)$.

  \item $\mathit{context\_subst\_right\_assoc}$ \hfill \textbf{(tsbrr)} \\
    $\substR(C, p, t) \comp u \;\rew\; \substR(C, p, t \comp u)$.

  \item $\mathit{context\_subst\_left\_refl\_right}$ \hfill \textbf{(slr)} \\
    $\substL(C, \refl, p) \;\rew\; C[p]$.

  \item $\mathit{context\_subst\_left\_refl\_left}$ \hfill \textbf{(slss)} \\
    $\substL(C, \substL(C, r, \refl), p) \;\rew\; \substL(C, r, p)$.

  \item $\mathit{context\_subst\_right\_refl\_left}$ \hfill \textbf{(srr)} \\
    $\substR(C, p, \refl) \;\rew\; C[p]$.

  \item $\mathit{context\_subst\_right\_refl\_right}$ \hfill \textbf{(srrrr)} \\
    $\substR(C, \refl, \substR(C, p, t)) \;\rew\; \substR(C, p, t)$.

  \item $\mathit{context\_subst\_left\_idempotent}$ \hfill \textbf{(slsss)} \\
    $\substL(C, C[\refl], p) \;\rew\; C[p]$.

  \item $\mathit{context\_subst\_right\_cancel\_inner}$ \hfill \textbf{(srsr)} \\
    $\substR(C, p, \substR(C, \refl, t)) \;\rew\; \substR(C, p, t)$.

  \item $\mathit{context\_subst\_right\_cancel\_outer}$ \\
    $\substR(C, p, \substR(C, q, t)) \;\rew\; \substR(C, p \comp q, t)$
    \hfill (under appropriate conditions).
\end{enumerate}

\subsection{Group V: Dependent Context Rules (12 rules)}

Let $D : \DepContext(A, B)$ throughout. The rules are direct analogues of
Group~IV with the additional transport data required by the dependency:

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=47]
  \item $\mathit{depContext\_congr}$ \\
    $p \rew q \implies D[p] \;\rew\; D[q]$.

  \item $\mathit{depContext\_map\_symm}$ \\
    $\inv{D[p]} \;\rew\; D[\inv{p}]$.

  \item $\mathit{depContext\_subst\_left\_beta}$ \\
    $r \comp D[p] \;\rew\; \substL(D, r, p)$.

  \item $\mathit{depContext\_subst\_left\_assoc}$ \\
    $\substL(D, r, p) \comp t \;\rew\; r \comp \substR(D, p, t)$.

  \item $\mathit{depContext\_subst\_right\_beta}$ \\
    $D[p] \comp t \;\rew\; \substR(D, p, t)$.

  \item $\mathit{depContext\_subst\_right\_assoc}$ \\
    $\substR(D, p, t) \comp u \;\rew\; \substR(D, p, t \comp u)$.

  \item $\mathit{depContext\_subst\_left\_refl\_right}$ \\
    $\substL(D, \refl, p) \;\rew\; D[p]$.

  \item $\mathit{depContext\_subst\_left\_refl\_left}$ \\
    $\substL(D, \substL(D, r, \refl), p) \;\rew\; \substL(D, r, p)$.

  \item $\mathit{depContext\_subst\_right\_refl\_left}$ \\
    $\substR(D, p, \refl) \;\rew\; D[p]$.

  \item $\mathit{depContext\_subst\_right\_refl\_right}$ \\
    $\substR(D, \refl, \substR(D, p, t)) \;\rew\; \substR(D, p, t)$.

  \item $\mathit{depContext\_subst\_left\_idempotent}$ \\
    $\substL(D, D[\refl], p) \;\rew\; D[p]$.

  \item $\mathit{depContext\_subst\_right\_cancel\_inner}$ \\
    $\substR(D, p, \substR(D, \refl, t)) \;\rew\; \substR(D, p, t)$.
\end{enumerate}

\subsection{Group VI: Bi-Context Rules (8 rules)}

These rules govern the congruence properties of binary contexts
$\BiContext(A, B, C)$ and dependent binary contexts $\mathrm{DepBiContext}$:

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=59]
  \item $\mathit{depBiContext\_mapLeft\_congr}$ \\
    $p \rew q \implies \mapLeft(D_2, p, b) \;\rew\; \mapLeft(D_2, q, b)$.

  \item $\mathit{depBiContext\_mapRight\_congr}$ \\
    $p \rew q \implies \mapRight(D_2, a, p) \;\rew\; \mapRight(D_2, a, q)$.

  \item $\mathit{depBiContext\_map2\_congr\_left}$ \\
    $p \rew q \implies \mapTwo(D_2, p, r) \;\rew\; \mapTwo(D_2, q, r)$.

  \item $\mathit{depBiContext\_map2\_congr\_right}$ \\
    $p \rew q \implies \mapTwo(D_2, r, p) \;\rew\; \mapTwo(D_2, r, q)$.

  \item $\mathit{biContext\_mapLeft\_congr}$ \\
    $p \rew q \implies \mapLeft(B_2, p, b) \;\rew\; \mapLeft(B_2, q, b)$.

  \item $\mathit{biContext\_mapRight\_congr}$ \\
    $p \rew q \implies \mapRight(B_2, a, p) \;\rew\; \mapRight(B_2, a, q)$.

  \item $\mathit{biContext\_map2\_congr\_left}$ \\
    $p \rew q \implies \mapTwo(B_2, p, r) \;\rew\; \mapTwo(B_2, q, r)$.

  \item $\mathit{biContext\_map2\_congr\_right}$ \\
    $p \rew q \implies \mapTwo(B_2, r, p) \;\rew\; \mapTwo(B_2, r, q)$.
\end{enumerate}

\subsection{Group VII: Map Congruence Rules (4 rules)}

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=67]
  \item $\mathit{mapLeft\_congr}$ \\
    $p \rew q \implies \mapLeft(f, p, b) \;\rew\; \mapLeft(f, q, b)$.

  \item $\mathit{mapRight\_congr}$ \\
    $p \rew q \implies \mapRight(f, a, p) \;\rew\; \mapRight(f, a, q)$.

  \item $\mathit{mapLeft\_ofEq}$ \hfill \textbf{(mxp)} \\
    $\mapLeft(f, \ofEq(h), b) \;\rew\; \ofEq(\congrArgOp(\lambda x.\, f\,x\,b,\, h))$.

  \item $\mathit{mapRight\_ofEq}$ \hfill \textbf{(nxp)} \\
    $\mapRight(f, a, \ofEq(h)) \;\rew\; \ofEq(\congrArgOp(f\,a,\, h))$.
\end{enumerate}

\subsection{Group VIII: Structural Closure (4 rules)}

These rules propagate single-step rewrites through all path constructors,
ensuring that the rewrite relation is a congruence:

\begin{enumerate}[label=\textbf{R\arabic*.}, leftmargin=3.5em, start=71]
  \item $\mathit{symm\_congr}$ \\
    $p \rew q \implies \inv{p} \;\rew\; \inv{q}$.

  \item $\mathit{trans\_congr\_left}$ \\
    $p \rew q \implies p \comp r \;\rew\; q \comp r$.

  \item $\mathit{trans\_congr\_right}$ \\
    $q \rew r \implies p \comp q \;\rew\; p \comp r$.

  \item $\mathit{context\_congr}$ \\
    $p \rew q \implies C[p] \;\rew\; C[q]$ \hfill (already listed as R31).
\end{enumerate}

\bigskip

\begin{remark}
  The formalization defines 75 distinct constructors for the
  $\mathrm{Step}$ relation. The appendix listing above follows the
  earlier convention (R1--R74) in which context congruence (R31) appears
  in both Group~IV and Group~VIII; two additional transport rules for
  dependent sigma types (\textit{transport\_sigmaMk\_dep\_beta} and
  \textit{subst\_sigmaMk\_dep\_beta}) were added to the formalization
  after the original numbering was established. The earlier convention of
  76 in~\cite{RDQO18} listed certain rules in multiple groups for
  expository clarity.
\end{remark}


%%%% Bibliography %%%%

\Acknowledgements{Not applicable.}

\bibliographystyle{BSLbibstyle}
\bibliography{references}

\end{document}
