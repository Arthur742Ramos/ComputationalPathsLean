% % ----------------------------------------------------------
\chapter{Código Java do DDE2}
\label{chap:dde2java}
% % ----------------------------------------------------------






\begin{lstlisting}[caption={Código em linguagem de programação Java do DDE2},label=dde2java]

/*
 *    DDE.java
 *    Copyright (C) 2015 Maciel, Santos, Barros 
 *    @authors Bruno I. F. Maciel (bifm@cin.ufpe.br)
 *    			Silas Garrido T. de Carvalho Santos (sgtcs@cin.ufpe.br)
 *             	Roberto S. M. Barros (roberto@cin.ufpe.br) 
 *             
 *    @version $Version: 1 $
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Drift Detection Ensemble (DDE),
 * published as:
 * <p> Bruno I. F. Maciel, Silas Garrido T. C. Santos and Roberto S. M. Barros: 
 *     A Lightweight Concept Drift Detection Ensemble. 
 *     27th IEEE International Conference on Tools with Artificial Intelligence 
 *     (ICTAI) Vietri sul Mare, Italy, November 9-11, 2015</p>
 */

package moa.classifiers.drift;

import moa.classifiers.meta.WEKAClassifier;
import java.util.LinkedList;
import java.util.List;
import moa.classifiers.AbstractClassifier;
import moa.classifiers.Classifier;
import moa.classifiers.core.driftdetection.ChangeDetector;
import moa.core.Measurement;
import moa.options.ClassOption;
import moa.options.IntOption;
import weka.core.Instance;
import weka.core.Utils;

public class DDE2 extends AbstractClassifier  {
    private static final long serialVersionUID = 1L;
	
    @Override
    public String getPurposeString() {
        return "Classifier that replaces the current classifier with a new one when a change is detected in accuracy.";
    }

    public ClassOption baseLearnerOption = new ClassOption("baseLearner", 'l',
            "Classifier to train.", Classifier.class, "bayes.NaiveBayes");

    public IntOption ensembleSizeOption = new IntOption(
            "size", 'n',
            "Number of detectors in the ensemble.",
            4, 2, 7);
    
    public IntOption sensibilityOption = new IntOption(
            "sensibility", 's',
            "Number of detectors needed to identify warning or drift.",
            1, 1, 7);
    
    public ClassOption driftDetMeth1Option = new ClassOption(
    		"driftDetMeth1", 't',
            "Drift detection method 1 to use.", 
            ChangeDetector.class, "HDDM_A_Test");
        
    public ClassOption driftDetMeth2Option = new ClassOption(
    		"driftDetMeth2", 'u',
            "Drift detection method 2 to use.", 
            ChangeDetector.class, "HDDM_W_Test");
    
    public ClassOption driftDetMeth3Option = new ClassOption(
    		"driftDetMeth3", 'v',
            "Drift detection method 3 to use.", 
            ChangeDetector.class, "DDM");
    
    public ClassOption driftDetMeth4Option = new ClassOption(
    		"driftDetMeth4", 'w',
            "Drift detection method 4 to use.", 
            ChangeDetector.class, "ADWINChangeDetector");

    public ClassOption driftDetMeth5Option = new ClassOption(
    		"driftDetMeth5", 'x',
            "Drift detection method 5 to use.", 
            ChangeDetector.class, "STEPD");

    public ClassOption driftDetMeth6Option = new ClassOption(
    		"driftDetMeth6", 'y',
            "Drift detection method 6 to use.", 
            ChangeDetector.class, "EWMAChartDM");

    public ClassOption driftDetMeth7Option = new ClassOption(
    		"driftDetMeth7", 'z',
            "Drift detection method 7 to use.", 
            ChangeDetector.class, "SeqDrift2ChangeDetector");
    
   
    protected Classifier classifier; 
    protected Classifier newclassifier; 
    protected int changeDetected = 0;
    protected int warningDetected = 0;
    protected boolean newClassifierReset;
    
	protected static final int MAX_METHODS = 7;
	protected static final int MAX_WAIT = 100;
	protected ChangeDetector [] driftDetMeth = new ChangeDetector[MAX_METHODS];

    protected int [] result = new int [MAX_METHODS];
    protected int [] incontrol_level = new int [MAX_METHODS];
    protected int [] warning_level = new int [MAX_METHODS];
    protected int [] outcontrol_level = new int [MAX_METHODS];    

    protected int [] countDrift = new int [MAX_METHODS];    
    protected int warn, drift;

    protected int ensembleSize, sensibility;
    
    protected Double prediction;
    
    @Override
    public void resetLearningImpl() {
    	
        this.classifier = ((Classifier) getPreparedClassOption(this.baseLearnerOption)).copy();
        this.newclassifier = this.classifier.copy();
        
        this.classifier.resetLearning();
        this.newclassifier.resetLearning();
        
        this.driftDetMeth[0] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth1Option)).copy(); 
        this.driftDetMeth[1] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth2Option)).copy();
        this.driftDetMeth[2] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth3Option)).copy();
        this.driftDetMeth[3] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth4Option)).copy(); 
        this.driftDetMeth[4] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth5Option)).copy();
        this.driftDetMeth[5] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth6Option)).copy();
        this.driftDetMeth[6] = ((ChangeDetector) getPreparedClassOption(this.driftDetMeth7Option)).copy();
        
        this.newClassifierReset = false;  
        
        this.ensembleSize = this.ensembleSizeOption.getValue();
        this.sensibility = this.sensibilityOption.getValue();
        
        for (int i = 0; i < this.ensembleSize; i++) {
        	this.incontrol_level [i] = 0;
        	this.warning_level [i] = 0;
        	this.outcontrol_level [i] = 0;             	        	
        }
    }
    
    @Override
    public void trainOnInstanceImpl(Instance inst) {        
        int trueClass = (int) inst.classValue();
        
        if (Utils.maxIndex(this.classifier.getVotesForInstance(inst)) == trueClass) 
        	this.prediction = 0.0;
        else 
            this.prediction = 1.0;
        
        this.warn =	this.drift = 0;
        
        for (int i = 0; i < this.ensembleSize; i++) {       	
            if (this.result[i] != DriftDetectionMethodClassifier.DDM_OUTCONTROL_LEVEL 
            		|| this.countDrift[i] > MAX_WAIT) {  // Method should not wait
            	this.countDrift [i] = 0; 
            	this.driftDetMeth[i].input(this.prediction);        	

            	if (this.driftDetMeth[i].getChange()) {
            		this.result[i] = DriftDetectionMethodClassifier.DDM_OUTCONTROL_LEVEL;            	
            		this.drift++;
                    this.countDrift[i]++;
            	} else            		
            	    if (this.driftDetMeth[i].getWarningZone()) {
            		    this.result[i] = DriftDetectionMethodClassifier.DDM_WARNING_LEVEL;
            		    this.warn++;
            	    } else
                    	this.result[i] = DriftDetectionMethodClassifier.DDM_INCONTROL_LEVEL;
            } else {  // Method is waiting
            	this.driftDetMeth[i].input(this.prediction);  
            	this.drift++;
                this.countDrift[i]++;
            }
        }
        
        if (this.drift >= this.sensibility) { // DDE Outcontrol
        	this.changeDetected++;
            this.classifier = this.newclassifier;
            if (this.classifier instanceof WEKAClassifier) 
                ((WEKAClassifier) this.classifier).buildClassifier();
            
            this.newclassifier = ((Classifier) getPreparedClassOption(
            									this.baseLearnerOption)).copy();
            this.newclassifier.resetLearning();
            
            for (int i = 0; i < this.ensembleSize; i++) {           	
            	if (this.result[i] != DriftDetectionMethodClassifier.DDM_OUTCONTROL_LEVEL)
            		this.driftDetMeth[i].resetLearning();
                this.result[i] = DriftDetectionMethodClassifier.DDM_INCONTROL_LEVEL;
            }            
        } else
        	if ( (this.warn+this.drift) >= this.sensibility ){   	 
                this.warningDetected++;
	            if (newClassifierReset == true) {
	            	this.newclassifier.resetLearning();
	                newClassifierReset = false;
	            }
                this.newclassifier.trainOnInstance(inst);
            } else 
        	     newClassifierReset = true;
        
        this.classifier.trainOnInstance(inst);
    }
    
    public double[] getVotesForInstance(Instance inst) {
        return this.classifier.getVotesForInstance(inst);
    }

    @Override
    public boolean isRandomizable() {
        return true;
    }

    @Override
    public void getModelDescription(StringBuilder out, int indent) {
        ((AbstractClassifier) this.classifier).getModelDescription(out, indent);
    }

    @Override
    protected Measurement[] getModelMeasurementsImpl() {
        List<Measurement> measurementList = new LinkedList<Measurement>();
        measurementList.add(new Measurement("Change detected", this.changeDetected));
        measurementList.add(new Measurement("Warning detected", this.warningDetected));
        Measurement[] modelMeasurements = ((AbstractClassifier) this.classifier).getModelMeasurements();
        if (modelMeasurements != null) {
            for (Measurement measurement : modelMeasurements) {
                measurementList.add(measurement);
            }
        }
        this.changeDetected = 0;
        this.warningDetected = 0;
        return measurementList.toArray(new Measurement[measurementList.size()]);
    }}



\end{lstlisting}


\section{test}
sdfgsdfg 
fg d
gfdg dg